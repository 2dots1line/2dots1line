
### **Part 2: Neo4j V9.0 Graph Schema (Conceptual & Cypher DDL)**

**Location:** `packages/database/src/neo4j/schema.cypher` (A script to be run for setup)

This graph database is the **System of Relationships**. It models the rich, semantic connections *between* the core knowledge entities persisted in PostgreSQL.

**Core Node Labels & Key Properties (Mirrored from PostgreSQL for linkage):**

*   **`:User`**
    *   `userId` (String, Unique constraint, Indexed) - Mirrors `User.user_id`
*   **`:MemoryUnit`**
    *   `muid` (String, Unique constraint, Indexed) - Mirrors `MemoryUnit.muid`
    *   `userId` (String, Indexed) - For user-scoped graph traversals
    *   `title` (String)
    *   `creation_ts` (Datetime, Indexed)
    *   `importance_score` (Float)
*   **`:Concept`**
    *   `id` (String, Unique constraint, Indexed) - Mirrors `Concept.concept_id`
    *   `userId` (String, Indexed)
    *   `name` (String, Indexed)
    *   `type` (String, Indexed) - Crucial for typed queries
    *   `status` (String, Indexed) - 'active', 'merged'
*   **`:DerivedArtifact`**
    *   `id` (String, Unique constraint, Indexed) - Mirrors `DerivedArtifact.artifact_id`
    *   `userId` (String, Indexed)
    *   `artifact_type` (String, Indexed) - e.g., 'insight_summary', 'cycle_report'
*   **`:Community`**
    *   `community_id` (String, Unique constraint, Indexed) - Mirrors `Community.community_id`
    *   `userId` (String, Indexed)
    *   `name` (String)

**Core Relationship Types & Key Properties:**

*   **`[:AUTHORED_BY {timestamp: Datetime}]`**
    *   `(MemoryUnit)-[:AUTHORED_BY]->(User)`
*   **`[:HIGHLIGHTS {weight: Float, significance_score: Float, detected_by: String}]`**
    *   `(MemoryUnit)-[:HIGHLIGHTS]->(Concept)`
*   **`[:RELATED_TO {relationship_label: String, weight: Float, description: String, source: String, created_ts: Datetime}]`**
    *   `(Concept)-[:RELATED_TO]->(Concept)`
    *   `(MemoryUnit)-[:RELATED_TO]->(MemoryUnit)`
    *   `(MemoryUnit)-[:RELATED_TO]->(Concept)` (And vice-versa)
    *   *(The `relationship_label` comes from a controlled vocabulary, e.g., "causes", "is_analogy_for", "contradicts")*
*   **`[:DERIVED_FROM {contribution_type: String}]`**
    *   `(DerivedArtifact)-[:DERIVED_FROM]->(MemoryUnit)`
    *   `(DerivedArtifact)-[:DERIVED_FROM]->(Concept)`
*   **`[:BELONGS_TO_COMMUNITY]`**
    *   `(Concept)-[:BELONGS_TO_COMMUNITY]->(Community)`
*   **`[:MERGED_INTO]`** (For ontology management by `InsightEngine`)
    *   `(Concept {status:'merged'})-[:MERGED_INTO]->(Concept {status:'active'})`

**Cypher DDL for Constraints & Indexes:**
```cypher
// Unique Constraints (automatically create backing indexes)
CREATE CONSTRAINT user_userId_unique IF NOT EXISTS FOR (u:User) REQUIRE u.userId IS UNIQUE;
CREATE CONSTRAINT memoryunit_muid_unique IF NOT EXISTS FOR (mu:MemoryUnit) REQUIRE mu.muid IS UNIQUE;
CREATE CONSTRAINT concept_id_unique IF NOT EXISTS FOR (c:Concept) REQUIRE c.id IS UNIQUE;
CREATE CONSTRAINT derivedartifact_id_unique IF NOT EXISTS FOR (da:DerivedArtifact) REQUIRE da.id IS UNIQUE;
CREATE CONSTRAINT community_community_id_unique IF NOT EXISTS FOR (co:Community) REQUIRE co.community_id IS UNIQUE;

// Indexes for Performance
CREATE INDEX user_userId_idx IF NOT EXISTS FOR (u:User) ON (u.userId);

CREATE INDEX memoryunit_userId_idx IF NOT EXISTS FOR (mu:MemoryUnit) ON (mu.userId);
CREATE INDEX memoryunit_creation_ts_idx IF NOT EXISTS FOR (mu:MemoryUnit) ON (mu.creation_ts);
CREATE INDEX memoryunit_importance_score_idx IF NOT EXISTS FOR (mu:MemoryUnit) ON (mu.importance_score);

CREATE INDEX concept_userId_idx IF NOT EXISTS FOR (c:Concept) ON (c.userId);
CREATE INDEX concept_name_idx IF NOT EXISTS FOR (c:Concept) ON (c.name);
CREATE INDEX concept_type_idx IF NOT EXISTS FOR (c:Concept) ON (c.type);
CREATE INDEX concept_status_idx IF NOT EXISTS FOR (c:Concept) ON (c.status);

CREATE INDEX derivedartifact_userId_idx IF NOT EXISTS FOR (da:DerivedArtifact) ON (da.userId);
CREATE INDEX derivedartifact_artifact_type_idx IF NOT EXISTS FOR (da:DerivedArtifact) ON (da.artifact_type);

CREATE INDEX community_userId_idx IF NOT EXISTS FOR (co:Community) ON (co.userId);

// Example Relationship Property Index (if specific queries benefit significantly)
// CREATE INDEX rel_related_to_label_idx IF NOT EXISTS FOR ()-[r:RELATED_TO]-() ON (r.relationship_label);
// CREATE INDEX rel_related_to_weight_idx IF NOT EXISTS FOR ()-[r:RELATED_TO]-() ON (r.weight);
```

---

### **Part 3: Weaviate V9.0 Vector Schema (JSON Format)**

**Location:** `packages/database/src/weaviate/schema.json`

This vector database is the **System of Semantics**. It provides fast, meaning-based search across all textual content.

```json
{
  "classes": [
    {
      "class": "UserKnowledgeItem",
      "description": "A unified searchable item representing textual content from any source entity (MemoryUnit content, Concept description, DerivedArtifact narrative, ConversationMessage content, Reflection content, etc.). This is the semantic index for the user's entire knowledge graph.",
      "vectorizer": "none", // Embeddings are generated externally by the application
      "properties": [
        {
          "name": "externalId",
          "dataType": ["uuid"],
          "description": "The UUID of this specific text chunk or high-level entity text. If chunked, this is a newly generated UUID for the chunk."
        },
        {
          "name": "userId",
          "dataType": ["string"], // Using string for potential future flexibility, but maps to User.user_id (UUID)
          "description": "The user this item belongs to.",
          "indexInverted": true
        },
        {
          "name": "sourceEntityType",
          "dataType": ["string"],
          "description": "The type of the original entity in PostgreSQL this text comes from (e.g., 'MemoryUnit', 'Concept', 'ConversationMessage', 'Reflection', 'DerivedArtifact').",
          "indexInverted": true
        },
        {
          "name": "sourceEntityId",
          "dataType": ["uuid"],
          "description": "The UUID of the original entity in PostgreSQL (e.g., MemoryUnit.muid, Concept.concept_id).",
          "indexInverted": true
        },
        {
          "name": "textContent",
          "dataType": ["text"],
          "description": "The actual text content that is vectorized and made searchable. This could be a full MemoryUnit.content, a Concept.description, or a smaller chunk of a ConversationMessage."
        },
        {
          "name": "title", // Optional title from the source entity
          "dataType": ["text"],
          "description": "Title of the source entity, if applicable (e.g., MemoryUnit.title). For metadata and potential keyword search.",
          "indexInverted": true,
          "tokenization": "word"
        },
        {
          "name": "embeddingModelVersion",
          "dataType": ["string"],
          "description": "Version of the external model used for the vector generation.",
          "indexInverted": true
        },
        {
          "name": "createdAt", // Timestamp of the source entity's creation or the chunk's creation
          "dataType": ["date"],
          "description": "Creation timestamp for temporal filtering.",
          "indexInverted": true
        },
        {
          "name": "importanceScore", // Optional, inherited from MemoryUnit or Conversation
          "dataType": ["number"],
          "description": "Importance score of the source entity, if applicable.",
          "indexInverted": true
        },
        {
          "name": "tags", // Optional, could be keywords extracted or user-defined tags
          "dataType": ["text[]"],
          "description": "Keywords or tags associated with this text content.",
          "indexInverted": true,
          "tokenization": "word" // Ensure tags are searchable as whole words
        }
      ]
    }
  ]
}
```

---
This V9.0 Definitive Database Schema provides a cohesive, complementary, and exhaustive foundation for the entire application. It directly supports all agent workflows, context package requirements, and the overall architectural vision. Terminology is now consistent across all three database designs.