Understood. The `InsightQueryLibrary` is a critical deterministic component that enables the `InsightEngine` to gather the "raw ingredients" (`CompiledCycleData`) for its strategic LLM synthesis call.

This canonical guide will define its purpose, location, structure, example queries (aligned with the "menu of big-picture questions"), and how it interacts with the `InsightEngine` worker.

---

### **Canonical Guide: The V9.1 `InsightQueryLibrary`**

#### **1. Core Job Responsibility & Philosophy**

The `InsightQueryLibrary` is a **deterministic, backend module** responsible for housing and executing a curated set of **pre-defined, parameterized global Cypher queries** against a user's Neo4j knowledge graph. Its sole purpose is to gather the diverse, structured data points that form the `CompiledCycleData` required by the `InsightEngine` worker for its cyclical analysis.

**Philosophy:**
*   **Deterministic & Auditable:** All queries are explicitly defined, version-controlled, and can be reviewed for correctness and performance. The `InsightEngine` LLM does *not* generate these strategic data-gathering queries.
*   **Thematic & Hypothesis-Driven:** Each query in the library is designed to answer a specific "big-picture question" about the user's identity, growth, patterns, or graph health, based on the hypotheses outlined in your "menu of questions."
*   **Efficient Data Aggregation:** Queries are designed to be as efficient as possible, often aggregating data or finding key patterns directly in the graph database.
*   **Raw Data Provider:** The library returns raw, structured query results. It does *not* perform natural language synthesis or interpretation; that is the job of the `InsightEngine`'s LLM.

**Location:** `packages/database/src/neo4j/queries/insight-queries.ts`

#### **2. Structure and Implementation**

The `InsightQueryLibrary` will be implemented as a class that is instantiated with a Neo4j driver instance. Each thematic query from your "menu" will correspond to a public async method in this class.

```typescript
// packages/database/src/neo4j/queries/insight-queries.ts
import { Driver, Session, Result, Record } from 'neo4j-driver';

// Define common result types for clarity
interface ConceptQueryResult { id: string; name: string; type?: string; [key: string]: any; }
interface MemoryUnitQueryResult { muid: string; title: string; creation_ts?: Date; [key: string]: any; }
// ... other specific result types as needed

export class InsightQueryLibrary {
  private driver: Driver;

  constructor(driver: Driver) {
    this.driver = driver;
  }

  private async runQuery(cypher: string, params: Record<string, any>): Promise<Record[]> {
    const session: Session = this.driver.session();
    try {
      const result: Result = await session.run(cypher, params);
      return result.records;
    } catch (error) {
      console.error(`Error executing Cypher query: ${cypher} with params: ${JSON.stringify(params)}`, error);
      throw error; // Or handle more gracefully, perhaps returning empty array
    } finally {
      await session.close();
    }
  }

  // --- Methods corresponding to the "Menu of Big-Picture Questions" ---

  // Category: Identity & Consistency (Query #2 from your list)
  async getTopSalientValues(userId: string, limit: number = 5): Promise<Array<{ name: string; salience: number | null }>> {
    const cypher = `
      MATCH (u:User {userId: $userId})-[:PERCEIVES]->(val:Concept) // Assuming :PERCEIVES links to values
      WHERE val.type = 'value' AND val.salience IS NOT NULL
      RETURN val.name AS name, val.salience AS salience
      ORDER BY val.salience DESC
      LIMIT $limit
    `;
    const records = await this.runQuery(cypher, { userId, limit });
    return records.map(r => ({ name: r.get('name'), salience: r.get('salience') }));
  }

  // Category: Goals & Progress (Query #4 from your list)
  async getStalledGoals(userId: string, cycleStartDate: Date, limit: number = 5): Promise<Array<{ id: string; name: string; lastActivityDate: Date | null }>> {
    // This query needs to find goals whose latest related MemoryUnit is older than cycleStartDate
    const cypher = `
      MATCH (g:Concept {userId: $userId, type: 'goal', status: 'active'}) // Assuming 'active' status for goals
      OPTIONAL MATCH (g)<-[:HIGHLIGHTS]-(m:MemoryUnit)
      WITH g, max(m.creation_ts) AS lastMemoryTimestamp
      WHERE lastMemoryTimestamp IS NULL OR lastMemoryTimestamp < $cycleStartDate
      RETURN g.id AS id, g.name AS name, lastMemoryTimestamp
      ORDER BY COALESCE(lastMemoryTimestamp, datetime('1970-01-01T00:00:00Z')) ASC // Goals with no activity first
      LIMIT $limit
    `;
    // Note: date comparison in Cypher can be tricky with timezones. Ensure consistency.
    // cycleStartDate should be an ISO string or Neo4j DateTime object.
    const records = await this.runQuery(cypher, { userId, cycleStartDate: cycleStartDate.toISOString(), limit });
    return records.map(r => ({
      id: r.get('id'),
      name: r.get('name'),
      lastActivityDate: r.get('lastMemoryTimestamp') ? new Date(r.get('lastMemoryTimestamp')) : null,
    }));
  }

  // Category: Value-Action Alignment (Query #5 - adapted)
  async getValueActionAlignment(userId: string, cycleStartDate: Date): Promise<Array<{ valueName: string; recentActionCount: number }>> {
    // Get top values first (re-using or similar to getTopSalientValues)
    const topValues = await this.getTopSalientValues(userId, 3); // e.g., top 3 values
    if (topValues.length === 0) return [];

    const results = [];
    for (const value of topValues) {
      const cypher = `
        MATCH (val:Concept {userId: $userId, name: $valueName, type: 'value'})
        // Define what constitutes a "concrete action" memory linked to this value.
        // This might involve memories HIGHLIGHTING the value AND also HIGHLIGHTING an 'action_taken' Concept type,
        // or memories with specific keywords. For simplicity, let's count recent memories highlighting the value.
        MATCH (val)<-[:HIGHLIGHTS]-(m:MemoryUnit {userId: $userId})
        WHERE m.creation_ts >= $cycleStartDate
        RETURN count(DISTINCT m) AS recentActionCount
      `;
      const records = await this.runQuery(cypher, { userId, valueName: value.name, cycleStartDate: cycleStartDate.toISOString() });
      results.push({
        valueName: value.name,
        recentActionCount: records[0] ? records[0].get('recentActionCount').toNumber() : 0,
      });
    }
    return results;
  }

  // Category: Emerging Interests & Concept Drift (Query #7 - needs historical data or snapshots)
  async getEmergingInterests(userId: string, cycleStartDate: Date, previousCycleStartDate: Date, limit: number = 5): Promise<Array<{ conceptName: string; type: string; currentCycleMentions: number; previousCycleMentions: number; spikeFactor: number }>> {
    // This is complex as it requires comparing two time periods.
    // One approach: Count mentions in current cycle, count in previous, then calculate delta.
    // This might be better handled by multiple queries or more complex Cypher if performance allows.
    // For now, a conceptual placeholder for the query's intent:
    const cypherCurrent = `
      MATCH (c:Concept {userId: $userId})<-[:HIGHLIGHTS]-(m:MemoryUnit)
      WHERE m.creation_ts >= $cycleStartDate
      RETURN c.id AS conceptId, c.name AS conceptName, c.type AS type, count(m) AS mentions
      ORDER BY mentions DESC
    `;
    const cypherPrevious = `
      MATCH (c:Concept {userId: $userId})<-[:HIGHLIGHTS]-(m:MemoryUnit)
      WHERE m.creation_ts >= $previousCycleStartDate AND m.creation_ts < $cycleStartDate
      RETURN c.id AS conceptId, count(m) AS mentions
    `;
    const currentRecords = await this.runQuery(cypherCurrent, { userId, cycleStartDate: cycleStartDate.toISOString() });
    const previousRecords = await this.runQuery(cypherPrevious, { userId, previousCycleStartDate: previousCycleStartDate.toISOString(), cycleStartDate: cycleStartDate.toISOString() });

    const prevMentionsMap = new Map(previousRecords.map(r => [r.get('conceptId'), r.get('mentions').toNumber()]));
    
    const emerging = currentRecords.map(r => {
      const conceptId = r.get('conceptId');
      const currentMentions = r.get('mentions').toNumber();
      const previousMentions = prevMentionsMap.get(conceptId) || 0;
      return {
        conceptName: r.get('conceptName'),
        type: r.get('type'),
        currentCycleMentions: currentMentions,
        previousCycleMentions: previousMentions,
        // Spike factor: (current - previous) / (previous + 1) to avoid division by zero and normalize
        spikeFactor: previousMentions === 0 && currentMentions > 0 ? currentMentions : (currentMentions - previousMentions) / (previousMentions + 1), 
      };
    }).filter(e => e.spikeFactor > 0.5 && e.currentCycleMentions > 2) // Example threshold for "spike"
      .sort((a,b) => b.spikeFactor - a.spikeFactor)
      .slice(0, limit);
      
    return emerging;
  }
  
  // Category: Knowledge Coverage & Gaps (Query #10)
  async getKnowledgeGaps(userId: string, minSalience: number = 0.7, minEpisodes: number = 3, limit: number = 5): Promise<Array<{ conceptName: string; type: string; salience: number; episodeCount: number }>> {
    const cypher = `
      MATCH (c:Concept {userId: $userId})
      WHERE c.salience >= $minSalience AND c.status = 'active'
      OPTIONAL MATCH (c)<-[:HIGHLIGHTS]-(m:MemoryUnit)
      WITH c, count(m) AS episodeCount
      WHERE episodeCount < $minEpisodes
      RETURN c.name AS conceptName, c.type AS type, c.salience AS salience, episodeCount
      ORDER BY c.salience DESC, episodeCount ASC
      LIMIT $limit
    `;
    const records = await this.runQuery(cypher, { userId, minSalience, minEpisodes, limit });
    return records.map(r => ({
        conceptName: r.get('conceptName'),
        type: r.get('type'),
        salience: r.get('salience'),
        episodeCount: r.get('episodeCount').toNumber()
    }));
  }

  // Category: Sentiment & Well-being (Query #12 - adapted for concepts)
  async getContextsTriggeringStrongSentiment(userId: string, cycleStartDate: Date, sentimentThreshold: number = -0.5, isNegative: boolean = true, limit: number = 5): Promise<Array<{conceptName: string; type: string; averageSentiment: number; count: number}>> {
    // Assumes MemoryUnits have a 'sentiment_score' property
    // Or, sentiment could be a Concept itself linked to MemoryUnits
    const sentimentOperator = isNegative ? '<=' : '>=';
    const cypher = `
      MATCH (m:MemoryUnit {userId: $userId})-[:HIGHLIGHTS]->(c:Concept {userId: $userId})
      WHERE m.creation_ts >= $cycleStartDate AND m.sentiment_score IS NOT NULL AND m.sentiment_score ${sentimentOperator} $sentimentThreshold
      WITH c, avg(m.sentiment_score) AS avgSentiment, count(m) AS memoryCount
      WHERE memoryCount > 1 // Consider contexts mentioned more than once
      RETURN c.name AS conceptName, c.type AS type, avgSentiment, memoryCount
      ORDER BY avgSentiment ${isNegative ? 'ASC' : 'DESC'} // Most negative or most positive
      LIMIT $limit
    `;
    // This requires MemoryUnits to have a sentiment_score. If not, this query needs adaptation
    // to perhaps link to :Emotion concepts.
    // For now, assuming MemoryUnit.sentiment_score for simplicity.
    const records = await this.runQuery(cypher, { userId, cycleStartDate: cycleStartDate.toISOString(), sentimentThreshold, limit });
    return records.map(r => ({
        conceptName: r.get('conceptName'),
        type: r.get('type'),
        averageSentiment: r.get('avgSentiment'),
        count: r.get('memoryCount').toNumber()
    }));
  }
  
  // Category: Narrative & Coherence (Query #19 - simplified for prominent themes)
  async getMostActiveStoryArcs(userId: string, cycleStartDate: Date, limit: number = 3): Promise<Array<{themeName: string; newEpisodesThisCycle: number}>> {
      // This can leverage the Community nodes created by the InsightEngine's ontology phase
      // or look for frequently co-occurring concepts in recent memories.
      // Simpler version: find communities with most new MemoryUnits linked to their concepts.
      const cypher = `
        MATCH (com:Community {userId: $userId})<-[:BELONGS_TO_COMMUNITY]-(c:Concept {userId: $userId})<-[:HIGHLIGHTS]-(m:MemoryUnit {userId: $userId})
        WHERE m.creation_ts >= $cycleStartDate
        RETURN com.name AS themeName, count(DISTINCT m) AS newEpisodes
        ORDER BY newEpisodes DESC
        LIMIT $limit
      `;
      const records = await this.runQuery(cypher, { userId, cycleStartDate: cycleStartDate.toISOString(), limit });
      return records.map(r => ({
          themeName: r.get('themeName'),
          newEpisodesThisCycle: r.get('newEpisodes').toNumber()
      }));
  }


  // ... Implement methods for other queries from your list (#1, #3, #8, #11, #14, #17, #18, #20)
  // Each method will have a carefully crafted Cypher query and parameterization.
  // For example:
  // async getConflictingIdentityFacts(userId: string): Promise<any> { /* ... */ }
  // async getGoalsApproachingTarget(userId: string, daysWindow: number = 30): Promise<any> { /* ... */ }
  // etc.
}
```

#### **3. Integration with `InsightEngine` Worker**

The `InsightEngine` worker will be instantiated with this `InsightQueryLibrary`. In its "Phase I: Data Compilation," it will call these methods sequentially.

```typescript
// workers/insight-worker/src/InsightEngine.ts (Conceptual Snippet)
// ...
const compiledCycleData: Partial<CompiledCycleData> = {}; // Initialize as Partial

// In processCycle method, after instantiating insightQueryLibrary:
compiledCycleData.topSalientValues = await this.insightQueryLibrary.getTopSalientValues(userId);
compiledCycleData.stalledGoals = await this.insightQueryLibrary.getStalledGoals(userId, cycleStartDate);
compiledCycleData.valueActionAlignment = await this.insightQueryLibrary.getValueActionAlignment(userId, cycleStartDate);
compiledCycleData.emergingInterests = await this.insightQueryLibrary.getEmergingInterests(userId, cycleStartDate, previousCycleStartDate);
compiledCycleData.knowledgeGaps = await this.insightQueryLibrary.getKnowledgeGaps(userId);
compiledCycleData.strongSentimentContextsNegative = await this.insightQueryLibrary.getContextsTriggeringStrongSentiment(userId, cycleStartDate, -0.5, true);
compiledCycleData.strongSentimentContextsPositive = await this.insightQueryLibrary.getContextsTriggeringStrongSentiment(userId, cycleStartDate, 0.5, false);
compiledCycleData.mostActiveStoryArcs = await this.insightQueryLibrary.getMostActiveStoryArcs(userId, cycleStartDate);
// ... call other query methods ...

// This full compiledCycleData object is then passed to the LLM via the StrategicSynthesisTool.
// ...
```

#### **4. Schema Dependencies & Assumptions for Queries**

The example queries above make certain assumptions about your Neo4j schema. These need to be consistent with what the `IngestionAnalyst` creates and what your `KnowledgeGraphSchema` defines:

*   `User` nodes have a `userId` property.
*   `Concept` nodes have `userId`, `name`, `type`, `status`, `salience`.
*   `MemoryUnit` nodes have `userId`, `title`, `content_snippet` (or `content`), `creation_ts`, `importance_score`, and potentially `sentiment_score`.
*   `Community` nodes have `userId`, `name`.
*   Relationships like `:HIGHLIGHTS`, `:RELATED_TO`, `:BELONGS_TO_COMMUNITY`, `:PERCEIVES` exist with appropriate properties.

If these differ, the Cypher queries in the library must be adjusted. For instance, your Query #2 sketch uses `(u:User)-[:EMBODIES]->(v:Value)`. My example uses `(u:User)-[:PERCEIVES]->(val:Concept) WHERE val.type = 'value'`. This kind of detail needs to be harmonized with the actual graph structure being built by the `IngestionAnalyst`.

---

This canonical guide for the `InsightQueryLibrary` establishes it as the deterministic heart of the `InsightEngine`'s data gathering phase. It provides a structured, maintainable, and testable way to execute the strategic queries needed to fuel deep insights. The "menu of questions" serves as an excellent blueprint for the methods this library will contain.