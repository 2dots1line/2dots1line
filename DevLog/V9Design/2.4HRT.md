### **Definitive Canonical Guide: The V9.2 `HybridRetrievalTool` (HRT)**

This guide incorporates all peer-review feedback and establishes the HRT as a highly deterministic, configuration-driven component.

**Location:** `packages/tools/retrieval/HybridRetrievalTool.ts`

**Core Principle:** The HRT orchestrates a multi-stage retrieval process. It uses Weaviate for semantic grounding of LLM-provided `key_phrases` into seed entities, then uses a **deterministic `CypherBuilder`** to construct safe, templated queries for Neo4j graph traversal, and finally, a **`HydrationAdapter`** to fetch full content from PostgreSQL. **At no point does an LLM generate or execute Cypher directly.**

**Trigger:** `DialogueAgent` (after its LLM makes a `query_memory` decision and outputs `key_phrases_for_retrieval`) calls `HybridRetrievalTool.execute({ keyPhrasesForRetrieval, userId })`.

**Input:**
*   `keyPhrasesForRetrieval`: An array of strings from the `DialogueAgent`'s LLM.
*   `userId`: The ID of the current user.
*   `retrievalScenario`: (Optional, defaults to 'neighborhood') A key to select a specific Cypher template, e.g., 'neighborhood', 'timeline', 'episodesByConcept'.

**Output:**
*   `AugmentedMemoryContext`: A structured JSON object containing hydrated entities, or a graceful failure object.

---

#### **HRT Internal Sub-Components & Configuration**

1.  **`CypherTemplateRegistry` (Configuration)**
    *   **Location:** `config/cypher_templates.json` (or `.yaml`)
    *   **Content:** A JSON/YAML file containing pre-approved, parameterized Cypher query templates, keyed by `retrievalScenario`.
        ```json
        // config/cypher_templates.json
        {
          "neighborhood": {
            "description": "Finds nodes within N hops of seed entities.",
            "template": "UNWIND $seedEntities AS seed MATCH (startNode) WHERE startNode.id = seed.id CALL { WITH startNode MATCH p=(startNode)-[*1..$hops]-(relatedNode) WHERE relatedNode.userId = $userId RETURN DISTINCT relatedNode.id AS nodeId, labels(relatedNode)[0] AS nodeType LIMIT $limit } RETURN COLLECT(DISTINCT {id: nodeId, type: nodeType}) + $seedEntities AS allRelevantEntities",
            "allowedParams": ["seedEntities", "hops", "limit", "userId"],
            "defaultParams": { "hops": 2, "limit": 20 }
          },
          "episodesByConcept": {
            "description": "Finds MemoryUnits related to a specific Concept.",
            "template": "MATCH (c:Concept {id: $conceptId, userId: $userId})<-[:HIGHLIGHTS]-(mu:MemoryUnit) RETURN COLLECT(DISTINCT {id: mu.muid, type: 'MemoryUnit'}) AS allRelevantEntities LIMIT $limit",
            "allowedParams": ["conceptId", "userId", "limit"],
            "defaultParams": { "limit": 10 }
          }
          // ... other templates ...
        }
        ```

2.  **`CypherBuilder` (Internal HRT Micro-Module)**
    *   **Responsibility:** To safely construct a Cypher query and its parameters.
    *   **Method:** `buildQuery(queryKey: string, runtimeParams: Record<string, any>): { cypher: string, params: Record<string, any> }`
    *   **Logic:**
        1.  Loads the `CypherTemplateRegistry`.
        2.  Retrieves the template and `allowedParams` for the given `queryKey`.
        3.  Validates `runtimeParams` against the `allowedParams` schema.
        4.  Applies `ParamGuard` logic (see below).
        5.  Safely injects validated `runtimeParams` into the Cypher template (e.g., replacing `$paramName` placeholders).
        6.  Returns the final `{ cypher, params }` object.

3.  **`ParamGuard` (Internal HRT Micro-Module)**
    *   **Responsibility:** Enforces runtime constraints on query parameters.
    *   **Logic:** Contains rules like `if (params.limit > 100) throw Error(...)`, `if (params.hops > 3) throw Error(...)`. Called by the `CypherBuilder`.

4.  **`HydrationAdapter` (Internal HRT Micro-Module)**
    *   **Responsibility:** To map Neo4j query results (node IDs and types) to the correct PostgreSQL repository calls for content hydration.
    *   **Method:** `hydrateEntities(nodes: Array<{id: string, type: string}>, userId: string): Promise<AugmentedMemoryContext>`
    *   **Logic:**
        1.  Type-buckets the input `nodes` (e.g., separate lists of `MemoryUnit` IDs, `Concept` IDs).
        2.  Performs batch `findByIds` calls to the respective repositories (e.g., `memoryRepo.findByIds(muids, userId)`).
        3.  Applies de-duplication and prioritization logic (e.g., prioritize original seed entities, sort by recency or degree if available).
        4.  Constructs the `AugmentedMemoryContext` object.

---

#### **Detailed HRT `execute` Workflow (V9.2)**

**Step 1: Key Phrase Pre-processing & Truncation (Deterministic)**

*   **Input:** `keyPhrasesForRetrieval` array from `DialogueAgent` LLM.
*   **Action:**
    1.  **Safety Check:** If `keyPhrasesForRetrieval.length > MAX_KEY_PHRASES` (e.g., `MAX_KEY_PHRASES = 5`, configurable), truncate the list. Prioritize shorter, more specific phrases or use TF-IDF if available.
    2.  Log any truncation for monitoring.
*   **Output:** A sanitized list of `processedKeyPhrases`.

**Step 2: Semantic Grounding & Seed Entity Identification (Weaviate)**

*   **Input:** `processedKeyPhrases`, `userId`.
*   **Action:**
    1.  For each `phrase` in `processedKeyPhrases`:
        *   Perform a `nearText` vector search in Weaviate's `UserKnowledgeItem` class (filtered by `userId`).
        *   Retrieve top M (e.g., M=2) `sourceEntityId` and `sourceEntityType`.
    2.  Consolidate and de-duplicate results to form a list of unique `seedEntities` (e.g., `[{id: 'c123', type:'Concept'}, {id:'m456',type:'MemoryUnit'}]`).
*   **Output:** `seedEntities` list.
*   **Failure Mode:** If Weaviate returns no matches or is unavailable, `seedEntities` might be empty. HRT can either return an empty context or proceed to Neo4j with a broader, non-seed-based discovery query (if such templates exist).

**Step 3: Cypher Query Construction (HRT `CypherBuilder`)**

*   **Input:** `seedEntities`, `userId`, `retrievalScenario` (defaults to 'neighborhood').
*   **Action:**
    1.  The HRT calls `this.cypherBuilder.buildQuery(retrievalScenario, { seedEntities, userId, /* other scenario-specific params */ })`.
    2.  `CypherBuilder` loads `config/cypher_templates.json`, selects the template, validates params, applies `ParamGuard`, and constructs the query.
*   **Output:** `{ cypher: string, params: Record<string, any> }`.
*   **Failure Mode:** If `ParamGuard` fails or template is missing, throw an error.

**Step 4: Graph Traversal (Neo4j)**

*   **Input:** `{ cypher, params }` from `CypherBuilder`.
*   **Action:** Execute the query against Neo4j using the Neo4j driver.
*   **Output:** A list of `neo4jResults` (e.g., `[{id: 'nodeId1', type: 'Concept'}, ...]`).
*   **Failure Mode:** If Neo4j is down or query times out: Log error. Proceed to Step 6 and return `graph_unavailable` context.

**Step 5: Content Hydration (HRT `HydrationAdapter` & PostgreSQL)**

*   **Input:** `neo4jResults`, `userId`.
*   **Action:**
    1.  The HRT calls `this.hydrationAdapter.hydrateEntities(neo4jResults, userId)`.
    2.  `HydrationAdapter` buckets IDs by type, calls batch repo methods, and assembles the context.
*   **Output:** Populated `AugmentedMemoryContext` object.
*   **Failure Mode (Stale ID):** If a PostgreSQL lookup for an ID fails (entity deleted/stale), log the issue and exclude that entity from the final context.

**Step 6: Return `AugmentedMemoryContext` to `DialogueAgent`**

*   **Action:** Return the assembled `AugmentedMemoryContext`.
    *   **Success:** `{ retrievedMemoryUnits: [...], retrievedConcepts: [...], retrievalSummary: "..." }`
    *   **Partial Failure (e.g., Neo4j down):** `{ retrievedMemoryUnits:[], retrievedConcepts:[], retrievalSummary:"graph_unavailable_could_not_retrieve_full_context" }`
    *   **Total Failure (e.g., Weaviate & Neo4j down):** `{ retrievedMemoryUnits:[], retrievedConcepts:[], retrievalSummary:"memory_system_unavailable" }`

---

#### **Key Safety & Maintainability Features Addressed by This Design:**

*   **No LLM-Generated Cypher:** Eliminates risk of rogue queries or poorly performing Cypher.
*   **Auditable Query Templates:** All possible graph queries are version-controlled and reviewable in `cypher_templates.json`.
*   **Parameter Guarding:** Prevents overly broad or deep traversals.
*   **Deterministic Logic:** The entire HRT flow after receiving `key_phrases` is deterministic code.
*   **Graceful Fallbacks:** Handles scenarios where parts of the persistence layer might be unavailable.
*   **Testability:** Each internal module (`CypherBuilder`, `HydrationAdapter`, individual templates) can be unit-tested.
*   **Schema Drift Mitigation (Checklist item 5):** CI/CD pipeline should include a step to compare the `KnowledgeGraphSchema` in `UserMemoryProfile` (which reflects what the LLM *thinks* the schema is) against the actual Neo4j schema (via `CALL db.schema.visualization()`) and the `cypher_templates.json`. Discrepancies should flag a need for template or `InsightEngine` prompt updates.

---

This V9.2 `HybridRetrievalTool` specification is now far more robust, secure, and aligned with engineering best practices. It precisely defines how the LLM's semantic understanding is safely and deterministically translated into effective knowledge graph retrieval.

Excellent question. To maintain clarity and adhere to our V9.1+ monorepo structure, these new "micro-modules" (`CypherBuilder`, `ParamGuard`, `HydrationAdapter`) should be logically co-located with the `HybridRetrievalTool` itself, as they are its internal, private implementation details.

They are not intended to be shared or used by other parts of the system directly; they are integral components of how the `HybridRetrievalTool` fulfills its contract.

---

### **Placement of `HybridRetrievalTool` Micro-Modules in V9.2 Repo Structure**

The `HybridRetrievalTool` itself lives in `packages/tools/retrieval/`. Its internal micro-modules will reside within that same package, likely in a subdirectory to keep the main tool file cleaner.

**Target File Structure:**

```
/2dots1line/
├── packages/
│   ├── tools/
│   │   └── retrieval/
│   │       ├── src/
│   │       │   ├── HybridRetrievalTool.ts  # The main public-facing tool class
│   │       │   │
│   │       │   ├── internal/               # NEW: Subdirectory for HRT's private micro-modules
│   │       │   │   ├── CypherBuilder.ts
│   │       │   │   ├── ParamGuard.ts
│   │       │   │   └── HydrationAdapter.ts
│   │       │   │
│   │       │   └── index.ts                # Exports HybridRetrievalTool
│   │       ├── package.json
│   │       └── tsconfig.json
│   │
│   └── ... (other tool categories like ai/, data/, composite/)
│
├── config/
│   └── cypher_templates.json               # NEW: Configuration for the CypherBuilder
│
└── ... (other parts of the monorepo)
```

**Explanation:**

1.  **`packages/tools/retrieval/src/HybridRetrievalTool.ts`:**
    *   This file will contain the main `HybridRetrievalTool` class.
    *   Its constructor will instantiate `CypherBuilder` and `HydrationAdapter`.
    *   Its `execute()` method will orchestrate the calls to Weaviate, then to its internal `CypherBuilder` instance, then to Neo4j, then to its internal `HydrationAdapter` instance.

2.  **`packages/tools/retrieval/src/internal/CypherBuilder.ts`:**
    *   Contains the `CypherBuilder` class.
    *   It will have a method to load and parse `config/cypher_templates.json` (or receive the parsed registry as a constructor argument if preferred for testing).
    *   It will instantiate and use the `ParamGuard`.
    *   This module is **not** exported from `packages/tools/retrieval/src/index.ts`. It's an internal implementation detail.

3.  **`packages/tools/retrieval/src/internal/ParamGuard.ts`:**
    *   Contains the `ParamGuard` class or utility functions for validating Cypher parameters.
    *   Not exported from the package index.

4.  **`packages/tools/retrieval/src/internal/HydrationAdapter.ts`:**
    *   Contains the `HydrationAdapter` class.
    *   It will depend on the various PostgreSQL repositories (e.g., `MemoryRepository`, `ConceptRepository`) which will be injected into its constructor (or methods).
    *   Not exported from the package index.

5.  **`config/cypher_templates.json`:**
    *   This new configuration file will live in the root `config/` directory, alongside `CoreIdentity.yaml`, `tool_composition.json`, etc.
    *   The `CypherBuilder` will be responsible for loading this file (likely at service initialization and caching it, or receiving its content from a configuration service).

**How They Exist in the Code File System (Conceptual Implementation):**

```typescript
// packages/tools/retrieval/src/internal/CypherBuilder.ts
import { ParamGuard } from './ParamGuard';
// Assume CypherTemplateRegistry is loaded from config/cypher_templates.json
// or passed in. For simplicity, let's say it's loaded internally.
// const cypherTemplateRegistry = loadCypherTemplates(); // Utility function

interface CypherTemplate {
  template: string;
  allowedParams: string[];
  defaultParams?: Record<string, any>;
}
interface CypherTemplateRegistry {
  [key: string]: CypherTemplate;
}

export class CypherBuilder {
  private paramGuard: ParamGuard;
  private templateRegistry: CypherTemplateRegistry;

  constructor(templateRegistryContent: CypherTemplateRegistry) { // Content passed from config
    this.paramGuard = new ParamGuard();
    this.templateRegistry = templateRegistryContent;
  }

  buildQuery(queryKey: string, runtimeParams: Record<string, any>): { cypher: string; params: Record<string, any> } {
    const templateDefinition = this.templateRegistry[queryKey];
    if (!templateDefinition) {
      throw new Error(`Cypher template not found for key: ${queryKey}`);
    }

    const finalParams = { ...templateDefinition.defaultParams, ...runtimeParams };

    // Validate against allowedParams (simple check here, could use JSON schema)
    for (const paramKey in finalParams) {
      if (!templateDefinition.allowedParams.includes(paramKey) && paramKey !== 'userId') { // userId is often implicit
        // Allow userId even if not in allowedParams for safety, or make it explicit
        // throw new Error(`Invalid parameter '${paramKey}' for Cypher template '${queryKey}'`);
      }
    }
    
    this.paramGuard.validate(queryKey, finalParams); // Apply specific guards

    let cypher = templateDefinition.template;
    // Safe placeholder replacement (e.g., ensure $paramName format)
    for (const key in finalParams) {
      // Ensure the key is a valid placeholder in the template
      const placeholder = `$${key}`;
      if (cypher.includes(placeholder)) {
         // This is a simplified replacement. Real Cypher drivers handle parameterization.
         // The goal here is to ensure the query structure is based on the template.
         // The actual Neo4j driver will use the `params` object for safe injection.
      }
    }
    // The Neo4j driver will use the `finalParams` object to safely inject values.
    // The `cypher` string returned here is the template with placeholders.
    return { cypher: templateDefinition.template, params: finalParams };
  }
}

// packages/tools/retrieval/src/HybridRetrievalTool.ts
import { CypherBuilder } from './internal/CypherBuilder';
import { HydrationAdapter } from './internal/HydrationAdapter';
// ... other imports (Weaviate client, Neo4j driver, repos) ...

export class HybridRetrievalTool {
  private weaviateClient: any; // Weaviate client instance
  private neo4jDriver: any;    // Neo4j driver instance
  private cypherBuilder: CypherBuilder;
  private hydrationAdapter: HydrationAdapter;
  // Repositories for HydrationAdapter will be passed to its constructor

  constructor(
    weaviateClient: any, 
    neo4jDriver: any, 
    cypherTemplateRegistryContent: any, // Loaded from config/cypher_templates.json
    // Pass all necessary repositories for the HydrationAdapter
    memoryRepository: any, 
    conceptRepository: any 
    // ... other repositories
  ) {
    this.weaviateClient = weaviateClient;
    this.neo4jDriver = neo4jDriver;
    this.cypherBuilder = new CypherBuilder(cypherTemplateRegistryContent);
    this.hydrationAdapter = new HydrationAdapter(memoryRepository, conceptRepository /*, ... */);
  }

  async execute({ keyPhrasesForRetrieval, userId, retrievalScenario = 'neighborhood' }: { /* input type */ }) {
    // Step 1: Key Phrase Pre-processing & Truncation (as defined before)
    const processedKeyPhrases = this.preprocessKeyPhrases(keyPhrasesForRetrieval);

    // Step 2: Semantic Grounding (Weaviate)
    const seedEntities = await this.identifySeedEntities(processedKeyPhrases, userId);
    if (seedEntities.length === 0 && retrievalScenario === 'neighborhood') { // Check scenario
        return { /* ... empty or specific 'no_seeds_found' context ... */ };
    }

    // Step 3: Cypher Query Construction
    const { cypher, params: cypherParams } = this.cypherBuilder.buildQuery(retrievalScenario, {
      seedEntities: seedEntities, // Might be empty if not 'neighborhood'
      userId: userId,
      // ... other runtime params specific to the scenario, e.g., conceptId for 'episodesByConcept'
    });

    // Step 4: Graph Traversal (Neo4j)
    let neo4jResults;
    const session = this.neo4jDriver.session();
    try {
      const result = await session.run(cypher, cypherParams);
      neo4jResults = result.records.map(record => record.get('allRelevantEntities') || record.get('related') || []).flat(); // Adjust based on actual template output
      // Ensure neo4jResults is an array of {id, type}
      if (neo4jResults.length > 0 && neo4jResults[0] && (typeof neo4jResults[0].id === 'undefined' || typeof neo4jResults[0].type === 'undefined')) {
         // If the structure is different (e.g. directly node objects), transform it here
         // For example, if records are Neo4j Node objects:
         // neo4jResults = result.records.map(r => ({ id: r.get('n').identity.toString(), type: r.get('n').labels[0] }));
      }
    } catch (error) {
      console.error("Neo4j query failed:", error);
      // Return graceful failure context
      return { retrievedMemoryUnits:[], retrievedConcepts:[], retrievalSummary:"graph_query_failed" };
    } finally {
      await session.close();
    }
    
    // Step 5: Content Hydration
    const augmentedContext = await this.hydrationAdapter.hydrateEntities(neo4jResults, userId);

    // Step 6: Return
    return augmentedContext;
  }

  private preprocessKeyPhrases(keyPhrases: string[]): string[] { /* ... */ return keyPhrases.slice(0,5); }
  private async identifySeedEntities(keyPhrases: string[], userId: string): Promise<Array<{id: string, type: string}>> { /* ... Weaviate logic ... */ return []; }
}
```

This structure ensures that the `HybridRetrievalTool` is the single public interface for this package, while its complex internal workings are neatly encapsulated in private micro-modules. The `config/cypher_templates.json` provides the necessary external configuration for its deterministic query generation.


This is an excellent suggestion that elevates the `HybridRetrievalTool` (HRT) from simple retrieval to **intelligent, weighted contextualization**. Incorporating a tunable scoring mechanism for prioritizing retrieved entities aligns perfectly with our goal of providing the most relevant information to the `DialogueAgent`.

Let's break down how to incorporate this scoring mechanism into the HRT, identify the necessary data fields, and analyze the implications for the broader system.

---

### **V9.3: Incorporating Weighted Scoring into `HybridRetrievalTool`**

The core idea is that after retrieving a set of candidate entities (from Weaviate semantic search and Neo4j graph traversal), the HRT will score each entity based on multiple factors before deciding which ones to fully hydrate and return.

**New HRT Internal Scoring Step (after Neo4j traversal, before full PG hydration):**

Let's call this **Step 4.5: Candidate Entity Scoring & Prioritization**. This happens after Neo4j returns a list of `relevantEntityIdsAndTypes` (our previous Step 4) and before we fully hydrate *all* of them from PostgreSQL (previous Step 5).

**The Scoring Formula:**

`Score(entity) = (α * SemanticSimilarityScore) + (β * RecencyScore) + (γ * SalienceScore) + (δ * UserPreferenceScore)`

*   **Weights (α, β, γ, δ):** These will be tunable parameters, likely stored in a configuration file (e.g., `config/retrieval_weights.json`) or even as part of `User.preferences`. This allows us to fine-tune the retrieval behavior.

**Data Fields Needed for Each Scoring Component:**

1.  **Semantic Similarity Score (α):**
    *   **Source:** This score comes directly from **Weaviate's vector search results**. When Weaviate returns `UserKnowledgeItem`s similar to the `key_phrases`, it provides a distance or similarity score for each.
    *   **HRT Action:** During Step 2 (Semantic Grounding), the HRT must capture and store this initial similarity score for each `seedEntityId` it identifies.
    *   **Data Field:** This is transient data within the HRT's execution context, associated with the `seedEntities`. For entities brought in via Neo4j traversal (neighbors of seeds), their initial semantic similarity score might be considered lower or derived from their proximity to a high-similarity seed.
    *   **Normalization:** Weaviate scores (often distances) need to be normalized (e.g., to a 0-1 range where 1 is most similar).

2.  **Recency Score (β):**
    *   **Source:** The `creation_ts` (for `Concept`s, `DerivedArtifact`s) or `ingestion_ts` / `last_modified_ts` (for `MemoryUnit`s) fields from their respective PostgreSQL tables.
    *   **HRT Action:** After Neo4j returns the list of candidate `relevantEntityIdsAndTypes`, the HRT needs to perform a **lightweight fetch from PostgreSQL** for *just these timestamp fields* for all candidate entities. This is a pre-hydration step.
    *   **Data Field:** `MemoryUnit.ingestion_ts` or `MemoryUnit.last_modified_ts`, `Concept.created_at` or `Concept.last_updated_ts`.
    *   **Normalization:** Convert timestamps into a score (e.g., Gaussian decay function where newer items get higher scores, older items taper off). Max score for items created/modified today, min score for items older than X days.

3.  **Salience Score (γ):**
    *   **Source:**
        *   `MemoryUnit.importance_score` (generated by `IngestionAnalyst` LLM).
        *   `Concept.salience` (can be user-defined or AI-calculated by `InsightEngine` based on graph centrality or frequency of mention).
        *   `DerivedArtifact` could have an `importance_score` field.
    *   **HRT Action:** Similar to Recency, after Neo4j traversal, perform a lightweight PG fetch for these salience/importance fields for all candidate entities.
    *   **Data Field:** `MemoryUnit.importance_score`, `Concept.salience`.
    *   **Normalization:** These scores might already be in a usable range (e.g., 1-10 or 0-1). If not, normalize them.

4.  **User Preference Score (δ):**
    *   **Source:** This is more complex and implies a new layer of personalization.
        *   **Option A (Explicit):** `User.preferences` could store explicit boosts for certain `Concept.type`s (e.g., `{ "preferred_concept_types": { "goal": 1.5, "value": 1.2 } }`).
        *   **Option B (Implicit):** The `InsightEngine` could analyze `UserActivityLog` or `InteractionLog` to determine which entity types or specific entities the user interacts with most frequently and positively. This "engagement score" could be stored as a property on the Neo4j node or in a separate PG lookup table.
        *   **Option C (From `UserMemoryProfile`):** Core values or active goals identified in the `UserMemoryProfile` could grant a preference boost to related entities.
    *   **HRT Action:** Fetch the `User.preferences` or relevant derived preference data. For each candidate entity, check if it matches a preferred type or theme.
    *   **Data Field:** `User.preferences.preferred_concept_types` (New JSONB structure). Or a new field like `Concept.user_engagement_score` populated by `InsightEngine`.
    *   **Normalization:** Assign a score boost (e.g., 1.0 for no preference, 1.5 for preferred).

---

### **Updated HRT `execute` Workflow (V9.3 - With Scoring)**

**Step 1: Key Phrase Pre-processing & Truncation (Deterministic)**
    *   *(Unchanged)*

**Step 2: Semantic Grounding & Initial Score (Weaviate)**
    *   *(Unchanged from V9.2, but now critically captures the Weaviate similarity score for each seed entity).*
    *   **Output:** `seedEntitiesWithSimilarity` (e.g., `[{id: 'c123', type:'Concept', weaviateScore: 0.85}, ...]`).

**Step 3: Contextual Graph Traversal (Neo4j)**
    *   *(Unchanged from V9.2, uses `CypherBuilder` with `seedEntitiesWithSimilarity` as input).*
    *   **Output:** `candidateEntityIdsAndTypes` (expanded list including neighbors).

**Step 4: Lightweight Pre-Hydration for Scoring (PostgreSQL)**
    *   **NEW Step**
    *   **Input:** `candidateEntityIdsAndTypes`.
    *   **Action:** For all unique entity IDs in the list:
        *   Batch fetch `creation_ts`/`last_modified_ts` from `MemoryUnit`, `Concept` tables.
        *   Batch fetch `importance_score`/`salience` from `MemoryUnit`, `Concept` tables.
    *   **Output:** A map of `entityId` to `{ recencyData, salienceData }`.

**Step 4.5: Candidate Entity Scoring & Prioritization (Deterministic Code within HRT)**
    *   **NEW Step**
    *   **Input:** `candidateEntityIdsAndTypes`, `seedEntitiesWithSimilarity`, data from Step 4, `User.preferences` (for δ score), and configured weights (α, β, γ, δ).
    *   **Action:**
        1.  For each entity in `candidateEntityIdsAndTypes`:
            *   Calculate its `SemanticSimilarityScore`:
                *   If it was a direct seed from Weaviate, use its stored `weaviateScore`.
                *   If it's a neighbor from Neo4j, its similarity score could be a fraction of the seed it's connected to, or a default lower value.
            *   Calculate `RecencyScore` based on its timestamp data.
            *   Calculate `SalienceScore` based on its importance/salience data.
            *   Calculate `UserPreferenceScore` based on its type and user preferences.
            *   Compute the final weighted `Score(entity)`.
        2.  Sort all candidate entities by their final score in descending order.
        3.  Select the top N entities (e.g., `TOP_N_CANDIDATES_FOR_HYDRATION = 10`, configurable) for full hydration.
    *   **Output:** A prioritized list of `topCandidateEntityIdsAndTypes`.

**Step 5: Full Content Hydration (PostgreSQL `HydrationAdapter`)**
    *   **Input:** The `topCandidateEntityIdsAndTypes` (the prioritized, shorter list).
    *   **Action:** *(Largely unchanged from V9.2)* The `HydrationAdapter` fetches full content for these top N entities.
    *   **Output:** Populated `AugmentedMemoryContext` (now containing only the highest-scoring, most relevant entities).

**Step 6: Return `AugmentedMemoryContext` to `DialogueAgent`**
    *   *(Unchanged)*

---

### **Implications on Other Parts of the Agent Framework & Data Schema**

1.  **`User.preferences` (PostgreSQL `users` table):**
    *   **Impact:** May need to be enhanced to store explicit concept type preferences or themes if Option A for UserPreferenceScore is chosen.
        ```prisma
        // User.preferences (example structure for δ)
        // { "preferred_concept_types": { "goal": 1.5, "value": 1.2, "skill_development": 1.4 } }
        ```

2.  **`MemoryUnit` and `Concept` tables (PostgreSQL):**
    *   **Impact:** Ensure `importance_score` (for `MemoryUnit`) and `salience` (for `Concept`) are consistently populated and meaningful. The `InsightEngine` might be responsible for periodically re-calculating `Concept.salience` based on graph centrality or recent engagement.
    *   Ensure timestamp fields (`creation_ts`, `ingestion_ts`, `last_modified_ts`, `last_updated_ts`) are accurate.

3.  **`InsightEngine`:**
    *   **Impact:**
        *   Could be responsible for calculating and storing `Concept.user_engagement_score` (Option B for UserPreferenceScore) if we go that route.
        *   Its `UserMemoryProfile` output could include a summary of these engagement scores or preferences, which might also feed into the `DialogueAgent`'s general awareness.

4.  **Configuration Files:**
    *   **New File:** `config/retrieval_weights.json` to store α, β, γ, δ.
        ```json
        // config/retrieval_weights.json
        {
          "alpha_semantic_similarity": 0.4,
          "beta_recency": 0.25,
          "gamma_salience": 0.25,
          "delta_user_preference": 0.1
        }
        ```
    *   `config/hr_tool_config.json` (or similar) for constants like `MAX_KEY_PHRASES`, `TOP_N_WEAVIATE_RESULTS_PER_PHRASE`, `TOP_N_CANDIDATES_FOR_HYDRATION`.

5.  **Weaviate Schema (`UserKnowledgeItem`):**
    *   **Impact:** No direct schema change, but the process of loading data into Weaviate should ensure that `importanceScore` and relevant `tags` (which could influence user preference scoring) are included if they are to be used as filters *before* the main scoring logic. The primary semantic score comes from the vector distance itself.

**Summary of Changes:**

*   HRT gets a new internal scoring and prioritization step.
*   HRT needs to perform a lightweight pre-hydration fetch for timestamps and salience scores.
*   `User.preferences` might be extended.
*   `Concept.salience` becomes more critical.
*   New configuration for scoring weights and HRT parameters.

This weighted scoring mechanism makes the HRT significantly more intelligent. It's no longer just "find related things" but "find the *most important and relevant* related things right now." This is a substantial improvement and aligns beautifully with the overall goal of a deeply personalized AI.