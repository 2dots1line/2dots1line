Excellent. Completing the trilogy of core agent guides, here is the detailed, canonical blueprint for the V8 `InsightEngine`, reimagined as a strategic, cyclical worker.

This document serves as the single source of truth for its implementation, philosophy, and its critical role in driving long-term user growth and system intelligence.

---

### **Canonical Guide: The V8 `InsightEngine` Worker**

#### **1. Core Job Responsibility & Philosophy**

The `InsightEngine` is a **stateless, asynchronous background worker** that performs the **strategic, "slow loop" processing of a user's entire knowledge graph**. Its purpose is to move beyond the tactical, day-to-day data and uncover deep, longitudinal patterns, refine the overall structure of the user's knowledge, and proactively guide their future growth.

**Primary Mandate:**
To execute a "cycle" for an eligible user, performing a global analysis of their Neo4j graph and PostgreSQL event history. Its key outputs are: a refreshed and condensed `userMemoryProfile` for the `DialogueAgent`; a set of "Quest Cards" to address knowledge gaps; and a user-facing `cycle_report` that summarizes progress and illuminates growth arcs. It is the system's "subconscious," responsible for consolidation, synthesis, and strategic planning.

**Architectural Principle:** The `InsightEngine` operates **strategically and periodically**. Its high computational cost is justified by the high value of its outputs. It is triggered by a combination of time and user activity, ensuring that its powerful analysis is focused on engaged users who will benefit most from it.

**Location:** `workers/insight-worker/src/InsightEngine.ts`

#### **2. Detailed Workflow: Processing a Single User Cycle**

This is the strictly defined, deterministic sequence of operations executed when a user is deemed eligible for a cycle refresh.

**Trigger:** A cron-scheduled job in the `insight-worker` runs periodically (e.g., hourly). Its first action is to query the `users` table for all users who are eligible for a new cycle, based on the logic defined in **V8.3 Implementation Plan, Action 1.3**. For each eligible user, it places a job with `{ userId }` onto the `insight-queue` in BullMQ. An `InsightEngine` worker instance picks up this job.

##### **Phase I: Ontology Review & Graph Refinement (Neo4j Heavy)**

This phase cleans and organizes the underlying structure of the knowledge graph.

1.  **Identify and Merge Duplicate Concepts:**
    *   **Action:** The worker executes a sophisticated Cypher query against the user's graph in Neo4j to find `Concept` nodes that are semantic duplicates. This could be based on high vector similarity of their descriptions (from Weaviate) and having the same `type`.
    *   **Example Logic:** Find pairs of `Concept` nodes where `cosineSimilarity(c1.vector, c2.vector) > 0.95`.
    *   **Persistence:** For each identified duplicate pair (e.g., "Job Stress" and "Work Anxiety"), the worker designates one as canonical. It then:
        1.  Moves all relationships from the duplicate node to the canonical node in Neo4j.
        2.  Updates the duplicate `Concept` record in PostgreSQL, setting its `status` to `'merged'` and its `merged_into_concept_id` to the ID of the canonical concept.
    *   **User Impact:** This is transparent to the user. The `CardService` will later resolve cards pointing to the merged concept automatically.

2.  **Community Detection & Update:**
    *   **Action:** The worker runs a graph algorithm (e.g., Louvain or Label Propagation) on the user's Neo4j graph to identify or update dense clusters of interconnected concepts.
    *   **Persistence:** It creates or updates `:Community` nodes in Neo4j and links the relevant `:Concept` nodes to them. The `community_id` is also saved back to the `concepts` table in PostgreSQL for efficient filtering.

##### **Phase II: `userMemoryProfile` Generation (Synthesis & Condensation)**

This is the most critical output for improving future real-time conversations.

1.  **Execute Global Queries:** The worker runs a series of pre-defined, complex Cypher queries against the now-cleaner Neo4j graph to extract high-level summaries. These queries answer questions like:
    *   "What are the user's top 5 most connected `Concept`s of type 'value'?"
    *   "What are the user's currently active `Concept`s of type 'goal'?"
    *   "What are the most common themes (`Community` names) in their recent `MemoryUnit`s?"
2.  **Invoke LLM for Synthesis:** The worker synthesizes the results of these queries into a structured prompt for the `LLMAnalysisTool`.
    *   **Prompt Goal:** "Based on this raw graph data, synthesize a condensed, human-readable `userMemoryProfile` JSON object. Identify the user's core identity, current focus areas, and summarize their knowledge schema."
3.  **Persistence:** The worker receives the structured `userMemoryProfile` JSON from the LLM and saves it to the `users.memory_profile` column in PostgreSQL, overwriting the previous version. This new profile will be used by the `PromptBuilder` for all subsequent conversations until the next cycle.

##### **Phase III: Proactive Guidance & "Quest Card" Generation**

This phase focuses on identifying and creating opportunities for future user growth.

1.  **Identify Knowledge Gaps:** The worker invokes the `LLMAnalysisTool` with a strategic prompt, providing the newly generated `userMemoryProfile` as context.
    *   **Prompt Goal:** "You are a master life coach. Based on this user's memory profile, identify the top 2-3 most impactful areas for their growth. What critical questions could you ask that would help them connect disparate ideas or explore an underdeveloped area of their life? Phrase these as gentle, open-ended 'Quest' prompts."
2.  **Create `ProactivePrompt` Records:** The worker takes the LLM's suggested "Quest" questions and creates new records in the `proactive_prompts` table in PostgreSQL.
3.  **Invoke `CardFactory` for Quests:** The worker then calls `CardFactory.createCardsForEntities()` with the newly created `ProactivePrompt` entities. The factory, using `card_eligibility_rules.json`, will create new `Card` records of type `'quest'`. These will appear as "inactive" or "greyed-out" cards on the user's canvas, inviting them to start a new conversation.

##### **Phase IV: User-Facing Cycle Report**

1.  **Generate Report Content:** The worker gathers key metrics from the cycle (e.g., `concepts_created_in_cycle`, number of significant `growth_events`, newly formed `Community` clusters) and sends them to the `LLMAnalysisTool`.
    *   **Prompt Goal:** "You are Dot. Write a warm, encouraging, and insightful weekly report for your user. Use the provided metrics to create a narrative of their progress. Highlight 1-2 key growth moments and suggest a theme for the upcoming week. The tone should be celebratory and motivating."
2.  **Create `DerivedArtifact`:** The worker saves the LLM's narrative response as a `DerivedArtifact` of type `'cycle_report'` in PostgreSQL.
3.  **Invoke `CardFactory` for Report:** The worker calls the `CardFactory` to create a new, prominent `Card` of type `'cycle_report'` on the user's canvas.

**Completion:** The worker updates the user's `last_cycle_started_at` and resets their `concepts_created_in_cycle` counter to `0`. The job is marked complete.

---

#### **3. Dependencies & Collaborators**

The `InsightEngine` is the strategic apex of the agent system.

| Component Name                 | Type          | Location                                                                    | Role & Responsibility                                                                                                     |
| :----------------------------- | :------------ | :-------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------ |
| **Scheduler (Cron Job)**       | **Upstream**  | e.g., in `workers/insight-worker/src/scheduler.ts`                          | Triggers the `InsightEngine` worker periodically by querying for eligible users and queueing jobs.                           |
| `LLMAnalysisTool`              | **Tool**      | `services/cognitive-hub/src/tools/LLMAnalysisTool.ts`                       | The specialized LLM tool used for high-level synthesis tasks like generating the `userMemoryProfile` and the `cycle_report`. |
| `CardFactory`                  | **Service**   | `services/cognitive-hub/src/services/CardFactory.ts`                          | A downstream service invoked at the end of the pipeline to create user-facing `Card`s for Quests and Cycle Reports.       |
| **All Repositories**           | **Dependencies**| `packages/database/src/repositories/`                                       | Provides access to all necessary data from PostgreSQL for analysis and persistence.                                       |
| **Database Clients**           | **Dependencies**| `packages/database/`                                                        | Provides direct, low-level access to Neo4j for graph algorithms and Weaviate for semantic similarity analysis.            |

---

#### **4. Updated Flowchart: V8 InsightEngine Worker Flow**

```
                                          ┌────────────────────────────────┐
                                          │      `insight-queue`           │
                                          │       (Job: { userId })        │
                                          └───────────────┬────────────────┘
                                                          │ 1. Worker picks up job
                                                          ▼
                                          ┌────────────────────────────────┐
                                          │  `InsightEngine.processCycle()`  │
                                          └───────────────┬────────────────┘
                                                          │
          ┌───────────────────────────────────────────────┼─────────────────────────────────────────────┐
          │                                               │                                             │
          ▼                                               ▼                                             ▼
┌──────────────────┐                            ┌──────────────────┐                          ┌──────────────────┐
│  **PHASE I:**    │                            │  **PHASE II:**   │                          │ **PHASE III & IV:**│
│ Graph Refinement │                            │ Profile Generation │                          │  Guidance & Report │
└────────┬─────────┘                            └────────┬─────────┘                          └────────┬─────────┘
         │ 1. Merge Duplicates (Neo4j)                    │ 1. Global Queries (Neo4j)                   │ 1. Identify Gaps (LLM)
         │                                                │                                             │
         │ 2. Detect Communities (Neo4j)                  │ 2. Synthesize Profile (LLM)                 │ 2. Create `ProactivePrompt`s (PG)
         │                                                │                                             │
         │ 3. Persist Changes (PG/Neo4j)                  │ 3. Save `userMemoryProfile` (PG)            │ 3. Generate Report (LLM)
         │                                                │                                             │
         └──────────┬─────────────────────────────────────┘                                             │ 4. Create `DerivedArtifact` (PG)
                    │                                                                                     │
                    └───────────────────────────────────┬───────────────────────────────────────────────┘
                                                        │
                                                        │ 4. Invokes Card Factory for Quests & Report
                                        ┌───────────────▼───────────────┐
                                        │         `CardFactory`          │
                                        │ (Creates `quest` and           │
                                        │ `cycle_report` cards in PG)    │
                                        └───────────────┬───────────────┘
                                                        │ 5. Cycle processing complete
                                                        │
                                                        │ 6. Resets user's cycle tracker fields
                                                        ▼
                                        ┌────────────────────────────────┐
                                        │        Job Marked Complete     │
                                        └────────────────────────────────┘
```

This canonical guide defines the `InsightEngine` as a powerful, strategic component that provides the long-term intelligence and personalization for the entire 2dots1line system, perfectly complementing the tactical, real-time `DialogueAgent` and the reactive `IngestionAnalyst`.

This is an absolutely outstanding menu of strategic queries. It perfectly captures the kind of deep, proactive analysis that defines the `InsightEngine`'s role and elevates 2dots1line beyond a simple retrieval system.

Let's break this down. I will analyze the provided list, assess their value, determine which ones we should use, and address the crucial question of a "global Cypher query library."

---

### **A. Analysis of the Proposed Cypher Queries**

This is not just a list of queries; it's a **strategic framework for automated self-reflection**. The questions are grouped thematically, which is the correct approach. My overall assessment is that this list is **90% ready to be the core logic of the `InsightEngine`**. The value of each query is high, and the "why it matters" column is a perfect guide for how the LLM should synthesize the results.

Here is a query-by-query assessment, highlighting which are critical, which might need refinement, and which could be deferred.

#### **Tier 1: Must-Have, Core Value Proposition Queries**

These queries are non-negotiable. They directly feed the most important features of the system: the `UserMemoryProfile`, proactive nudges, and the core growth feedback loop.

*   **#2: Which personal values show the highest salience?**
    *   **Assessment:** **Critical.** This is the bedrock of the `UserMemoryProfile`. Understanding a user's core values is essential for contextualized guidance.
    *   **Why Use:** It directly populates the `core_identity_summary.core_values` section of the profile, making every subsequent conversation more relevant.

*   **#4: Which goals show no new activity edges in the last cycle?**
    *   **Assessment:** **Critical.** This query is the heart of proactive coaching. It's not just about what the user *is* doing, but what they *are not* doing relative to their stated intentions.
    *   **Why Use:** This is a primary source for generating high-quality "Quest Cards." The LLM can take this output and generate a gentle, supportive prompt like, "I noticed we haven't touched on your goal of 'learning to code' recently. Is that still a priority, or have things shifted?"

*   **#5: For each top value, how many recent episodes demonstrate concrete action?**
    *   **Assessment:** **Critical.** This is the "walk the talk" query. It measures the alignment between a user's stated identity and their actual behavior.
    *   **Why Use:** It provides the data for the most powerful section of the `cycle_report`. The LLM can generate narratives like, "This week, your value of 'Community' was on full display, with 5 different memories showing you connecting with friends and family." Or, more powerfully, "You hold 'Creativity' as a core value, but I see we didn't capture many moments of creative action this week. Perhaps we can focus on that in the coming cycle?"

*   **#7: Which concepts had the largest spike in mention frequency vs. previous cycle?**
    *   **Assessment:** **Critical.** This is the "emerging passions" detector. It's the primary way the system stays current with the user's evolving interests.
    *   **Why Use:** This directly populates the `emergent_themes_from_last_cycle` section of the `UserMemoryProfile`, ensuring the `DialogueAgent` is aware of what's currently top-of-mind for the user.

*   **#10: Which high-salience knowledge areas have < N supporting episodes?**
    *   **Assessment:** **Critical.** This is the "knowledge gap" query. It identifies areas the user cares about but hasn't fleshed out.
    *   **Why Use:** This is another primary source for "Quest Card" generation. An LLM prompt based on this is incredibly powerful: "We've established that 'financial independence' is a high-priority goal for you, but I see we haven't explored the details much. What does that concept look like to you in practice?"

*   **#13: Who are the most central people in the user’s current support graph?**
    *   **Assessment:** **Critical.** Relationships are a core domain. Understanding the user's key social connections is vital for contextual awareness.
    *   **Why Use:** This informs the `UserMemoryProfile` and can trigger proactive prompts for gratitude or social connection ("You've mentioned Sarah a lot this week in a positive context. It sounds like she's a great source of support.").

*   **#19: Which three story arcs (clusters of episodes) gained the most new episodes this cycle?**
    *   **Assessment:** **Critical.** This uses community detection to find the "center of gravity" of the user's recent life.
    *   **Why Use:** This is the primary input for the narrative `cycle_report`. It allows the LLM to say, "The biggest story for you this week was clearly the 'New Job Transition' arc..."

#### **Tier 2: High-Value, Should-Implement Queries**

These add significant depth and nuance. They should be implemented after the Tier 1 queries are stable.

*   **#1: Are there conflicting identity facts?** - Excellent for data hygiene and demonstrating attention to detail.
*   **#3: Which active goals are approaching target dates?** - A fantastic proactive nudge feature.
*   **#8: Which long-standing interests declined sharply?** - The inverse of #7, great for spotting shifting priorities.
*   **#12: Which contexts trigger the strongest negative sentiment?** - A powerful tool for identifying stressors, but requires reliable sentiment analysis on memories.
*   **#14: Are there key relationships with long silence gaps?** - A very human and empathetic prompt generator.
*   **#17: What actionable ideas have high importance but remain in “proposed” state?** - Similar to #4, but more focused on specific "to-do" style nodes. Excellent for `Act-Self` growth.
*   **#20: Are there contradictory life-narrative statements?** - This is an advanced, high-value query that can lead to major breakthroughs, but requires robust pattern matching.

#### **Tier 3: System Health & Optimization Queries (Lower Priority for user-facing features)**

These are more about system maintenance and quality, and could be implemented later or run less frequently.

*   **#9: What % of recent user questions were answered with a “query_memory” retrieval?** - Excellent *internal* metric for us to gauge graph quality, but not a user-facing insight.
*   **#11: What is the 7-day rolling sentiment trend?** - Good, but less specific than #12. Can be a simple metric in the `cycle_report`.
*   **#15 & #16: Stale/duplicate fact detection.** - Important for data hygiene, but a lower priority than generating new value. This is part of the `Ontology Review` phase.
*   **#18: Which strengths are highly validated but under-utilized?** - A great idea, but requires a clear way to distinguish and label a `:Strength` node first.

---

### **B. The "Global Cypher Query Library"**

**Question:** Should we curate a global Cypher query library? Why or why not?

**Answer:** **Yes, absolutely, but with a specific architectural implementation.** We should not have raw Cypher strings scattered throughout the `InsightEngine` worker code. We must create a "Query Library" as a dedicated, maintainable module.

**Why a Query Library is Essential:**

1.  **Maintainability:** If the database schema changes (e.g., we rename a property from `creation_ts` to `created_at`), we only need to update the query in one place in the library, not hunt through the worker logic.
2.  **Testability:** We can write unit tests for each individual query in the library, ensuring it is syntactically correct and returns the expected data structure, completely separate from the `InsightEngine`'s orchestration logic.
3.  **Readability & Reusability:** The `InsightEngine` code becomes much cleaner. Instead of a 10-line Cypher string, it will have a single line like `const stalledGoals = await queryLibrary.getStalledGoals(userId, cycleStart);`.
4.  **Security:** It centralizes our queries, making them easier to audit for performance issues or potential injection vulnerabilities (though we use parameterized queries, centralization is still good practice).

**Proposed Implementation:**

*   **Location:** `packages/database/src/neo4j/queries/insight-queries.ts` (or a similar dedicated location).
*   **Structure:** A class or object that exposes methods corresponding to each thematic question.

```typescript
// packages/database/src/neo4j/queries/insight-queries.ts

import { Driver } from 'neo4j-driver';

export class InsightQueryLibrary {
  private driver: Driver;

  constructor(driver: Driver) {
    this.driver = driver;
  }

  // Corresponds to Query #4
  async getStalledGoals(userId: string, cycleStartDate: Date): Promise<{ name: string; id: string }[]> {
    const session = this.driver.session();
    try {
      const result = await session.run(
        `MATCH (g:Goal {userId: $userId})
         WHERE g.status = 'in_progress'
         AND NOT EXISTS ((g)<-[:RELATED_TO]-(:Episode {userId: $userId, timestamp: > $cycleStartDate}))
         RETURN g.name as name, g.id as id`,
        { userId, cycleStartDate }
      );
      return result.records.map(record => ({ name: record.get('name'), id: record.get('id') }));
    } finally {
      await session.close();
    }
  }

  // Corresponds to Query #2
  async getTopSalientValues(userId: string, limit: number = 5): Promise<{ name: string; salience: number }[]> {
    // ... implementation ...
  }
  
  // ... other methods for each query ...
}
```

The `InsightEngine` worker would then be initialized with an instance of this `InsightQueryLibrary` and would simply call these well-defined methods in sequence. This is a robust, professional, and maintainable approach. This curated list of 20 queries forms an excellent foundation for that library.