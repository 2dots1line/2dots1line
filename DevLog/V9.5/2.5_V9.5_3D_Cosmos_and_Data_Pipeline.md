### **`2.5_V9.5_3D_Cosmos_and_Data_Pipeline.md`**

---

# **V9.5 Canonical Guide: 3D Knowledge Cosmos & Data Pipeline**

**Document Version:** 9.5
**Purpose:** To provide a definitive, deep-dive specification for the 3D Knowledge Cosmos user interface, the asynchronous data pipeline that powers it, and the new `GraphProjectionWorker` responsible for generating its data.

## **1. Core Philosophy & User Experience**

The 3D Knowledge Cosmos is the second primary interface for exploring the user's knowledge graph, complementing the 2D Card Canvas. Its purpose is to provide a **holistic, spatial, and structural view** of the user's knowledge, allowing them to intuitively grasp the shape, density, and relationships within their "inner universe."

**User Experience Principles:**
*   **Structural Insight:** Unlike the serendipitous 2D canvas, the 3D Cosmos is about understanding structure. Users can see clusters of related thoughts, identify central "pillar" concepts, and notice isolated ideas.
*   **Semantic Proximity:** The placement of nodes is not random; it is a 3D projection of their high-dimensional vector embeddings. **Nodes that are semantically similar will appear closer together in the 3D space.**
*   **Interactive Exploration:** The user is an active explorer, able to navigate the space (pan, rotate, zoom), interrogate the graph with AI assistance, and dive into specific nodes to view their detailed `Card` representation.

## **2. Architectural Overview: The Asynchronous Projection Pipeline**

To ensure a high-performance, real-time 3D experience, the complex calculations required to generate the cosmos view are performed **asynchronously** by a dedicated worker. The frontend does not query the live databases directly; it loads a pre-computed, static data file.

```
            ┌───────────────────┐        ┌──────────────────┐
            │       Neo4j       │        │     Weaviate     │
            │  (Graph Structure)  │        │(Vector Embeddings)│
            └──────────┬──────────┘        └─────────┬────────┘
                       │ 1. Fetch Node IDs & Edges     │ 2. Fetch Vectors for Node IDs
                       │                             │
                       └───────────────┐ ┌───────────┘
                                       ▼ ▼
                         ┌───────────────────────────┐
                         │ `GraphProjectionWorker`   │
                         │ (Asynchronous Background Job) │
                         └─────────────┬─────────────┘
                                       │ 3. Dimensionality Reduction
                                       │    (e.g., UMAP: 1536D -> 3D)
                                       │
                                       │ 4. Store Projection Data
                                       ▼
                         ┌───────────────────────────┐
                         │   PostgreSQL:             │
                         │ `user_graph_projections` table │
                         │ (or CDN/S3 for pure static file serving) │
                         └─────────────┬─────────────┘
                                       │ 5. API provides data
                                       ▼
                         ┌───────────────────────────┐
                         │  API Gateway:             │
                         │ GET /api/v1/graph-projection │
                         └─────────────┬─────────────┘
                                       │ 6. Frontend fetches projection
                                       ▼
                         ┌───────────────────────────┐
                         │     3D Knowledge Cosmos   │
                         │    (Frontend Renders Scene) │
                         └───────────────────────────┘
```

## **3. The `GraphProjectionWorker`**

This is the new worker responsible for generating the data for the 3D Cosmos.

**Location:** `workers/graph-projection-worker/`

**Trigger:** It is subscribed to the `card-and-graph-queue`. It listens for events like `new_entities_created` or `cycle_artifacts_created`. It can also be run on a periodic schedule (e.g., hourly) to ensure the projection stays reasonably up-to-date.

### **Detailed Workflow: Processing a Projection Job**

1.  **Fetch Full Graph Structure:** The worker queries Neo4j to get a complete list of all active `nodeId`s and their `type`s, along with an edge list (`{ source_id, target_id }`) for the given `userId`.
2.  **Fetch All Vectors:** The worker performs a batch fetch from Weaviate to retrieve the high-dimensional vector for every `nodeId` gathered in the previous step.
3.  **Perform Dimensionality Reduction:**
    *   **Dependency:** This step will likely require a specialized service, potentially a Python microservice, that has access to libraries like `UMAP`, `t-SNE`, or `PCA`. The worker sends the batch of vectors to this service.
    *   **Action:** The service projects the high-dimensional vectors (e.g., 1536D) down to 3D coordinates (`[x, y, z]`).
    *   **Output:** The service returns a map of `nodeId` to its new `[x, y, z]` coordinates.
4.  **Assemble Projection JSON:** The worker constructs a single, comprehensive JSON object containing all the data the frontend needs to render the scene. (See Section 5 for the structure).
5.  **Persist Projection Data:** The worker saves the generated JSON object to the `user_graph_projections` table in PostgreSQL.
    *   **Storage Table:** `user_graph_projections` (`user_id`, `projection_version_id`, `projection_data` JSONB, `created_at`). This allows for versioning and easy retrieval.
    *   *(Alternative for massive scale: The JSON is uploaded to a CDN like S3, and the URL is stored in PostgreSQL.)*

## **4. API Endpoint for Serving Projection Data**

A new, simple endpoint is required to serve the pre-computed data to the frontend.

*   **Endpoint:** `GET /api/v1/graph-projection`
*   **Controller:** `graph.controller.ts` (new or can be part of `card.controller.ts`).
*   **Logic:**
    1.  Authenticates the user.
    2.  Queries the `user_graph_projections` table for the user's most recent projection.
    3.  Returns the `projection_data` JSON object.

## **5. The Graph Projection Data Structure**

This is the structure of the JSON object that the `GraphProjectionWorker` creates and the frontend consumes.

```json
// Example content of `user_graph_projections.projection_data`
{
  "version": "proj-uuid-v1",
  "createdAt": "2025-06-15T18:00:00Z",
  "nodeCount": 152,
  "edgeCount": 340,
  "nodes": [
    {
      "id": "muid-abc", // Corresponds to a sourceEntityId
      "type": "MemoryUnit",
      "label": "Brainstorming Session for Project Phoenix",
      "pos": [10.34, -5.12, 42.89], // The pre-computed [x,y,z] coordinates
      "metadata": {
        "importance": 8.5,
        "community_id": "community-work"
      }
    },
    {
      "id": "concept-def",
      "type": "Concept",
      "label": "Project Phoenix",
      "pos": [11.01, -4.99, 43.15],
      "metadata": {
        "salience": 0.9,
        "concept_type": "project",
        "community_id": "community-work"
      }
    }
    // ... all other nodes
  ],
  "edges": [
    { "source": "muid-abc", "target": "concept-def" },
    { "source": "concept-def", "target": "concept-ghi" }
    // ... all other edges
  ],
  "communities": [
    {
      "id": "community-work",
      "label": "Work & Career Growth",
      "member_node_ids": ["muid-abc", "concept-def", "..."]
    }
  ]
}
```

## **6. Frontend Responsibilities (3D Knowledge Cosmos)**

The frontend (`apps/web-app`) is responsible for:

1.  **Fetching Data:** On loading the 3D Cosmos scene, it calls `GET /api/v1/graph-projection` to get the data object.
2.  **Rendering:** It uses a 3D library like React Three Fiber (R3F) to:
    *   Iterate through the `nodes` array and place a mesh/sprite at each `pos` coordinate.
    *   Iterate through the `edges` array and draw lines/tubes connecting the nodes.
    *   Optionally use the `communities` data to visually group or color-code nodes.
3.  **Navigation:** Implementing orbit, pan, and zoom controls for the camera.
4.  **Interaction:**
    *   Handling hover events to show node labels.
    *   Handling click events on a node to fetch its full `CardDTO` from `GET /api/v1/cards/by-source/{entityId}` and display it in a modal.
    *   Providing a dedicated chat input for general graph interrogation.
5.  **Responding to UI Actions:** Listening for `ui_actions` (like `highlight_nodes`) returned from `DialogueAgent` responses and applying the corresponding visual effects (e.g., using an emissive material) to the specified nodes in the scene.

## **7. Integration with the `DialogueAgent`**

The `DialogueAgent`'s workflow for handling queries from the 3D Cosmos is detailed in `2.1_V9.5_DialogueAgent_and_PromptBuilder.md`. The key is that it can now return a `ui_actions` array in its response, which gives the frontend a structured command to execute visually within the 3D scene, creating a tight feedback loop between conversation and visualization.

This guide defines a robust, scalable, and performant architecture for the 3D Knowledge Cosmos, ensuring it integrates seamlessly with the existing V9.5 agent and service model.