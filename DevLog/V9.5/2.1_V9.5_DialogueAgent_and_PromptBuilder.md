### **`2.1_V9.5_DialogueAgent_and_PromptBuilder.md`**

---

# **V9.5 Canonical Guide: `DialogueAgent` & `PromptBuilder`**

**Document Version:** 9.5
**Purpose:** To provide a definitive, deep-dive specification for the real-time conversational components of the 2dots1line system: the `DialogueAgent` service and its dedicated `PromptBuilder`.

## **1. Core Philosophy & Architectural Role**

The `DialogueAgent` and `PromptBuilder` work in tandem to orchestrate the live, turn-by-turn conversation with the user. They are the heart of the system's real-time responsiveness and contextual awareness.

*   **`DialogueAgent` (The Orchestrator):** A stateful service responsible for managing the logic of a single conversational turn. It is a deterministic construct that receives user input, orchestrates the gathering of necessary context, makes a single decisive LLM call, and processes the structured output to produce a user response and update its own internal state for the next turn.

*   **`PromptBuilder` (The Context Assembler):** A deterministic service used exclusively by the `DialogueAgent`. Its sole responsibility is to meticulously gather all required `Context Packages` from various data sources (PostgreSQL, Redis) and assemble them into a single, comprehensive, and perfectly structured system prompt for the `DialogueAgent`'s LLM call.

**Location:**
*   `DialogueAgent.ts`: `services/dialogue-service/src/DialogueAgent.ts`
*   `PromptBuilder.ts`: `services/dialogue-service/src/PromptBuilder.ts` (Co-located, as it is a dedicated dependency)

## **2. Detailed Workflow: A Single Conversational Turn**

This is the strict, deterministic sequence of operations executed by the `DialogueAgent` for every user message.

**Trigger:** The `conversation.controller.ts` receives a request from `POST /api/v1/conversations/messages` and invokes `DialogueAgent.processTurn()`.

### **Phase I: Input Pre-processing (Deterministic Code)**

*   **Responsibility:** `DialogueAgent.ts`
*   **Goal:** Convert all forms of user input into a single, unified text string (`finalInputText`).

1.  **Receive Payload:** The `DialogueAgent` receives `{ userId, conversationId, currentMessageText?, currentMessageMedia?, ui_context?, source_card_id? }`.
2.  **Multi-Modal Handling:** If `currentMessageMedia` is present, the `DialogueAgent` calls the appropriate **atomic tool**:
    *   **Image:** Calls `VisionCaptionTool` to get a caption.
    *   **Audio:** Calls `AudioTranscribeTool` to get a transcript.
    *   **Document:** Calls `DocumentExtractTool` to get extracted text.
3.  **Assemble `finalInputText`:** The code concatenates the `currentMessageText` with any text generated from the media tools.

### **Phase II: Comprehensive Context Assembly**

*   **Responsibility:** `DialogueAgent.ts` invokes `PromptBuilder.ts`
*   **Goal:** Create the complete system prompt for the LLM.

1.  **Call `PromptBuilder`:** The `DialogueAgent` calls `this.promptBuilder.buildPrompt()` with all necessary IDs and the `finalInputText`.
2.  **`PromptBuilder` Actions:** The `PromptBuilder` executes its parallel data fetching and formatting workflow (as detailed in `1.1_V9.5_System_Flows...` and `3.2_V9.5_Context_Packages...`), assembling all required context packages (`CoreIdentity`, `UserMemoryProfile`, `KnowledgeGraphSchema`, `TurnContextPackage`, `CurrentConversationHistory`, etc.) into a single string.

### **Phase III: The "Single Synthesis" LLM Call**

*   **Responsibility:** `DialogueAgent.ts`
*   **Goal:** To get a decisive, structured plan from the LLM in one efficient call.

1.  **Append Instructions:** The `DialogueAgent` appends the final `<instructions>` block to the prompt received from the `PromptBuilder`. This instruction block details the task and the required JSON output schema.
2.  **Execute LLM Call:** The `DialogueAgent` uses its injected atomic `LLMChatTool` to send the complete prompt to the LLM.
3.  **Expected LLM Output (V9.5):** A single, structured JSON object.
    ```json
    {
      "thought_process": "My reasoning for the decision...",
      "response_plan": {
        "decision": "'respond_directly' OR 'query_memory'",
        "key_phrases_for_retrieval": ["..."] OR null,
        "direct_response_text": "..." OR null
      },
      "turn_context_package": {
        "suggested_next_focus": "...",
        "emotional_tone_to_adopt": "...",
        "flags_for_ingestion": ["..."]
      },
      "ui_actions": [ // Optional, for 3D Cosmos or other UI commands
        {
          "action": "highlight_nodes",
          "node_ids": ["..."],
          "style": "focus_pulse_gold"
        }
      ] OR null
    }
    ```

### **Phase IV: Conditional Orchestration & Final Response**

*   **Responsibility:** `DialogueAgent.ts`
*   **Goal:** To execute the LLM's plan and formulate the final response to the user.

1.  **Parse & Persist:** The `DialogueAgent` parses the LLM's JSON response. It immediately saves the `turn_context_package` to Redis (`turn_context:{convoId}`) to maintain state for the next turn.
2.  **Execute Decision:** The code checks `response_plan.decision`.
    *   **If `respond_directly`:** The `direct_response_text` and `ui_actions` are extracted. The turn is effectively over, and these are passed to the controller.
    *   **If `query_memory`:** A multi-step sub-workflow is initiated:
        a.  **Call HRT:** The `DialogueAgent` calls `this.hybridRetrievalTool.execute()` with the `key_phrases_for_retrieval` from the LLM output.
        b.  **Receive Context:** The HRT returns the detailed `AugmentedMemoryContext` object.
        c.  **Make 2nd LLM Call:** The `DialogueAgent` makes a second, targeted LLM call. The prompt for this call is assembled by the `PromptBuilder` again, but this time it includes the `AugmentedMemoryContext`. The instructions ask the LLM to synthesize this new information into a final response.
        d.  **Extract Final Response:** The LLM's response from this second call will now have a `decision` of `respond_directly`. The `DialogueAgent` extracts the `direct_response_text` and any `ui_actions`.

3.  **Return to Controller:** The `DialogueAgent` returns the final `user_response` (containing the text and UI actions) to the `conversation.controller.ts`, which then sends it to the client.

## **3. `PromptBuilder` Deep Dive**

The `PromptBuilder` is the dedicated context preparation engine for the `DialogueAgent`.

**`buildPrompt` Method Input:**
```typescript
interface BuildPromptInput {
  userId: string;
  conversationId: string;
  finalInputText: string;
  sourceCardId?: string;
  augmentedMemoryContext?: AugmentedMemoryContext; // Only for 2nd LLM call in retrieval turns
}
```

**Assembly Logic:**
The `PromptBuilder` is responsible for fetching and formatting every component listed in the `DialogueAgent`'s Input/Output Matrix in `1.1_V9.5_AgentContextOutput.md`. Its primary value is abstracting away the complexity of these parallel data fetches (from PG and Redis) and structured formatting from the `DialogueAgent`'s main turn-processing logic.

## **4. Data Storage & State Management**

The `DialogueAgent` and `PromptBuilder` read from and write to the following locations to manage state across turns and conversations:

| Data Component                     | Storage Location                               | Written By         | Read By           | Notes                                                                                           |
| :--------------------------------- | :--------------------------------------------- | :----------------- | :---------------- | :---------------------------------------------------------------------------------------------- |
| `UserMemoryProfile`                | PostgreSQL: `User.memory_profile`              | `InsightEngine`    | `PromptBuilder`   | The long-term strategic context.                                                                |
| `KnowledgeGraphSchema`             | PostgreSQL: `User.knowledge_graph_schema`      | `InsightEngine`    | `PromptBuilder`   | The "API docs" for the user's graph.                                                            |
| `NextConversationContextPackage`   | PostgreSQL: `User.next_conversation_context_package` | `IngestionAnalyst` | `PromptBuilder`   | The "debrief memo" for the start of a new conversation.                                         |
| **`TurnContextPackage`**           | **Redis**: `turn_context:{conversationId}`     | **`DialogueAgent`** | **`PromptBuilder`** | **The critical, ephemeral turn-to-turn state.** Has a TTL aligned with the conversation timeout. |
| `CoreIdentity`                     | Redis: `config:core_identity`                  | `OntologySteward` (on startup) | `PromptBuilder`   | The global, static persona configuration.                                                     |

## **5. Dependencies & Collaborators**

The `DialogueAgent` is a high-level orchestrator that relies on a suite of specialized tools and services.

| Component Name                 | Type                         | Role & Responsibility                                                                                                                              |
| :----------------------------- | :--------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------- |
| `conversation.controller`      | Upstream Controller          | Invokes the agent for each user message and manages the HTTP response cycle.                                                                       |
| **`PromptBuilder`**            | **Dedicated Service**        | **(Primary Dependency)** Assembles the complete, multi-part system prompt for every LLM call.                                                        |
| **`HybridRetrievalTool`**      | **Specialized Tool**         | **(Primary Dependency)** Executes the sophisticated, multi-stage retrieval pipeline when the `DialogueAgent` receives a `query_memory` decision. |
| `LLMChatTool`                  | Atomic Tool                  | Provides a standardized interface for making API calls to the external LLM service.                                                                |
| `VisionCaptionTool`, etc.      | Atomic Tools                 | A suite of deterministic tools for pre-processing multi-modal input into a unified text format.                                                      |
| All Database Repositories      | Data Access Layer            | Used by the `PromptBuilder` and `HybridRetrievalTool` to fetch the necessary data from PostgreSQL.                                                   |
| Redis Client                   | Cache/State Store            | Used by the `PromptBuilder` to fetch the `TurnContextPackage` and `CoreIdentity`. Used by the `DialogueAgent` to write the `TurnContextPackage`.      |

This detailed guide for the V9.5 `DialogueAgent` and `PromptBuilder` provides a complete blueprint for the real-time conversational core of the system, fully aligned with all established architectural principles.