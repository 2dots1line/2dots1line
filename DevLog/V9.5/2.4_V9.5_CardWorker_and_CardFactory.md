### **`2.4_V9.5_CardWorker_and_CardFactory.md`**

---

# **V9.5 Canonical Guide: `CardWorker` & `CardFactory`**

**Document Version:** 9.5
**Purpose:** To provide a definitive, deep-dive specification for the new `CardWorker` and its core dependency, the `CardFactory`. These components are responsible for the creation of all user-facing `Card` entities, ensuring a clean separation between knowledge generation and its presentation.

## **1. Core Job Responsibility & Philosophy**

The `CardWorker` and `CardFactory` form the heart of the system's **Presentation Layer Pipeline**. They are responsible for deciding *if* and *how* new knowledge should be presented to the user on their 2D Card Canvas.

*   **`CardWorker` (The Event Consumer):** An **asynchronous background worker** that subscribes to the `card-and-graph-queue`. Its sole purpose is to process events published by the `IngestionAnalyst` and `InsightEngine`, determine if new cards should be created based on those events, and orchestrate their creation using the `CardFactory`.

*   **`CardFactory` (The Deterministic Builder):** A **deterministic service** responsible for the business logic of card creation. It consults configuration files (`card_eligibility_rules.json`, `card_templates.json`) to decide if a given knowledge entity is "card-worthy" and then constructs and persists the `Card` record in the database.

**Philosophy:**
*   **Decoupling:** This architecture completely decouples the `IngestionAnalyst` and `InsightEngine` from the concerns of the UI. Their job is to create high-quality knowledge; they don't need to know or care if that knowledge becomes a card.
*   **Centralized & Configurable Logic:** All rules for card creation are centralized in the `CardFactory` and its configuration files. To change what becomes a card, or how it's initially presented, we only need to modify configuration, not agent code.
*   **Asynchronous Presentation:** Card creation happens asynchronously, ensuring that the user-facing canvas updates smoothly in the background without blocking any core processing loops.

**Location:**
*   `CardWorker`: `workers/card-worker/src/CardWorker.ts` (New worker)
*   `CardFactory`: `services/card-service/src/CardFactory.ts` (New or heavily refactored service)

## **2. Detailed Workflow: Processing a Card Creation Job**

This is the sequence of operations for creating new cards.

**Trigger:** The `IngestionAnalyst` or `InsightEngine` publishes an event to the `card-and-graph-queue`. A `CardWorker` instance picks up a job from this queue.

**Example Job Payload:**
```json
{
  "type": "new_entities_created", // or "cycle_artifacts_created"
  "userId": "user-uuid-123",
  "entities": [
    { "id": "muid-abc", "type": "MemoryUnit" },
    { "id": "concept-def", "type": "Concept" },
    { "id": "da-xyz", "type": "DerivedArtifact" },
    { "id": "prompt-456", "type": "ProactivePrompt" }
  ],
  "source": "IngestionAnalyst" // or "InsightEngine"
}
```

### **The `CardWorker` Workflow**

1.  **Receive Job:** The `CardWorker` receives the job payload from the queue.
2.  **Iterate Through Entities:** The worker loops through the `entities` array in the payload.
3.  **Invoke `CardFactory`:** For each entity, the worker calls `this.cardFactory.createCardForEntity(entity, userId)`.
4.  **Log Results:** The worker logs the outcome for each entity (e.g., "Card created for MemoryUnit muid-abc", "Concept concept-def did not meet eligibility criteria").
5.  **Mark Job Complete:** Once all entities in the payload have been processed, the job is marked as complete.

### **The `CardFactory` Workflow (`createCardForEntity`)**

This is the deterministic, rule-based core of the process.

1.  **Fetch Full Entity Data:** The `CardFactory` receives the entity's `id` and `type`. It calls the appropriate repository (e.g., `MemoryRepository`, `ConceptRepository`) to fetch the full entity record, including its properties like `importance_score` or `salience`.
2.  **Check Eligibility:**
    *   **Dependency:** `OntologySteward` (to get cached configuration).
    *   **Action:** It fetches the `card_eligibility_rules.json` configuration. It finds the rule set corresponding to the entity's `type` (e.g., `"MemoryUnit"`). It then evaluates the entity against these rules (e.g., `entity.importance_score > rule.importance_threshold`).
3.  **If Not Eligible:** The method returns `{ created: false, reason: "Did not meet importance threshold" }`. The `CardWorker` logs this and moves on.
4.  **If Eligible, Construct Card:**
    *   **Get Card Template:** It fetches `card_templates.json` and finds the template matching the entity's `type` (e.g., `"MemoryUnit_from_Conversation"`).
    *   **Build `display_data`:** It uses the template to construct the initial `Card.display_data` JSONB object. The template might specify which fields from the source entity to use for `title` and `previewText`.
    *   **Build `Card` Record:** It assembles the complete `Card` record object, including `userId`, `card_type` (from the template), `source_entity_id`, `source_entity_type`, and the newly constructed `display_data`.
5.  **Persist Card:** The `CardFactory` calls `this.cardRepository.create()` to save the new `Card` record to the PostgreSQL database.
6.  **Return Success:** The method returns `{ created: true, cardId: newCard.card_id }`.

## **3. `CardFactory` & Configuration Files**

The `CardFactory` is entirely driven by configuration, making it highly flexible.

*   **`config/card_eligibility_rules.json`:**
    *   **Purpose:** Decides if a knowledge entity is important enough to deserve its own card on the canvas.
    *   **Example Structure:**
        ```json
        {
          "MemoryUnit": {
            "min_importance_score": 5.0,
            "required_source_types": ["conversation_extraction", "journal_entry"]
          },
          "Concept": {
            "min_salience": 0.6,
            "eligible_types": ["goal", "value", "project", "person"]
          },
          "DerivedArtifact": {
            "eligible_types": ["cycle_report", "insight_summary", "trophy"]
          },
          "ProactivePrompt": {
            "always_eligible": true // All quests become cards
          }
        }
        ```

*   **`config/card_templates.json`:**
    *   **Purpose:** Provides a template for creating the `Card` record itself, especially its `card_type` and initial `display_data`.
    *   **Example Structure:**
        ```json
        {
          "MemoryUnit": {
            "card_type": "memory_unit_card",
            "display_data": {
              "title_source_field": "title", // Use MemoryUnit.title for the card's display title
              "preview_source_field": "content", // Use MemoryUnit.content for the card's preview
              "preview_truncate_length": 150
            }
          },
          "Concept_goal": { // Specific template for a 'goal' type Concept
            "card_type": "goal_card",
            "display_data": {
              "title_source_field": "name",
              "preview_source_field": "description"
            }
          },
          "ProactivePrompt": {
            "card_type": "quest_card",
            "display_data": {
              "title_source_field": "prompt_text", // Use the prompt text as the title
              "preview_source_field": "rationale"
            }
          }
        }
        ```

## **4. Data Storage & State Management**

The `CardWorker` and `CardFactory` are primarily responsible for writing to one key table.

| Data Component | Action   | Storage Location              | Written By `CardWorker` via... |
| :------------- | :------- | :---------------------------- | :----------------------------- |
| `Card`         | **Create** | PostgreSQL: `cards` table     | `CardFactory` -> `CardRepository` |

They read from `MemoryUnit`, `Concept`, etc., to make decisions but do not modify them.

## **5. Dependencies & Collaborators**

| Component Name                 | Type                         | Role & Responsibility                                                                                                                              |
| :----------------------------- | :--------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------- |
| `IngestionAnalyst`, `InsightEngine` | Upstream Workers             | Publish events with "card-worthy" entities to the `card-and-graph-queue`.                                                                            |
| **`CardFactory`**              | **Primary Service Dependency** | **(Key Dependency)** Encapsulates all business logic for evaluating entity eligibility and constructing the final `Card` record for persistence.         |
| `OntologySteward`              | Configuration Service        | Provides the `CardFactory` with cached access to `card_eligibility_rules.json` and `card_templates.json`.                                             |
| All Database Repositories      | Data Access Layer            | Used by the `CardFactory` to fetch the full data for an entity before evaluating its eligibility.                                                      |
| `CardRepository`               | Data Access Layer            | Used by the `CardFactory` to persist the newly created `Card` record.                                                                                |

---

#### **Updated Flowchart: The V9.5 Presentation Loop (Card Generation)**

```
             ┌───────────────────────────────┐
             │ `IngestionAnalyst` /          │
             │   `InsightEngine`             │
             └───────────────┬───────────────┘
                             │ 1. Publishes event after creating knowledge entities
                             ▼
             ┌───────────────────────────────┐
             │    `card-and-graph-queue`     │
             │ (Event: { type, userId, entities }) │
             └───────────────┬───────────────┘
                             │ 2. `CardWorker` picks up job
                             ▼
             ┌───────────────────────────────┐
             │         `CardWorker`          │
             └───────────────┬───────────────┘
                             │ 3. For each entity in event...
                             │    Calls `CardFactory.createCardForEntity()`
                             ▼
             ┌───────────────────────────────┐
             │         `CardFactory`         │
             └───────────────┬───────────────┘
                             │ 4. Fetches full entity data from PG (e.g., `MemoryRepository`)
                             │
                             │ 5. Checks `card_eligibility_rules.json`
                             │
       ┌─────────────────────┴─────────────────────┐
       │                                           │
IF NOT ELIGIBLE                           IF ELIGIBLE
       │                                           │
       │ 6a. Returns { created: false }            │ 6b. Fetches template from `card_templates.json`
       │                                           │
       ▼                                           │ 6c. Constructs `Card` record object
   ┌───────────────────┐                         │
   │ `CardWorker` logs │                         │ 6d. Persists `Card` to PostgreSQL via `CardRepository`
   │ "Skipped" message │                         │
   └───────────────────┘                         │ 6e. Returns { created: true, cardId: ... }
                                                 │
                                                 ▼
                                     ┌───────────────────┐
                                     │ `CardWorker` logs │
                                     │ "Card Created"    │
                                     └───────────────────┘
```

This guide solidifies the role of the `CardWorker` as the gatekeeper for the user's 2D canvas. This separation makes the entire system more robust, modular, and easier to manage, as the logic for knowledge creation is now cleanly divorced from the logic for its presentation.