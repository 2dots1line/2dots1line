### **`3.1_V9.6_Database_Schema_Unified.md`**

---

# **V9.6 Definitive Unified Database Schema**

**Document Version:** 9.6
**Purpose:** To provide the single, canonical source of truth for the schemas of all persistence layers in the 2dots1line system: PostgreSQL (the system of record), Neo4j (the system of relationships), and Weaviate (the system of semantics).

---

## **Part 1: PostgreSQL V9.6 Schema (Prisma Format)**

**Location:** `packages/database/prisma/schema.prisma`

This relational database is the **System of Record**. It stores all core, transactional, and user-generated data authoritatively.

```prisma
// packages/database/prisma/schema.prisma
// V9.6 - Definitive Schema with Unified InteractionLog & Graph Projection Table

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================================================================
// SECTION 1: CORE USER & SESSION MANAGEMENT
// ========================================================================

model User {
  user_id String @id @default(uuid())
  email   String @unique
  hashed_password String?
  name            String?
  region          String  @default("us")
  account_status  String  @default("active")
  created_at      DateTime @default(now())
  last_active_at  DateTime? @updatedAt

  // V9.5: Central context packages generated by InsightEngine
  memory_profile                    Json? @db.JsonB
  knowledge_graph_schema            Json? @db.JsonB
  next_conversation_context_package Json? @db.JsonB

  // V9.5: Cycle management fields
  last_cycle_started_at   DateTime?
  concepts_created_in_cycle Int     @default(0)

  // V9.5: User-configurable settings
  preferences Json? @db.JsonB

  // --- Relations ---
  sessions                UserSession[]
  conversations           Conversation[]
  cards                   Card[]
  memory_units            MemoryUnit[]
  concepts                Concept[]
  media_items             Media[]             @relation("UserMedia")
  derived_artifacts       DerivedArtifact[]
  user_challenges         UserChallenge[]
  proactive_prompts       ProactivePrompt[]
  growth_events           GrowthEvent[]       @relation("UserGrowthEvents")
  communities             Community[]         @relation("UserCommunities")
  interaction_logs        InteractionLog[]    @relation("UserInteractionLogs")
  graph_projections       UserGraphProjection[] // V9.6: For 3D Cosmos

  @@map("users")
}

model UserSession {
  session_id     String   @id @default(uuid())
  user_id        String
  user           User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  device_info    Json?    @db.JsonB
  ip_address     String?
  user_agent     String?
  created_at     DateTime @default(now())
  expires_at     DateTime
  last_active_at DateTime @updatedAt

  @@index([user_id])
  @@map("user_sessions")
}


// ========================================================================
// SECTION 2: CONVERSATION & INTERACTION LOGGING
// ========================================================================

model Conversation {
  id               String    @id @default(uuid())
  user_id          String
  user             User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  title            String?
  start_time       DateTime  @default(now())
  last_active_time DateTime  @updatedAt
  ended_at         DateTime?
  status           String    @default("active")
  importance_score Float?
  context_summary  String?

  source_card_id   String?
  source_card      Card?     @relation(fields: [source_card_id], references: [card_id], onDelete: SetNull)

  messages             ConversationMessage[]
  spawned_memory_units MemoryUnit[]          @relation("ConversationToMemoryUnit")

  @@index([user_id, status])
  @@map("conversations")
}

model ConversationMessage {
  id                String       @id @default(uuid())
  conversation_id   String
  conversation      Conversation @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  role              String       // 'user' or 'assistant'
  content           String
  message_type      String       @default("text")
  timestamp         DateTime     @default(now())
  llm_call_metadata Json?        @db.JsonB

  @@index([conversation_id, timestamp])
  @@map("conversation_messages")
}


// ========================================================================
// SECTION 3: PRESENTATION & KNOWLEDGE ENTITIES
// ========================================================================

// The stable anchor for the 2D UI Canvas
model Card {
  card_id             String    @id @default(uuid())
  user_id             String
  user                User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  card_type           String
  source_entity_id    String
  source_entity_type  String    // 'MemoryUnit', 'Concept', 'DerivedArtifact', 'ProactivePrompt'
  status              String    @default("active_canvas") // 'active_canvas', 'active_archive', 'completed'
  is_favorited        Boolean   @default(false)
  display_data        Json?     @db.JsonB // Cached title, preview, etc.
  is_synced           Boolean   @default(true)
  created_at          DateTime  @default(now())
  updated_at          DateTime  @updatedAt

  initiated_conversations Conversation[]

  @@index([user_id, status])
  @@index([source_entity_id, source_entity_type])
  @@map("cards")
}

// The underlying knowledge nodes
model MemoryUnit {
  muid                    String    @id @default(uuid())
  user_id                 String
  user                    User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  source_type             String
  title                   String?
  content                 String
  creation_ts             DateTime
  ingestion_ts            DateTime  @default(now())
  last_modified_ts        DateTime  @updatedAt
  importance_score        Float?
  sentiment_score         Float? // V9.5: Added for sentiment analysis queries
  metadata                Json?     @db.JsonB
  source_conversation_id  String?
  source_conversation     Conversation? @relation("ConversationToMemoryUnit", fields: [source_conversation_id], references: [id], onDelete: SetNull)

  media_items                 Media[]           @relation("MemoryUnitMedia")
  derived_artifacts_as_source DerivedArtifact[] @relation("DerivedArtifactSourceMemoryUnit")

  @@index([user_id, creation_ts(sort: Desc)])
  @@map("memory_units")
}

model Concept {
  concept_id String @id @default(uuid())
  user_id    String
  user       User   @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  name       String
  type       String
  description         String?
  community_id        String?
  community           Community? @relation(fields: [community_id], references: [community_id], onDelete: SetNull)
  status              String     @default("active") // 'active', 'merged', 'archived'
  merged_into_concept_id String?
  merged_into_concept    Concept?   @relation("ConceptMergeTarget", fields: [merged_into_concept_id], references: [concept_id], onDelete: NoAction, onUpdate: NoAction)
  merged_from_concepts   Concept[]  @relation("ConceptMergeTarget")
  created_at             DateTime   @default(now())
  last_updated_ts        DateTime   @updatedAt
  salience               Float?
  metadata               Json?      @db.JsonB

  derived_artifacts_as_source DerivedArtifact[] @relation("DerivedArtifactSourceConcept")

  @@unique([user_id, name, type])
  @@map("concepts")
}

model Media {
  media_id          String     @id @default(uuid())
  user_id           String
  user              User       @relation("UserMedia", fields: [user_id], references: [user_id], onDelete: Cascade)
  memory_unit_id    String?
  memory_unit       MemoryUnit? @relation("MemoryUnitMedia", fields: [memory_unit_id], references: [muid], onDelete: SetNull)
  type              String     // 'image', 'audio', 'document'
  storage_url       String
  filename          String?
  mime_type         String?
  size_bytes        Int?
  processing_status String     @default("pending")
  metadata          Json?      @db.JsonB
  created_at        DateTime   @default(now())

  @@map("media_items")
}

// ========================================================================
// SECTION 4: GROWTH, GUIDANCE & DERIVED CONTENT
// ========================================================================

model GrowthEvent {
  event_id    String   @id @default(uuid())
  user_id     String
  user        User     @relation("UserGrowthEvents", fields: [user_id], references: [user_id], onDelete: Cascade)
  entity_id   String
  entity_type String
  dim_key     String
  delta       Float
  source      String
  created_at  DateTime @default(now())
  details     Json?    @db.JsonB // { rationale: string }

  @@index([user_id, dim_key])
  @@map("growth_events")
}

model UserChallenge {
  user_challenge_id String    @id @default(uuid())
  user_id           String
  user              User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  challenge_template_id String
  status                String    @default("active")
  start_time            DateTime  @default(now())
  completion_time       DateTime?
  progress_data         Json?     @db.JsonB

  @@index([user_id, status])
  @@map("user_challenges")
}

model ProactivePrompt {
  prompt_id    String    @id @default(uuid())
  user_id      String
  user         User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  prompt_text  String
  source_agent String
  status       String    @default("pending")
  created_at   DateTime  @default(now())
  metadata     Json?     @db.JsonB

  @@index([user_id, status])
  @@map("proactive_prompts")
}

model DerivedArtifact {
  artifact_id        String    @id @default(uuid())
  user_id            String
  user               User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  artifact_type      String    // 'insight_summary', 'cycle_report', 'trophy'
  title              String?
  content_narrative  String?
  content_data       Json?     @db.JsonB
  generated_by_agent String?
  source_memory_unit_id String?
  source_memory_unit    MemoryUnit? @relation("DerivedArtifactSourceMemoryUnit", fields: [source_memory_unit_id], references: [muid], onDelete: SetNull)
  source_concept_id     String?
  source_concept        Concept?    @relation("DerivedArtifactSourceConcept", fields: [source_concept_id], references: [concept_id], onDelete: SetNull)
  created_at            DateTime    @default(now())

  @@index([user_id, artifact_type])
  @@map("derived_artifacts")
}

model Community {
  community_id     String    @id @default(uuid())
  user_id          String
  user             User      @relation("UserCommunities", fields: [user_id], references: [user_id], onDelete: Cascade)
  name             String?
  description      String?
  created_at       DateTime  @default(now())
  last_analyzed_ts DateTime? @updatedAt
  metadata         Json?     @db.JsonB

  concepts Concept[]

  @@index([user_id, name])
  @@map("communities")
}


// ========================================================================
// SECTION 5: UNIFIED INTERACTION LOG & 3D COSMOS DATA
// ========================================================================

model InteractionLog {
  interaction_id String   @id @default(uuid())
  user_id        String
  user           User     @relation("UserInteractionLogs", fields: [user_id], references: [user_id], onDelete: Cascade)
  timestamp      DateTime @default(now())
  interaction_type String   // e.g., 'user_note_on_card', 'feedback_on_concept_type'
  target_entity_id   String?
  target_entity_type String?
  content_text      String?
  content_structured Json?    @db.JsonB
  metadata         Json?    @db.JsonB

  @@index([target_entity_id, target_entity_type])
  @@map("interaction_logs")
}

// V9.6: New table to store pre-computed 3D graph projections
model UserGraphProjection {
  projection_id       String   @id @default(uuid())
  user_id             String
  user                User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  status              String   @default("completed") // 'processing', 'completed', 'failed'
  projection_data     Json     @db.JsonB // The large JSON object with nodes, edges, and 3D positions
  created_at          DateTime @default(now())

  @@index([user_id, created_at(sort: Desc)])
  @@map("user_graph_projections")
}
```

---

## **Part 2: Neo4j V9.5 Graph Schema (Cypher DDL)**

**Location:** `packages/database/src/neo4j/schema.cypher`

This graph database is the **System of Relationships**. Its node properties are mirrors of the primary keys and key indexed fields from PostgreSQL to facilitate graph traversals and linkage.

**Cypher DDL for Constraints & Indexes (V9.5):**
```cypher
// --- Unique Constraints (auto-create backing indexes) ---
CREATE CONSTRAINT user_userId_unique IF NOT EXISTS FOR (n:User) REQUIRE n.userId IS UNIQUE;
CREATE CONSTRAINT memoryunit_muid_unique IF NOT EXISTS FOR (n:MemoryUnit) REQUIRE n.muid IS UNIQUE;
CREATE CONSTRAINT concept_id_unique IF NOT EXISTS FOR (n:Concept) REQUIRE n.id IS UNIQUE;
CREATE CONSTRAINT derivedartifact_id_unique IF NOT EXISTS FOR (n:DerivedArtifact) REQUIRE n.id IS UNIQUE;
CREATE CONSTRAINT community_community_id_unique IF NOT EXISTS FOR (n:Community) REQUIRE n.community_id IS UNIQUE;

// --- Indexes for Performance ---
// Scoping by User ID is critical for multi-tenancy performance
CREATE INDEX memoryunit_userId_idx IF NOT EXISTS FOR (n:MemoryUnit) ON (n.userId);
CREATE INDEX concept_userId_idx IF NOT EXISTS FOR (n:Concept) ON (n.userId);
CREATE INDEX derivedartifact_userId_idx IF NOT EXISTS FOR (n:DerivedArtifact) ON (n.userId);
CREATE INDEX community_userId_idx IF NOT EXISTS FOR (n:Community) ON (n.userId);

// Indexing frequently queried properties
CREATE INDEX memoryunit_creation_ts_idx IF NOT EXISTS FOR (n:MemoryUnit) ON (n.creation_ts);
CREATE INDEX concept_name_idx IF NOT EXISTS FOR (n:Concept) ON (n.name);
CREATE INDEX concept_type_idx IF NOT EXISTS FOR (n:Concept) ON (n.type);
CREATE INDEX concept_status_idx IF NOT EXISTS FOR (n:Concept) ON (n.status);
CREATE INDEX derivedartifact_artifact_type_idx IF NOT EXISTS FOR (n:DerivedArtifact) ON (n.artifact_type);

// Relationship Property Indexes (useful for weighted or labeled relationship queries)
CREATE INDEX rel_related_to_label_idx IF NOT EXISTS FOR ()-[r:RELATED_TO]-() ON (r.relationship_label);
```

---

## **Part 3: Weaviate V9.5 Vector Schema (JSON Format)**

**Location:** `packages/database/src/weaviate/schema.json`

This vector database is the **System of Semantics**. It provides fast, meaning-based search across all textual content. The schema remains a single, unified class for simplicity and powerful cross-entity searches.

```json
{
  "classes": [
    {
      "class": "UserKnowledgeItem",
      "description": "A unified searchable item representing textual content from any source entity. This is the semantic index for the user's entire knowledge graph.",
      "vectorizer": "none",
      "properties": [
        {
          "name": "externalId",
          "dataType": ["uuid"],
          "description": "The UUID of this specific text chunk or high-level entity text."
        },
        {
          "name": "userId",
          "dataType": ["string"],
          "description": "The user this item belongs to.",
          "indexInverted": true
        },
        {
          "name": "sourceEntityType",
          "dataType": ["string"],
          "description": "The type of the original entity in PostgreSQL (e.g., 'MemoryUnit', 'Concept', 'ConversationMessage', 'InteractionLog').",
          "indexInverted": true
        },
        {
          "name": "sourceEntityId",
          "dataType": ["uuid"],
          "description": "The UUID of the original entity in PostgreSQL.",
          "indexInverted": true
        },
        {
          "name": "textContent",
          "dataType": ["text"],
          "description": "The actual text content that is vectorized and made searchable."
        },
        {
          "name": "title",
          "dataType": ["text"],
          "description": "Title of the source entity, if applicable.",
          "indexInverted": true,
          "tokenization": "word"
        },
        {
          "name": "embeddingModelVersion",
          "dataType": ["string"],
          "description": "Version of the external model used for the vector generation.",
          "indexInverted": true
        },
        {
          "name": "createdAt",
          "dataType": ["date"],
          "description": "Creation timestamp for temporal filtering.",
          "indexInverted": true
        },
        {
          "name": "importanceScore",
          "dataType": ["number"],
          "description": "Importance/salience score of the source entity, if applicable.",
          "indexInverted": true
        },
        {
          "name": "tags",
          "dataType": ["text[]"],
          "description": "Keywords or tags associated with this text content.",
          "indexInverted": true,
          "tokenization": "word"
        }
      ]
    }
  ]
}
```

This unified V9.5 database schema provides a cohesive, complementary, and exhaustive foundation for the entire application, including the new 3D Cosmos feature. Terminology and structure are now consistent across all three database designs.