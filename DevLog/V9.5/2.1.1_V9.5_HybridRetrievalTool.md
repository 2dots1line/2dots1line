# **Canonical Specification: HybridRetrievalTool V9.3**

**Document Version:** V9.3 Final  
**Last Updated:** January 2025  
**Location:** `packages/tools/retrieval/HybridRetrievalTool.ts`

## **Executive Summary**

The `HybridRetrievalTool` (HRT) is a sophisticated, multi-stage retrieval system that intelligently surfaces the most relevant memory context for the `DialogueAgent`. It combines semantic search (Weaviate), graph traversal (Neo4j), and intelligent scoring to deliver prioritized, contextually relevant information from the user's personal knowledge graph.

**Key Innovation:** The HRT employs a **weighted scoring mechanism** that evaluates retrieved entities across four dimensions: semantic similarity, recency, salience, and user preferences, ensuring that only the most valuable information is surfaced to the LLM.

## **Core Design Principles**

### **1. Security & Determinism**
- **No LLM-Generated Queries:** All database queries use pre-approved, parameterized templates
- **Parameter Validation:** Strict input validation prevents injection attacks and resource exhaustion
- **Deterministic Logic:** All retrieval logic after receiving `key_phrases` is deterministic code

### **2. Intelligent Prioritization**
- **Multi-Factor Scoring:** Entities are scored across semantic similarity, recency, salience, and user preferences
- **Tunable Weights:** Scoring weights are configurable for different retrieval scenarios
- **Quality Over Quantity:** Returns fewer, higher-quality results rather than exhaustive lists

### **3. Graceful Degradation**
- **Service Independence:** Handles scenarios where individual services (Weaviate, Neo4j) are unavailable
- **Partial Results:** Provides meaningful context even when some retrieval stages fail
- **Comprehensive Error Handling:** All failure modes return structured, actionable feedback

### **4. Maintainability & Testability**
- **Modular Architecture:** Internal micro-modules enable focused testing and maintenance
- **Configuration-Driven:** Templates and parameters are externalized for easy tuning
- **Audit Trail:** All queries and scoring decisions are logged for analysis

## **System Integration Context**

The HRT operates as a critical component in the V9.3 agent architecture:

```
DialogueAgent (LLM decides to query_memory)
    ↓ (provides key_phrases_for_retrieval)
HybridRetrievalTool.execute()
    ↓ (returns AugmentedMemoryContext)
DialogueAgent (incorporates context into renewed LLM query to get final response)
```

**Input Contract:**
```typescript
interface HRTInput {
  keyPhrasesForRetrieval: string[];        // From DialogueAgent LLM
  userId: string;                          // Current user context
  retrievalScenario?: string;              // Optional scenario key (default: 'neighborhood')
  maxResults?: number;                     // Optional result limit override
}
```

**Output Contract:**
```typescript
interface AugmentedMemoryContext {
  retrievedMemoryUnits: MemoryUnit[];      // Fully hydrated memory units
  retrievedConcepts: Concept[];            // Fully hydrated concepts  
  retrievedArtifacts?: DerivedArtifact[];  // Optional artifacts
  retrievalSummary: string;                // Human-readable retrieval status
  scoringDetails?: ScoringMetadata;        // Optional scoring breakdown
  totalCandidatesEvaluated: number;        // Metrics for optimization
}
```

## **Architectural Overview**

The HRT employs a **six-stage retrieval pipeline** with intelligent scoring and prioritization:

```
Stage 1: Key Phrase Processing (Deterministic)
    ↓
Stage 2: Semantic Grounding (Weaviate Vector Search)
    ↓
Stage 3: Graph Traversal (Neo4j Template-Based Queries)
    ↓
Stage 4: Lightweight Pre-Hydration (PostgreSQL Metadata)
    ↓
Stage 5: Intelligent Scoring & Prioritization (Deterministic)
    ↓
Stage 6: Full Content Hydration (PostgreSQL Content)
```

### **Internal Architecture Components**

The HRT is composed of four internal micro-modules, each with specific responsibilities:

#### **1. CypherBuilder**
**Location:** `packages/tools/retrieval/src/internal/CypherBuilder.ts`  
**Responsibility:** Safe construction of Neo4j queries from pre-approved templates

```typescript
interface CypherBuilder {
  buildQuery(
    queryKey: string, 
    runtimeParams: Record<string, any>
  ): { cypher: string; params: Record<string, any> };
}
```

**Key Features:**
- Loads templates from `config/cypher_templates.json`
- Validates parameters against allowed parameter schemas
- Applies `ParamGuard` constraints to prevent resource exhaustion
- Returns parameterized queries safe for Neo4j execution

#### **2. ParamGuard**
**Location:** `packages/tools/retrieval/src/internal/ParamGuard.ts`  
**Responsibility:** Runtime parameter validation and constraint enforcement

```typescript
interface ParamGuard {
  validate(queryKey: string, params: Record<string, any>): void;
}
```

**Validation Rules:**
- `params.limit <= MAX_RESULT_LIMIT` (default: 100)
- `params.hops <= MAX_GRAPH_HOPS` (default: 3)
- `params.seedEntities.length <= MAX_SEED_ENTITIES` (default: 10)
- Entity ID format validation
- User ID ownership verification

#### **3. EntityScorer**
**Location:** `packages/tools/retrieval/src/internal/EntityScorer.ts`  
**Responsibility:** Multi-factor scoring and prioritization of candidate entities

```typescript
interface EntityScorer {
  scoreEntities(
    candidates: CandidateEntity[],
    scoringContext: ScoringContext
  ): ScoredEntity[];
}

interface ScoringContext {
  seedEntitiesWithSimilarity: SeedEntity[];
  retrievalWeights: RetrievalWeights;
  userPreferences: UserPreferences;
  metadataMap: EntityMetadataMap;
}
```

**Scoring Formula:**
```
Score(entity) = (α × SemanticSimilarity) + (β × Recency) + (γ × Salience) + (δ × UserPreference)
```

#### **4. HydrationAdapter**
**Location:** `packages/tools/retrieval/src/internal/HydrationAdapter.ts`  
**Responsibility:** Efficient batch hydration of scored entities from PostgreSQL

```typescript
interface HydrationAdapter {
  hydrateEntities(
    scoredEntities: ScoredEntity[],
    userId: string
  ): Promise<AugmentedMemoryContext>;
}
```

**Key Features:**
- Type-based entity bucketing for batch queries
- Repository-level batch operations
- Stale entity handling and cleanup
- Result deduplication and ordering

## **Detailed Execution Workflow**

### **Stage 1: Key Phrase Processing**
**Input:** `keyPhrasesForRetrieval` array from DialogueAgent LLM  
**Type:** Deterministic processing  
**Purpose:** Sanitize and optimize input phrases for semantic search

**Process:**
1. **Safety Validation:**
   - Truncate to `MAX_KEY_PHRASES` (default: 5) if exceeded
   - Filter out empty strings and excessive whitespace
   - Apply phrase length limits (max 100 characters per phrase)

2. **Optimization:**
   - Prioritize shorter, more specific phrases
   - Remove duplicate or highly similar phrases
   - Apply stop-word filtering for semantic search efficiency

3. **Logging:**
   - Log any truncation or filtering for monitoring
   - Track phrase processing metrics

**Output:** `processedKeyPhrases: string[]`

**Failure Handling:** If all phrases are filtered out, proceed with empty array (triggers fallback scenarios)

### **Stage 2: Semantic Grounding**
**Input:** `processedKeyPhrases`, `userId`  
**Type:** Weaviate vector search  
**Purpose:** Identify seed entities semantically related to input phrases

**Process:**
1. **Vector Search Execution:**
   ```typescript
   for each phrase in processedKeyPhrases:
     results = weaviate.nearText(phrase, {
       className: 'UserKnowledgeItem',
       where: { path: ['userId'], operator: 'Equal', valueString: userId },
       limit: WEAVIATE_RESULTS_PER_PHRASE // default: 3
     })
   ```

2. **Seed Entity Extraction:**
   - Extract `sourceEntityId` and `sourceEntityType` from each result
   - Capture Weaviate similarity scores for later use
   - Deduplicate entities across phrases

3. **Score Normalization:**
   - Convert Weaviate distances to similarity scores (0-1 range)
   - Apply distance-to-similarity transformation: `similarity = 1 / (1 + distance)`

**Output:** `seedEntitiesWithSimilarity: SeedEntity[]`
```typescript
interface SeedEntity {
  id: string;
  type: 'MemoryUnit' | 'Concept' | 'DerivedArtifact';
  weaviateScore: number;  // 0-1, higher = more similar
  sourcePhrase: string;   // Which phrase led to this entity
}
```

**Failure Handling:**
- If Weaviate is unavailable: Log error, proceed with empty seed list
- If no semantic matches found: Continue to graph traversal with broader query templates
- Partial failures: Use available results, log missing data

### **Stage 3: Graph Traversal**
**Input:** `seedEntitiesWithSimilarity`, `userId`, `retrievalScenario`  
**Type:** Neo4j template-based query  
**Purpose:** Discover contextually related entities through graph relationships

**Process:**
1. **Template Selection:**
   ```typescript
   const template = cypherTemplateRegistry[retrievalScenario || 'neighborhood'];
   if (!template) throw new Error(`Unknown retrieval scenario: ${retrievalScenario}`);
   ```

2. **Query Construction:**
   ```typescript
   const { cypher, params } = cypherBuilder.buildQuery(retrievalScenario, {
     seedEntities: seedEntitiesWithSimilarity.map(e => ({ id: e.id, type: e.type })),
     userId: userId,
     hops: template.defaultParams.hops || 2,
     limit: template.defaultParams.limit || 20
   });
   ```

3. **Parameter Validation:**
   - Apply `ParamGuard` constraints
   - Validate entity ID formats and ownership
   - Ensure graph traversal limits are respected

4. **Query Execution:**
   ```typescript
   const session = neo4jDriver.session();
   try {
     const result = await session.run(cypher, params);
     candidateEntities = extractEntitiesFromResult(result);
   } finally {
     await session.close();
   }
   ```

**Output:** `candidateEntities: CandidateEntity[]`
```typescript
interface CandidateEntity {
  id: string;
  type: string;
  relationshipPath?: string;  // How this entity relates to seeds
  hopDistance?: number;       // Distance from seed entities
}
```

**Common Query Templates:**
- **`neighborhood`:** Finds entities within N hops of seed entities
- **`timeline`:** Retrieves entities with temporal relationships
- **`episodesByConcept`:** Finds memory units related to specific concepts
- **`conceptsByTheme`:** Discovers thematically related concepts

**Failure Handling:**
- Neo4j timeout: Return partial results with timeout flag
- Query execution error: Log error, return empty candidate list
- Connection failure: Proceed to scoring with seed entities only

### **Stage 4: Lightweight Pre-Hydration**
**Input:** `candidateEntities`, `userId`  
**Type:** PostgreSQL metadata queries  
**Purpose:** Fetch scoring metadata without full content hydration

**Process:**
1. **Entity Bucketing:**
   ```typescript
   const buckets = {
     memoryUnits: candidateEntities.filter(e => e.type === 'MemoryUnit').map(e => e.id),
     concepts: candidateEntities.filter(e => e.type === 'Concept').map(e => e.id),
     artifacts: candidateEntities.filter(e => e.type === 'DerivedArtifact').map(e => e.id)
   };
   ```

2. **Batch Metadata Queries:**
   ```sql
   -- Memory Unit metadata
   SELECT muid, importance_score, ingestion_ts, last_modified_ts 
   FROM memory_units 
   WHERE muid = ANY($1) AND user_id = $2;
   
   -- Concept metadata  
   SELECT cid, salience, created_at, last_updated_ts
   FROM concepts
   WHERE cid = ANY($1) AND user_id = $2;
   ```

3. **Metadata Mapping:**
   - Create efficient lookup map: `entityId -> metadata`
   - Handle missing entities (deleted/stale references)
   - Apply default values for missing scores

**Output:** `entityMetadataMap: Map<string, EntityMetadata>`
```typescript
interface EntityMetadata {
  entityId: string;
  entityType: string;
  importanceScore?: number;    // For MemoryUnits
  salience?: number;          // For Concepts
  createdAt: Date;
  lastModified: Date;
  isStale?: boolean;          // Entity exists in graph but not in PG
}
```

**Failure Handling:**
- Database connection issues: Use default scores for all entities
- Partial query failures: Use available metadata, apply defaults for missing
- Stale entity detection: Mark entities as stale for cleanup

### **Stage 5: Intelligent Scoring & Prioritization**
**Input:** `candidateEntities`, `seedEntitiesWithSimilarity`, `entityMetadataMap`, `userPreferences`  
**Type:** Deterministic scoring algorithm  
**Purpose:** Rank entities by relevance across multiple dimensions

**Process:**
1. **Load Scoring Configuration:**
   ```typescript
   const weights = await loadRetrievalWeights(userId); // User-specific or default
   // { alpha: 0.4, beta: 0.25, gamma: 0.25, delta: 0.1 }
   ```

2. **Calculate Component Scores:**

   **a) Semantic Similarity Score (α):**
   ```typescript
   function calculateSemanticScore(entity: CandidateEntity): number {
     if (entity.wasSeedEntity) {
       return entity.weaviateScore; // Direct from Weaviate
     } else {
       // Derived score based on relationship to seeds
       const maxSeedScore = Math.max(...connectedSeeds.map(s => s.weaviateScore));
       const decayFactor = Math.pow(0.8, entity.hopDistance || 1);
       return maxSeedScore * decayFactor;
     }
   }
   ```

   **b) Recency Score (β):**
   ```typescript
   function calculateRecencyScore(metadata: EntityMetadata): number {
     const ageInDays = (Date.now() - metadata.lastModified.getTime()) / (1000 * 60 * 60 * 24);
     const decayRate = 0.1; // Configurable decay parameter
     return Math.exp(-decayRate * ageInDays); // Exponential decay
   }
   ```

   **c) Salience Score (γ):**
   ```typescript
   function calculateSalienceScore(metadata: EntityMetadata): number {
     const rawScore = metadata.importanceScore || metadata.salience || 0;
     return Math.min(rawScore / 10.0, 1.0); // Normalize to 0-1 range
   }
   ```

   **d) User Preference Score (δ):**
   ```typescript
   function calculatePreferenceScore(entity: CandidateEntity, prefs: UserPreferences): number {
     const typeBoost = prefs.preferredConceptTypes?.[entity.type] || 1.0;
     const themeBoost = calculateThemeAlignment(entity, prefs.activeThemes);
     return Math.min(typeBoost * themeBoost, 2.0); // Cap at 2x boost
   }
   ```

3. **Final Score Calculation:**
   ```typescript
   function calculateFinalScore(entity: CandidateEntity, context: ScoringContext): number {
     const α = context.weights.alpha;
     const β = context.weights.beta;
     const γ = context.weights.gamma;
     const δ = context.weights.delta;
     
     const semanticScore = calculateSemanticScore(entity);
     const recencyScore = calculateRecencyScore(context.metadata[entity.id]);
     const salienceScore = calculateSalienceScore(context.metadata[entity.id]);
     const preferenceScore = calculatePreferenceScore(entity, context.userPreferences);
     
     return (α * semanticScore) + (β * recencyScore) + (γ * salienceScore) + (δ * preferenceScore);
   }
   ```

4. **Prioritization:**
   - Sort all entities by final score (descending)
   - Select top N entities for hydration (default: 10)
   - Apply diversity filters to avoid over-representation of single types

**Output:** `prioritizedEntities: ScoredEntity[]`
```typescript
interface ScoredEntity extends CandidateEntity {
  finalScore: number;
  scoreBreakdown: {
    semantic: number;
    recency: number;
    salience: number;
    preference: number;
  };
}
```

### **Stage 6: Full Content Hydration**
**Input:** `prioritizedEntities`, `userId`  
**Type:** PostgreSQL content queries  
**Purpose:** Fetch complete entity content for top-scored entities

**Process:**
1. **Batch Content Queries:**
   ```typescript
   const memoryUnits = await memoryRepository.findByIds(
     prioritizedEntities.filter(e => e.type === 'MemoryUnit').map(e => e.id),
     userId
   );
   
   const concepts = await conceptRepository.findByIds(
     prioritizedEntities.filter(e => e.type === 'Concept').map(e => e.id),
     userId
   );
   ```

2. **Content Assembly:**
   - Preserve scoring order in final results
   - Include scoring metadata for transparency
   - Apply final content filters (privacy, access control)

3. **Context Construction:**
   ```typescript
   const context: AugmentedMemoryContext = {
     retrievedMemoryUnits: memoryUnits,
     retrievedConcepts: concepts,
     retrievedArtifacts: artifacts,
     retrievalSummary: generateSummary(prioritizedEntities),
     scoringDetails: {
       totalCandidatesEvaluated: candidateEntities.length,
       seedEntitiesFound: seedEntitiesWithSimilarity.length,
       averageScore: calculateAverageScore(prioritizedEntities),
       scoringWeights: weights
     }
   };
   ```

**Output:** `AugmentedMemoryContext` (final result)

**Failure Handling:**
- Missing entities: Exclude from results, log for cleanup
- Partial hydration failures: Return available content with warnings
- Repository errors: Graceful degradation with error context

## **Configuration Management**

The HRT relies on several configuration files to maintain flexibility and security:

### **1. Cypher Query Templates**
**Location:** `config/cypher_templates.json`  
**Purpose:** Pre-approved, parameterized Neo4j query templates

```json
{
  "neighborhood": {
    "description": "Finds nodes within N hops of seed entities",
    "template": "UNWIND $seedEntities AS seed MATCH (startNode) WHERE startNode.id = seed.id CALL { WITH startNode MATCH p=(startNode)-[*1..$hops]-(relatedNode) WHERE relatedNode.userId = $userId RETURN DISTINCT relatedNode.id AS nodeId, labels(relatedNode)[0] AS nodeType LIMIT $limit } RETURN COLLECT(DISTINCT {id: nodeId, type: nodeType}) + $seedEntities AS allRelevantEntities",
    "allowedParams": ["seedEntities", "hops", "limit", "userId"],
    "defaultParams": { "hops": 2, "limit": 20 }
  },
  "timeline": {
    "description": "Retrieves entities with temporal relationships",
    "template": "MATCH (mu:MemoryUnit {userId: $userId}) WHERE mu.occurredAt >= $startDate AND mu.occurredAt <= $endDate RETURN COLLECT(DISTINCT {id: mu.muid, type: 'MemoryUnit'}) AS allRelevantEntities ORDER BY mu.occurredAt DESC LIMIT $limit",
    "allowedParams": ["userId", "startDate", "endDate", "limit"],
    "defaultParams": { "limit": 15 }
  },
  "episodesByConcept": {
    "description": "Finds MemoryUnits related to specific concepts",
    "template": "MATCH (c:Concept {id: $conceptId, userId: $userId})<-[:HIGHLIGHTS]-(mu:MemoryUnit) RETURN COLLECT(DISTINCT {id: mu.muid, type: 'MemoryUnit'}) AS allRelevantEntities LIMIT $limit",
    "allowedParams": ["conceptId", "userId", "limit"],
    "defaultParams": { "limit": 10 }
  },
  "conceptsByTheme": {
    "description": "Discovers thematically related concepts",
    "template": "MATCH (c1:Concept {userId: $userId})-[:RELATES_TO*1..$hops]-(c2:Concept {userId: $userId}) WHERE c1.theme = $theme RETURN COLLECT(DISTINCT {id: c2.cid, type: 'Concept'}) AS allRelevantEntities LIMIT $limit",
    "allowedParams": ["theme", "hops", "limit", "userId"],
    "defaultParams": { "hops": 2, "limit": 12 }
  }
}
```

### **2. Retrieval Scoring Weights**
**Location:** `config/retrieval_weights.json`  
**Purpose:** Configurable scoring weights for different retrieval scenarios

```json
{
  "default": {
    "alpha_semantic_similarity": 0.4,
    "beta_recency": 0.25,
    "gamma_salience": 0.25,
    "delta_user_preference": 0.1
  },
  "recent_focus": {
    "alpha_semantic_similarity": 0.3,
    "beta_recency": 0.5,
    "gamma_salience": 0.15,
    "delta_user_preference": 0.05
  },
  "high_importance": {
    "alpha_semantic_similarity": 0.3,
    "beta_recency": 0.1,
    "gamma_salience": 0.5,
    "delta_user_preference": 0.1
  },
  "personalized": {
    "alpha_semantic_similarity": 0.25,
    "beta_recency": 0.2,
    "gamma_salience": 0.25,
    "delta_user_preference": 0.3
  }
}
```

### **3. HRT Configuration Parameters**
**Location:** `config/hrt_config.json`  
**Purpose:** Operational parameters and limits

```json
{
  "processing": {
    "MAX_KEY_PHRASES": 5,
    "MAX_PHRASE_LENGTH": 100,
    "PHRASE_SIMILARITY_THRESHOLD": 0.8
  },
  "weaviate": {
    "RESULTS_PER_PHRASE": 3,
    "SIMILARITY_THRESHOLD": 0.1,
    "TIMEOUT_MS": 5000
  },
  "neo4j": {
    "MAX_RESULT_LIMIT": 100,
    "MAX_GRAPH_HOPS": 3,
    "MAX_SEED_ENTITIES": 10,
    "QUERY_TIMEOUT_MS": 10000
  },
  "scoring": {
    "TOP_N_CANDIDATES_FOR_HYDRATION": 10,
    "RECENCY_DECAY_RATE": 0.1,
    "MAX_PREFERENCE_BOOST": 2.0,
    "DIVERSITY_THRESHOLD": 0.3
  },
  "postgresql": {
    "BATCH_SIZE": 50,
    "HYDRATION_TIMEOUT_MS": 8000
  }
}
```

### **4. User Preference Schema**
**Location:** Database schema extension for `users.preferences`

```prisma
model User {
  // ... existing fields ...
  preferences Json? @default("{}")
  
  // Example preferences structure:
  // {
  //   "preferred_concept_types": {
  //     "goal": 1.5,
  //     "value": 1.2,
  //     "skill_development": 1.4
  //   },
  //   "active_themes": ["career", "health", "relationships"],
  //   "retrieval_weights_profile": "personalized",
  //   "max_results_preference": 8
  // }
}
```

## **File Structure & Implementation**

### **Package Organization**
```
packages/tools/retrieval/
├── src/
│   ├── HybridRetrievalTool.ts           # Main public interface
│   ├── index.ts                         # Package exports
│   ├── types/
│   │   ├── interfaces.ts                # TypeScript interfaces
│   │   ├── scoring.types.ts             # Scoring-related types
│   │   └── config.types.ts              # Configuration types
│   ├── internal/                        # Private micro-modules
│   │   ├── CypherBuilder.ts             # Query template processing
│   │   ├── ParamGuard.ts                # Parameter validation
│   │   ├── EntityScorer.ts              # Multi-factor scoring
│   │   ├── HydrationAdapter.ts          # PostgreSQL batch operations
│   │   └── ConfigLoader.ts              # Configuration management
│   ├── utils/
│   │   ├── similarity.utils.ts          # Weaviate score transformations
│   │   ├── temporal.utils.ts            # Recency score calculations
│   │   └── validation.utils.ts          # Input validation helpers
│   └── __tests__/
│       ├── HybridRetrievalTool.test.ts  # Integration tests
│       ├── internal/                    # Unit tests for micro-modules
│       │   ├── CypherBuilder.test.ts
│       │   ├── EntityScorer.test.ts
│       │   └── HydrationAdapter.test.ts
│       └── fixtures/                    # Test data and mocks
├── package.json
├── tsconfig.json
└── README.md
```

### **Configuration File Locations**
```
config/
├── cypher_templates.json               # Neo4j query templates
├── retrieval_weights.json              # Scoring weight configurations
├── hrt_config.json                     # Operational parameters
└── CoreIdentity.yaml                   # (Existing) Core system identity
```

### **Key Dependencies**
```json
{
  "dependencies": {
    "@2dots1line/database": "workspace:*",
    "@2dots1line/shared-types": "workspace:*",
    "neo4j-driver": "^5.0.0",
    "weaviate-ts-client": "^1.4.0",
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "@types/jest": "^29.5.0",
    "jest": "^29.5.0"
  }
}
```

## **Integration Points**

### **1. DialogueAgent Integration**
```typescript
// In DialogueAgent.ts
import { HybridRetrievalTool } from '@2dots1line/tools/retrieval';

class DialogueAgent {
  private hrt: HybridRetrievalTool;

  async processUserInput(input: UserInput): Promise<AgentResponse> {
    // ... LLM processing ...
    
    if (llmResponse.query_memory) {
      const memoryContext = await this.hrt.execute({
        keyPhrasesForRetrieval: llmResponse.key_phrases_for_retrieval,
        userId: input.userId,
        retrievalScenario: llmResponse.retrieval_scenario || 'neighborhood'
      });
      
      // Incorporate memory context into final response
      finalResponse = await this.generateContextualResponse(input, memoryContext);
    }
    
    return finalResponse;
  }
}
```

### **2. Repository Dependencies**
```typescript
// HRT constructor injection
constructor(
  private weaviateClient: WeaviateClient,
  private neo4jDriver: Driver,
  private memoryRepository: MemoryRepository,
  private conceptRepository: ConceptRepository,
  private artifactRepository: ArtifactRepository,
  private userRepository: UserRepository,
  private configLoader: ConfigLoader
) {
  this.cypherBuilder = new CypherBuilder(configLoader);
  this.entityScorer = new EntityScorer(configLoader);
  this.hydrationAdapter = new HydrationAdapter(
    memoryRepository,
    conceptRepository,
    artifactRepository
  );
}
```

### **3. Error Handling & Monitoring**
```typescript
// Comprehensive error context
interface HRTExecutionContext {
  requestId: string;
  userId: string;
  startTime: number;
  keyPhrasesCount: number;
  retrievalScenario: string;
  
  // Stage completion tracking
  stageResults: {
    keyPhraseProcessing: { success: boolean; processedCount: number };
    semanticGrounding: { success: boolean; seedEntitiesFound: number };
    graphTraversal: { success: boolean; candidatesFound: number };
    preHydration: { success: boolean; metadataFetched: number };
    scoring: { success: boolean; entitiesScored: number };
    hydration: { success: boolean; entitiesHydrated: number };
  };
  
  // Performance metrics
  timings: {
    totalDuration: number;
    weaviateLatency: number;
    neo4jLatency: number;
    postgresLatency: number;
    scoringDuration: number;
  };
  
  // Error details
  errors: Array<{
    stage: string;
    error: Error;
    impact: 'fatal' | 'degraded' | 'logged';
  }>;
}
``` 