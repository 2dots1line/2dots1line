# **V9.6 Repository Design Patterns & Standards**

**Document Version:** 9.6
**Purpose:** To provide canonical patterns, interfaces, and standards for all repository classes in the 2dots1line system, ensuring consistency across data access layers.

## **1. Repository Architecture Principles**

### **Core Principles:**
- **Single Responsibility:** Each repository manages one primary entity type
- **Interface Segregation:** Repositories implement only methods they actually need
- **Dependency Injection:** All repositories receive database clients as constructor parameters
- **Error Handling:** Repositories throw specific, typed errors for different failure modes
- **Type Safety:** All repository methods use TypeScript interfaces and return typed results

### **Standardized Patterns:**
- **Base Repository:** Common CRUD operations following consistent patterns
- **Specialized Repositories:** Entity-specific methods for complex queries
- **Transaction Support:** Standard patterns for multi-operation atomicity
- **Pagination:** Consistent pagination interfaces across all repositories

---

## **2. Base Repository Interface**

### **Standard CRUD Operations:**

```typescript
// packages/database/src/repositories/base/BaseRepository.ts
export interface BaseRepository<T, CreateInput, UpdateInput> {
  // Standard CRUD operations
  findById(id: string): Promise<T | null>;
  findMany(filters: Partial<T>, pagination?: PaginationOptions): Promise<PaginatedResult<T>>;
  create(data: CreateInput): Promise<T>;
  update(id: string, data: UpdateInput): Promise<T>;
  delete(id: string): Promise<boolean>;
  
  // Batch operations
  createMany(data: CreateInput[]): Promise<T[]>;
  updateMany(filters: Partial<T>, data: UpdateInput): Promise<number>; // Returns count updated
  deleteMany(filters: Partial<T>): Promise<number>; // Returns count deleted
  
  // Utility operations
  exists(id: string): Promise<boolean>;
  count(filters: Partial<T>): Promise<number>;
}

// Supporting types
export interface PaginationOptions {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface PaginatedResult<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
```

---

## **3. Concrete Repository Examples**

### **3.1 UserRepository**

```typescript
// packages/database/src/repositories/UserRepository.ts
import { PrismaClient } from '@prisma/client';
import { BaseRepository, PaginationOptions, PaginatedResult } from './base/BaseRepository';
import { User, UserCreateInput, UserUpdateInput } from '../types';

export class UserRepository implements BaseRepository<User, UserCreateInput, UserUpdateInput> {
  constructor(private prisma: PrismaClient) {}

  async findById(id: string): Promise<User | null> {
    try {
      return await this.prisma.user.findUnique({
        where: { id }
      });
    } catch (error) {
      throw new RepositoryError(`Failed to find user by ID: ${id}`, error);
    }
  }

  async findByEmail(email: string): Promise<User | null> {
    try {
      return await this.prisma.user.findUnique({
        where: { email }
      });
    } catch (error) {
      throw new RepositoryError(`Failed to find user by email: ${email}`, error);
    }
  }

  async updateMemoryProfile(userId: string, memoryProfile: UserMemoryProfile): Promise<User> {
    try {
      return await this.prisma.user.update({
        where: { id: userId },
        data: { 
          memory_profile: memoryProfile as any, // JSONB field
          updated_at: new Date()
        }
      });
    } catch (error) {
      throw new RepositoryError(`Failed to update memory profile for user: ${userId}`, error);
    }
  }

  async updateKnowledgeGraphSchema(userId: string, schema: KnowledgeGraphSchema): Promise<User> {
    try {
      return await this.prisma.user.update({
        where: { id: userId },
        data: { 
          knowledge_graph_schema: schema as any, // JSONB field
          updated_at: new Date()
        }
      });
    } catch (error) {
      throw new RepositoryError(`Failed to update KGS for user: ${userId}`, error);
    }
  }

  // Standard CRUD implementation
  async findMany(
    filters: Partial<User>, 
    pagination?: PaginationOptions
  ): Promise<PaginatedResult<User>> {
    const page = pagination?.page || 1;
    const limit = pagination?.limit || 20;
    const skip = (page - 1) * limit;

    try {
      const [data, total] = await Promise.all([
        this.prisma.user.findMany({
          where: filters,
          skip,
          take: limit,
          orderBy: pagination?.sortBy ? {
            [pagination.sortBy]: pagination.sortOrder || 'asc'
          } : undefined
        }),
        this.prisma.user.count({ where: filters })
      ]);

      return {
        data,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasNext: page * limit < total,
          hasPrev: page > 1
        }
      };
    } catch (error) {
      throw new RepositoryError('Failed to find users', error);
    }
  }

  async create(data: UserCreateInput): Promise<User> {
    try {
      return await this.prisma.user.create({ data });
    } catch (error) {
      if (error.code === 'P2002') { // Prisma unique constraint violation
        throw new DuplicateEntryError('User with this email already exists');
      }
      throw new RepositoryError('Failed to create user', error);
    }
  }

  async update(id: string, data: UserUpdateInput): Promise<User> {
    try {
      return await this.prisma.user.update({
        where: { id },
        data: { ...data, updated_at: new Date() }
      });
    } catch (error) {
      if (error.code === 'P2025') { // Prisma record not found
        throw new NotFoundError(`User not found: ${id}`);
      }
      throw new RepositoryError(`Failed to update user: ${id}`, error);
    }
  }

  async delete(id: string): Promise<boolean> {
    try {
      await this.prisma.user.delete({ where: { id } });
      return true;
    } catch (error) {
      if (error.code === 'P2025') { // Prisma record not found
        return false;
      }
      throw new RepositoryError(`Failed to delete user: ${id}`, error);
    }
  }

  // Additional implementations...
  async createMany(data: UserCreateInput[]): Promise<User[]> { /* ... */ }
  async updateMany(filters: Partial<User>, data: UserUpdateInput): Promise<number> { /* ... */ }
  async deleteMany(filters: Partial<User>): Promise<number> { /* ... */ }
  async exists(id: string): Promise<boolean> { /* ... */ }
  async count(filters: Partial<User>): Promise<number> { /* ... */ }
}
```

### **3.2 MemoryUnitRepository**

```typescript
// packages/database/src/repositories/MemoryUnitRepository.ts
export class MemoryUnitRepository implements BaseRepository<MemoryUnit, MemoryUnitCreateInput, MemoryUnitUpdateInput> {
  constructor(private prisma: PrismaClient) {}

  async findByUserId(
    userId: string, 
    pagination?: PaginationOptions
  ): Promise<PaginatedResult<MemoryUnit>> {
    return this.findMany({ userId }, pagination);
  }

  async findBySourceType(
    userId: string, 
    sourceType: string,
    pagination?: PaginationOptions
  ): Promise<PaginatedResult<MemoryUnit>> {
    return this.findMany({ userId, source_type: sourceType }, pagination);
  }

  async findByDateRange(
    userId: string,
    startDate: Date,
    endDate: Date,
    pagination?: PaginationOptions
  ): Promise<PaginatedResult<MemoryUnit>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 20;
      const skip = (page - 1) * limit;

      const [data, total] = await Promise.all([
        this.prisma.memoryUnit.findMany({
          where: {
            userId,
            creation_ts: {
              gte: startDate,
              lte: endDate
            }
          },
          skip,
          take: limit,
          orderBy: { creation_ts: 'desc' }
        }),
        this.prisma.memoryUnit.count({
          where: {
            userId,
            creation_ts: {
              gte: startDate,
              lte: endDate
            }
          }
        })
      ]);

      return {
        data,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasNext: page * limit < total,
          hasPrev: page > 1
        }
      };
    } catch (error) {
      throw new RepositoryError('Failed to find memory units by date range', error);
    }
  }

  async findHighImportance(
    userId: string,
    minScore: number = 7.0,
    pagination?: PaginationOptions
  ): Promise<PaginatedResult<MemoryUnit>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 20;
      const skip = (page - 1) * limit;

      const [data, total] = await Promise.all([
        this.prisma.memoryUnit.findMany({
          where: {
            userId,
            importance_score: {
              gte: minScore
            }
          },
          skip,
          take: limit,
          orderBy: { importance_score: 'desc' }
        }),
        this.prisma.memoryUnit.count({
          where: {
            userId,
            importance_score: {
              gte: minScore
            }
          }
        })
      ]);

      return {
        data,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasNext: page * limit < total,
          hasPrev: page > 1
        }
      };
    } catch (error) {
      throw new RepositoryError('Failed to find high importance memory units', error);
    }
  }

  // Standard CRUD implementations...
  async findById(id: string): Promise<MemoryUnit | null> { /* ... */ }
  async findMany(filters: Partial<MemoryUnit>, pagination?: PaginationOptions): Promise<PaginatedResult<MemoryUnit>> { /* ... */ }
  async create(data: MemoryUnitCreateInput): Promise<MemoryUnit> { /* ... */ }
  async update(id: string, data: MemoryUnitUpdateInput): Promise<MemoryUnit> { /* ... */ }
  async delete(id: string): Promise<boolean> { /* ... */ }
  // Additional standard methods...
}
```

---

## **4. Error Handling Standards**

### **Repository Error Types:**

```typescript
// packages/database/src/repositories/errors/RepositoryErrors.ts
export class RepositoryError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'RepositoryError';
  }
}

export class NotFoundError extends RepositoryError {
  constructor(message: string) {
    super(message);
    this.name = 'NotFoundError';
  }
}

export class DuplicateEntryError extends RepositoryError {
  constructor(message: string) {
    super(message);
    this.name = 'DuplicateEntryError';
  }
}

export class ValidationError extends RepositoryError {
  constructor(message: string, public details?: Record<string, string>) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class TransactionError extends RepositoryError {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'TransactionError';
  }
}
```

---

## **5. Transaction Support Patterns**

### **Standard Transaction Interface:**

```typescript
// packages/database/src/repositories/base/TransactionRepository.ts
export interface TransactionRepository {
  withTransaction<T>(operation: (tx: PrismaTransaction) => Promise<T>): Promise<T>;
}

export type PrismaTransaction = Parameters<Parameters<PrismaClient['$transaction']>[0]>[0];

// Example implementation
export class BaseTransactionRepository implements TransactionRepository {
  constructor(private prisma: PrismaClient) {}

  async withTransaction<T>(
    operation: (tx: PrismaTransaction) => Promise<T>
  ): Promise<T> {
    try {
      return await this.prisma.$transaction(operation);
    } catch (error) {
      throw new TransactionError('Transaction failed', error);
    }
  }
}

// Usage example
export class UserMemoryTransactionService {
  constructor(
    private userRepo: UserRepository,
    private memoryRepo: MemoryUnitRepository,
    private conceptRepo: ConceptRepository,
    private transactionRepo: BaseTransactionRepository
  ) {}

  async createMemoryWithConcepts(
    userId: string,
    memoryData: MemoryUnitCreateInput,
    conceptsData: ConceptCreateInput[]
  ): Promise<{ memory: MemoryUnit; concepts: Concept[] }> {
    return this.transactionRepo.withTransaction(async (tx) => {
      // Create memory unit
      const memory = await tx.memoryUnit.create({
        data: memoryData
      });

      // Create associated concepts
      const concepts = await Promise.all(
        conceptsData.map(conceptData =>
          tx.concept.create({
            data: { ...conceptData, userId }
          })
        )
      );

      // Create relationships if needed
      // ... additional transaction operations

      return { memory, concepts };
    });
  }
}
```

---

## **6. Repository Factory Pattern**

### **Centralized Repository Management:**

```typescript
// packages/database/src/repositories/RepositoryFactory.ts
export class RepositoryFactory {
  private static instance: RepositoryFactory;
  private repositories: Map<string, any> = new Map();

  constructor(private prisma: PrismaClient) {}

  static getInstance(prisma: PrismaClient): RepositoryFactory {
    if (!RepositoryFactory.instance) {
      RepositoryFactory.instance = new RepositoryFactory(prisma);
    }
    return RepositoryFactory.instance;
  }

  getUserRepository(): UserRepository {
    if (!this.repositories.has('UserRepository')) {
      this.repositories.set('UserRepository', new UserRepository(this.prisma));
    }
    return this.repositories.get('UserRepository');
  }

  getMemoryUnitRepository(): MemoryUnitRepository {
    if (!this.repositories.has('MemoryUnitRepository')) {
      this.repositories.set('MemoryUnitRepository', new MemoryUnitRepository(this.prisma));
    }
    return this.repositories.get('MemoryUnitRepository');
  }

  getConceptRepository(): ConceptRepository {
    if (!this.repositories.has('ConceptRepository')) {
      this.repositories.set('ConceptRepository', new ConceptRepository(this.prisma));
    }
    return this.repositories.get('ConceptRepository');
  }

  // Add other repository getters...

  getTransactionRepository(): BaseTransactionRepository {
    if (!this.repositories.has('BaseTransactionRepository')) {
      this.repositories.set('BaseTransactionRepository', new BaseTransactionRepository(this.prisma));
    }
    return this.repositories.get('BaseTransactionRepository');
  }
}
```

---

## **7. Testing Patterns**

### **Repository Test Standards:**

```typescript
// packages/database/src/repositories/__tests__/UserRepository.test.ts
describe('UserRepository', () => {
  let repository: UserRepository;
  let prisma: PrismaClient;

  beforeEach(async () => {
    prisma = new PrismaClient();
    repository = new UserRepository(prisma);
    // Setup test database state
  });

  afterEach(async () => {
    // Cleanup test data
    await prisma.$disconnect();
  });

  describe('findById', () => {
    it('should return user when found', async () => {
      // Arrange
      const testUser = await prisma.user.create({
        data: { email: 'test@example.com', /* ... */ }
      });

      // Act
      const result = await repository.findById(testUser.id);

      // Assert
      expect(result).toBeDefined();
      expect(result?.id).toBe(testUser.id);
    });

    it('should return null when not found', async () => {
      // Act
      const result = await repository.findById('non-existent-id');

      // Assert
      expect(result).toBeNull();
    });

    it('should throw RepositoryError on database error', async () => {
      // Arrange - simulate database error
      jest.spyOn(prisma.user, 'findUnique').mockRejectedValueOnce(new Error('DB Error'));

      // Act & Assert
      await expect(repository.findById('test-id')).rejects.toThrow(RepositoryError);
    });
  });

  // Additional test cases for all methods...
});
```

This comprehensive repository design pattern ensures consistency, type safety, and maintainability across all data access layers in the V9.6 system. 