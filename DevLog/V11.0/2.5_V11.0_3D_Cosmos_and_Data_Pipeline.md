read ### **`2.5_V11.0_3D_Cosmos_and_Data_Pipeline.md`**

---

# **V11.0 Canonical Guide: 3D Knowledge Cosmos & Data Pipeline**

**Document Version:** 11.0 (Headless Service Architecture)
**Purpose:** To provide a definitive, deep-dive specification for the 3D Knowledge Cosmos user interface, the asynchronous data pipeline that powers it, and the `GraphProjectionWorker` responsible for generating its data within the V11.0 headless architecture.

## **1. Core Philosophy & User Experience**

The 3D Knowledge Cosmos is the second primary interface for exploring the user's knowledge graph, complementing the 2D Card Canvas. Its purpose is to provide a **holistic, spatial, and structural view** of the user's knowledge, allowing them to intuitively grasp the shape, density, and relationships within their "inner universe."

**User Experience Principles:**
*   **Structural Insight:** Unlike the serendipitous 2D canvas, the 3D Cosmos is about understanding structure. Users can see clusters of related thoughts, identify central "pillar" concepts, and notice isolated ideas.
*   **Semantic Proximity:** The placement of nodes is not random; it is a 3D projection of their high-dimensional vector embeddings. **Nodes that are semantically similar will appear closer together in the 3D space.**
*   **Interactive Exploration:** The user is an active explorer, able to navigate the space (pan, rotate, zoom), interrogate the graph with AI assistance, and dive into specific nodes to view their detailed `Card` representation.
*   **AI-Guided Discovery:** Integration with the `DialogueAgent` allows users to ask questions and receive visual responses through node highlighting and camera movement.

## **2. V11.0 Architectural Overview: The Headless Projection Pipeline**

To ensure a high-performance, real-time 3D experience, the complex calculations required to generate the cosmos view are performed **asynchronously** by a dedicated worker. The frontend loads pre-computed data through the single API Gateway, eliminating direct database access.

```
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ       Neo4j       ‚îÇ        ‚îÇ     Weaviate     ‚îÇ
            ‚îÇ  (Graph Structure)  ‚îÇ        ‚îÇ(Vector Embeddings)‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ 1. Fetch Node IDs & Edges     ‚îÇ 2. Fetch Vectors for Node IDs
                       ‚îÇ                             ‚îÇ
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                       ‚ñº ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ `GraphProjectionWorker`   ‚îÇ
                         ‚îÇ (Asynchronous Background Job) ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                       ‚îÇ 3. Dimensionality Reduction
                                       ‚îÇ    (V11.0: Python microservice integration)
                                       ‚îÇ
                                       ‚îÇ 4. Store Projection Data
                                       ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ   PostgreSQL:             ‚îÇ
                         ‚îÇ `user_graph_projections` table ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                       ‚îÇ 5. API Gateway serves data (HEADLESS)
                                       ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ  API Gateway:             ‚îÇ
                         ‚îÇ GET /api/v1/graph-projection ‚îÇ
                         ‚îÇ (Headless service calls)  ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                       ‚îÇ 6. Frontend fetches projection
                                       ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ     3D Knowledge Cosmos   ‚îÇ
                         ‚îÇ    (Frontend Renders Scene) ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## **3. The `GraphProjectionWorker`**

This is the worker responsible for generating the data for the 3D Cosmos within the V11.0 headless architecture.

**Location:** `workers/graph-projection-worker/`

**Trigger:** It is subscribed to the `card-and-graph-queue`. It listens for events like `new_entities_created`, `cycle_artifacts_created`, or `graph_ontology_updated`. It can also be run on a periodic schedule (e.g., hourly) to ensure the projection stays reasonably up-to-date.

### **Detailed Workflow: Processing a Projection Job**

1.  **Fetch Full Graph Structure:** The worker queries Neo4j to get a complete list of all active `nodeId`s and their `type`s, along with an edge list (`{ source_id, target_id }`) for the given `userId`.
2.  **Fetch All Vectors:** The worker performs a batch fetch from Weaviate to retrieve the high-dimensional vector for every `nodeId` gathered in the previous step.
3.  **Perform Dimensionality Reduction:**
    *   **V11.0 Integration:** The worker integrates with the Python `dimension-reducer` microservice located at `py-services/dimension-reducer/`, which provides specialized libraries like `UMAP`, `t-SNE`, or `PCA`.
    *   **Action:** The worker sends the batch of vectors to this headless microservice.
    *   **Output:** The service returns a map of `nodeId` to its new `[x, y, z]` coordinates.
4.  **Assemble Projection JSON:** The worker constructs a single, comprehensive JSON object containing all the data the frontend needs to render the scene. (See Section 5 for the structure).
5.  **Persist Projection Data:** The worker saves the generated JSON object to the `user_graph_projections` table in PostgreSQL.
    *   **Storage Table:** `user_graph_projections` (`user_id`, `projection_version_id`, `projection_data` JSONB, `created_at`). This allows for versioning and easy retrieval.

## **4. V11.0 API Gateway Integration**

### **Headless Service Pattern**

In V11.0, the 3D Cosmos data is served through the single API Gateway using headless service calls:

*   **Endpoint:** `GET /api/v1/graph-projection`
*   **Controller:** `apps/api-gateway/src/controllers/graph.controller.ts`
*   **Headless Logic:** The controller directly imports and calls headless service libraries:
    ```typescript
    // V11.0 Pattern: Direct headless service calls
    import { GraphProjectionService } from '@2dots1line/graph-projection-service';
    
    export class GraphController {
      constructor(
        private graphProjectionService: GraphProjectionService,
        private databaseService: DatabaseService
      ) {}
      
      async getProjection(req: Request, res: Response) {
        const userId = req.user.userId;
        
        // Direct headless service call - no HTTP overhead
        const projection = await this.graphProjectionService.getLatestProjection(userId);
        
        res.json(projection);
      }
    }
    ```

### **Service Integration Benefits**

*   **No HTTP Overhead:** Direct method calls between controller and service
*   **Type Safety:** Full TypeScript validation across service boundaries
*   **Simplified Error Handling:** Natural exception propagation
*   **Enhanced Performance:** Shared memory space for large projection data

## **5. The Graph Projection Data Structure**

This is the structure of the JSON object that the `GraphProjectionWorker` creates and the API Gateway serves.

```json
// Example content of `user_graph_projections.projection_data`
{
  "version": "proj-uuid-v1",
  "createdAt": "2025-06-15T18:00:00Z",
  "nodeCount": 152,
  "edgeCount": 340,
  "metadata": {
    "dimension_reduction_algorithm": "UMAP",
    "vector_dimensionality": "1536->3",
    "semantic_similarity_threshold": 0.15
  },
  "nodes": [
    {
      "id": "muid-abc", // Corresponds to a sourceEntityId
      "type": "MemoryUnit",
      "label": "Brainstorming Session for Project Phoenix",
      "pos": [10.34, -5.12, 42.89], // The pre-computed [x,y,z] coordinates
      "metadata": {
        "importance": 8.5,
        "community_id": "community-work",
        "creation_date": "2025-06-10T14:30:00Z"
      }
    },
    {
      "id": "concept-def",
      "type": "Concept",
      "label": "Project Phoenix",
      "pos": [11.01, -4.99, 43.15],
      "metadata": {
        "salience": 0.9,
        "concept_type": "project",
        "community_id": "community-work"
      }
    }
    // ... all other nodes
  ],
  "edges": [
    { 
      "source": "muid-abc", 
      "target": "concept-def",
      "relationship_type": "HIGHLIGHTS",
      "strength": 0.8
    },
    { 
      "source": "concept-def", 
      "target": "concept-ghi",
      "relationship_type": "RELATED_TO",
      "strength": 0.6
    }
    // ... all other edges
  ],
  "communities": [
    {
      "id": "community-work",
      "label": "Work & Career Growth",
      "member_node_ids": ["muid-abc", "concept-def", "..."],
      "centroid": [10.5, -5.0, 43.0],
      "radius": 2.3
    }
  ]
}
```

## **6. Frontend Responsibilities (3D Knowledge Cosmos)**

The frontend (`apps/web-app`) is responsible for:

1.  **Fetching Data:** On loading the 3D Cosmos scene, it calls `GET /api/v1/graph-projection` to get the data object through the API Gateway.
2.  **Rendering:** It uses React Three Fiber (R3F) to:
    *   Iterate through the `nodes` array and place a mesh/sprite at each `pos` coordinate.
    *   Iterate through the `edges` array and draw lines/tubes connecting the nodes.
    *   Use the `communities` data to visually group or color-code nodes.
3.  **Navigation:** Implementing orbit, pan, and zoom controls for the camera.
4.  **Interaction:**
    *   Handling hover events to show node labels.
    *   Handling click events on a node to fetch its full `CardDTO` from `GET /api/v1/cards/by-source/{entityId}` and display it in a modal.
    *   Providing a dedicated chat input for general graph interrogation.
5.  **Responding to UI Actions:** Listening for `ui_actions` (like `highlight_nodes`) returned from `DialogueAgent` responses and applying the corresponding visual effects (e.g., using an emissive material) to the specified nodes in the scene.

## **7. Integration with the Headless `DialogueAgent`**

The `DialogueAgent` workflow for handling queries from the 3D Cosmos is detailed in `2.1_V11.0_DialogueService_and_Dependencies.md`. Key V11.0 improvements:

*   **Direct Service Calls:** The API Gateway directly calls the headless `DialogueService`
*   **Shared Memory:** UI actions and context are shared efficiently within the API Gateway process
*   **Type Safety:** Full TypeScript validation for UI action payloads
*   **Enhanced Performance:** No HTTP overhead for dialogue processing

The key is that the DialogueAgent can now return a `ui_actions` array in its response, which gives the frontend a structured command to execute visually within the 3D scene, creating a tight feedback loop between conversation and visualization.

## **8. Python Microservice Integration**

### **Dimension Reducer Service**

The V11.0 architecture includes a dedicated Python microservice for dimensionality reduction:

*   **Location:** `py-services/dimension-reducer/`
*   **Purpose:** Provides UMAP, t-SNE, and PCA algorithms for vector projection
*   **Integration:** Called by `GraphProjectionWorker` for complex mathematical operations
*   **Benefits:** Specialized Python libraries while maintaining overall TypeScript architecture

### **Docker Integration**

```yaml
# docker-compose.yml (V11.0)
services:
  dimension-reducer:
    build: ./py-services/dimension-reducer
    ports:
      - "8001:8000"
    environment:
      - PYTHONPATH=/app
```

## **9. V11.0 Performance Benefits**

The headless architecture provides significant performance improvements for 3D visualization:

*   **50-80% Reduced Latency:** Direct service calls in API Gateway eliminate HTTP overhead
*   **Optimized Data Transfer:** Single projection fetch instead of multiple API calls
*   **Enhanced Caching:** Projection data cached within API Gateway process
*   **Improved Error Handling:** Direct exception propagation for debugging

## **10. Implementation Status Assessment**

**‚úÖ PARTIAL IMPLEMENTATION:** Based on the current monorepo structure:
- `GraphProjectionWorker` exists and appears to follow correct patterns
- Python `dimension-reducer` service is properly containerized
- Database schema includes `user_graph_projections` table
- API Gateway structure supports headless service integration

**üîç AREAS FOR VERIFICATION:**
- Ensure `GraphProjectionService` is implemented as headless library
- Verify API Gateway controller uses headless service pattern
- Confirm Python microservice integration is working
- Test end-to-end projection pipeline

This V11.0 guide defines a robust, scalable, and performant architecture for the 3D Knowledge Cosmos, ensuring it integrates seamlessly with the headless service model while providing users with an immersive, AI-guided exploration experience of their personal knowledge universe. 