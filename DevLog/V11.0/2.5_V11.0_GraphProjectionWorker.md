# **V11.0 Canonical Guide: GraphProjectionWorker**

**Document Version:** 11.0 (Headless Service Architecture)
**Purpose:** To provide a definitive specification for the `GraphProjectionWorker` responsible for generating 3D knowledge graph projections within the V11.0 headless architecture, including the intelligent polling mechanism for embedding coordination.

## **1. Core Architecture & Responsibilities**

The `GraphProjectionWorker` is a critical component in the V11.0 headless architecture that generates 3D projections of user knowledge graphs for the Cosmos interface. It operates asynchronously and implements intelligent coordination with the `EmbeddingWorker` to ensure data consistency.

**Location:** `workers/graph-projection-worker/`

**Primary Responsibilities:**
- Process graph projection events from `graph-queue`
- Coordinate with `EmbeddingWorker` to ensure embeddings are ready
- Generate 3D coordinates via dimensionality reduction
- Store projection data in PostgreSQL
- Implement timeout protection to prevent indefinite hanging

## **2. Event Processing & Queue Integration**

### **Subscribed Events**
The worker listens to the `graph-queue` for the following event types:

1. **`new_entities_created`** - New knowledge entities ready for projection
2. **`cycle_artifacts_created`** - Strategic artifacts from insight cycles
3. **`graph_ontology_updated`** - Structural changes requiring projection update

### **Event Publishing Sources**
- **`IngestionAnalyst`** - Publishes `new_entities_created` events
- **`InsightEngine`** - Publishes `cycle_artifacts_created` and `graph_ontology_updated` events

## **3. V11.0 Intelligent Polling Mechanism**

### **Problem Solved**
The worker addresses race conditions where it might attempt to process entities before the `EmbeddingWorker` has finished generating their embeddings, leading to fallback vectors or processing failures.

### **Implementation Details**

#### **Retry Tracking**
```typescript
private retryCounts: Map<string, number> = new Map(); // Track retry attempts per job
```

#### **Polling Logic**
```typescript
// For new_entities_created events, check if embeddings are ready
if (data.type === 'new_entities_created') {
  const missingEmbeddings = await this.checkMissingEmbeddings(data.entities);
  if (missingEmbeddings.length > 0) {
    // Check retry limit (max 15 retries = 30 seconds total wait)
    const jobKey = `${data.userId}_${data.entities.map(e => e.id).join('_')}`;
    const retryCount = this.retryCounts.get(jobKey) || 0;
    const maxRetries = 15; // 30 seconds total (15 * 2 seconds)
    
    if (retryCount >= maxRetries) {
      console.warn(`⚠️ Max retries (${maxRetries}) reached for embeddings: ${missingEmbeddings.join(', ')}`);
      console.warn(`⚠️ Proceeding with projection using available embeddings only`);
      this.retryCounts.delete(jobKey); // Clean up
    } else {
      console.log(`Waiting for embeddings: ${missingEmbeddings.join(', ')} (retry ${retryCount + 1}/${maxRetries})`);
      this.retryCounts.set(jobKey, retryCount + 1);
      // Wait 2 seconds and retry
      await new Promise(resolve => setTimeout(resolve, 2000));
      return this.processJob(job); // Retry
    }
  }
}
```

#### **Embedding Check Method**
```typescript
private async checkMissingEmbeddings(entities: Array<{id: string, type: string}>): Promise<string[]> {
  const missing: string[] = [];
  
  for (const entity of entities) {
    try {
      const exists = await this.databaseService.weaviate
        .graphql
        .get()
        .withClassName('UserKnowledgeItem')
        .withFields('externalId')
        .withWhere({
          operator: 'And',
          operands: [
            { path: ['sourceEntityType'], operator: 'Equal', valueString: entity.type },
            { path: ['sourceEntityId'], operator: 'Equal', valueString: entity.id }
          ]
        })
        .withLimit(1)
        .do();
        
      if (!exists.data?.Get?.UserKnowledgeItem?.[0]) {
        missing.push(entity.id);
      }
    } catch (error) {
      console.warn(`Error checking embedding for ${entity.type} ${entity.id}:`, error);
      missing.push(entity.id);
    }
  }
  
  return missing;
}
```

### **Timeout Protection Benefits**
- **Prevents Infinite Hanging:** Maximum 30-second wait time
- **Graceful Degradation:** Proceeds with available embeddings if timeout reached
- **Memory Management:** Automatic cleanup of retry tracking data
- **Error Resilience:** Handles Weaviate connection issues gracefully

## **4. Core Processing Workflow**

### **Step 1: Event Validation**
```typescript
const shouldProcess = data.type === 'graph_ontology_updated' || 
                     (data.type === 'new_entities_created' && data.entities.length > 0);
```

### **Step 2: Embedding Coordination (for new entities)**
- Check if embeddings exist in Weaviate
- Implement polling with timeout protection
- Proceed only when embeddings are ready or timeout reached

### **Step 3: Graph Data Fetching**
```typescript
const graphData = await this.fetchGraphStructureFromNeo4j(userId);
```

### **Step 4: Vector Retrieval**
```typescript
const vectors = await this.fetchEmbeddingsFromWeaviate(graphData.nodes);
```

### **Step 5: Dimensionality Reduction**
```typescript
const coordinates3D = await this.callDimensionReducer(vectors);
```

### **Step 6: Projection Assembly**
```typescript
const projection = await this.generateProjection(userId);
```

### **Step 7: Data Persistence**
```typescript
await this.storeProjection(projection);
```

## **5. Error Handling & Resilience**

### **Embedding Failures**
- **Individual Entity Failures:** Logged as warnings, entity skipped
- **Batch Failures:** Timeout protection prevents infinite retries
- **Weaviate Connection Issues:** Graceful fallback with error logging

### **Dimensionality Reduction Failures**
- **Python Service Unavailable:** Fallback to default coordinates
- **Invalid Vector Data:** Skip problematic vectors, continue with valid ones
- **Service Timeout:** Implement exponential backoff retry

### **Database Failures**
- **Neo4j Connection Issues:** Retry with exponential backoff
- **PostgreSQL Storage Failures:** Log error, maintain projection in memory
- **Transaction Failures:** Rollback and retry mechanism

## **6. Performance Optimizations**

### **Batch Processing**
- **Vector Retrieval:** Batch fetch from Weaviate for efficiency
- **Dimensionality Reduction:** Single API call to Python service
- **Database Operations:** Optimized queries with proper indexing

### **Memory Management**
- **Retry Tracking Cleanup:** Automatic cleanup of old retry data
- **Large Graph Handling:** Streaming processing for graphs > 1000 nodes
- **Resource Monitoring:** Memory usage tracking and alerts

### **Caching Strategy**
- **Projection Caching:** Cache recent projections to avoid regeneration
- **Vector Caching:** Cache frequently accessed embeddings
- **Coordinate Caching:** Cache 3D coordinates for stable graphs

## **7. Monitoring & Observability**

### **Key Metrics**
- **Processing Time:** Average time per projection generation
- **Retry Frequency:** Number of embedding checks per job
- **Timeout Rate:** Percentage of jobs hitting retry limits
- **Error Rate:** Failed projections vs successful ones

### **Logging Strategy**
- **Structured Logging:** JSON format for easy parsing
- **Performance Tracking:** Detailed timing for each processing step
- **Error Context:** Rich error information for debugging
- **User Impact Tracking:** Correlation with user experience metrics

## **8. Integration Points**

### **Database Services**
- **Neo4jService:** Graph structure retrieval
- **WeaviateService:** Vector embedding access
- **GraphProjectionRepository:** Projection data persistence

### **External Services**
- **Python dimension-reducer:** Dimensionality reduction microservice
- **Redis/BullMQ:** Event queue management

### **API Gateway**
- **Graph Projection Endpoint:** Serves projection data to frontend
- **Health Checks:** Worker status monitoring

## **9. Configuration & Environment**

### **Environment Variables**
```bash
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
NEO4J_URI=bolt://localhost:7687
NEO4J_USER=neo4j
NEO4J_PASSWORD=password
WEAVIATE_URL=http://localhost:8080
DIMENSION_REDUCER_URL=http://localhost:8001
```

### **Worker Configuration**
```typescript
interface GraphProjectionWorkerConfig {
  maxRetries: number; // Default: 15
  retryDelayMs: number; // Default: 2000
  maxProcessingTimeMs: number; // Default: 300000 (5 minutes)
  batchSize: number; // Default: 100
}
```

## **10. Testing Strategy**

### **Unit Tests**
- **Polling Logic:** Test retry mechanism and timeout behavior
- **Embedding Checks:** Test Weaviate query logic
- **Error Handling:** Test various failure scenarios

### **Integration Tests**
- **End-to-End Pipeline:** Test complete projection generation
- **Queue Integration:** Test event processing from all sources
- **Service Dependencies:** Test Neo4j, Weaviate, and Python service integration

### **Performance Tests**
- **Large Graph Handling:** Test with 1000+ node graphs
- **Concurrent Processing:** Test multiple simultaneous jobs
- **Timeout Scenarios:** Test embedding coordination under load

This specification ensures the `GraphProjectionWorker` operates reliably within the V11.0 headless architecture while providing robust coordination with the `EmbeddingWorker` and graceful handling of edge cases.
