### **`3.1_V11.0_Database_Schema_Unified.md`**

---

# **V11.0 Current Implementation Database Schema**

**Document Version:** 11.0 (Current State Documentation)
**Purpose:** To provide an accurate documentation of the **actual current implementation** of all persistence layers: PostgreSQL, Neo4j, and Weaviate, as they exist right now in the codebase.

**CRITICAL:** This document reflects the **current state** of implementation, not an idealized future state.

---

## **Part 1: PostgreSQL Current Schema (Actual Prisma Implementation)**

**Location:** `packages/database/prisma/schema.prisma`

This documents the **actual implemented schema** as it exists in the codebase:

```prisma
// Current Actual Schema - packages/database/prisma/schema.prisma
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================================================================
// CURRENT IMPLEMENTATION: All models use lowercase_plural naming
// ========================================================================

model cards {
  card_id            String          @id
  user_id            String
  card_type          String
  source_entity_id   String
  source_entity_type String
  status             String          @default("active_canvas")
  is_favorited       Boolean         @default(false)
  display_data       Json?
  is_synced          Boolean         @default(true)
  created_at         DateTime        @default(now())
  updated_at         DateTime
  users              users           @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  conversations      conversations[]

  @@index([user_id, status])
}

model communities {
  community_id     String     @id
  user_id          String
  name             String
  description      String?
  created_at       DateTime   @default(now())
  last_analyzed_ts DateTime?
  users            users      @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  concepts         concepts[]
}

model concepts {
  concept_id             String              @id
  user_id                String
  name                   String
  type                   String
  description            String?
  community_id           String?
  created_at             DateTime            @default(now())
  last_updated_ts        DateTime
  merged_into_concept_id String?
  salience               Float?
  status                 String              @default("active")
  communities            communities?        @relation(fields: [community_id], references: [community_id])
  concepts               concepts?           @relation("conceptsToconcepts", fields: [merged_into_concept_id], references: [concept_id], onDelete: NoAction, onUpdate: NoAction)
  other_concepts         concepts[]          @relation("conceptsToconcepts")
  users                  users               @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  derived_artifacts      derived_artifacts[]

  @@unique([user_id, name, type])
}

model conversation_messages {
  conversation_id   String
  role              String
  media_ids         String[]      @default([])
  content           String
  id                String        @id
  llm_call_metadata Json?
  timestamp         DateTime      @default(now())
  conversations     conversations @relation(fields: [conversation_id], references: [id], onDelete: Cascade)

  @@index([conversation_id, timestamp])
}

model conversations {
  user_id               String
  title                 String?
  start_time            DateTime                @default(now())
  ended_at              DateTime?
  context_summary       String?
  metadata              Json?
  id                    String                  @id
  importance_score      Float?
  source_card_id        String?
  status                String                  @default("active")
  conversation_messages conversation_messages[]
  cards                 cards?                  @relation(fields: [source_card_id], references: [card_id])
  users                 users                   @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  memory_units          memory_units[]

  @@index([user_id, status])
}

model derived_artifacts {
  artifact_id           String        @id
  user_id               String
  artifact_type         String
  title                 String
  source_memory_unit_id String?
  created_at            DateTime      @default(now())
  content_data          Json?
  content_narrative     String?
  source_concept_id     String?
  concepts              concepts?     @relation(fields: [source_concept_id], references: [concept_id])
  memory_units          memory_units? @relation(fields: [source_memory_unit_id], references: [muid])
  users                 users         @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
}

model growth_events {
  event_id    String   @id
  user_id     String
  entity_id   String
  entity_type String
  dim_key     String
  delta       Float
  source      String
  created_at  DateTime @default(now())
  details     Json?
  users       users    @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
}

model interaction_logs {
  interaction_id     String   @id
  user_id            String
  timestamp          DateTime @default(now())
  interaction_type   String
  target_entity_id   String?
  target_entity_type String?
  content_text       String?
  content_structured Json?
  metadata           Json?
  users              users    @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
}

model media_items {
  media_id          String        @id
  user_id           String
  memory_unit_id    String?
  type              String
  storage_url       String
  filename          String?
  mime_type         String?
  size_bytes        Int?
  hash              String?       @unique
  processing_status String        @default("pending")
  metadata          Json?
  created_at        DateTime      @default(now())
  memory_units      memory_units? @relation(fields: [memory_unit_id], references: [muid])
  users             users         @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([processing_status])
  @@index([user_id, created_at(sort: Desc)])
  @@index([user_id])
  @@index([user_id, type])
}

model memory_units {
  muid                   String              @id
  user_id                String
  title                  String
  content                String
  creation_ts            DateTime
  ingestion_ts           DateTime            @default(now())
  last_modified_ts       DateTime
  importance_score       Float?
  sentiment_score        Float?
  source_conversation_id String?
  derived_artifacts      derived_artifacts[]
  media_items            media_items[]
  conversations          conversations?      @relation(fields: [source_conversation_id], references: [id])
  users                  users               @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
}

model proactive_prompts {
  prompt_id    String   @id
  user_id      String
  prompt_text  String
  source_agent String
  status       String   @default("pending")
  created_at   DateTime @default(now())
  metadata     Json?
  users        users    @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
}

model user_challenges {
  user_challenge_id     String    @id
  user_id               String
  challenge_template_id String
  status                String    @default("active")
  start_time            DateTime  @default(now())
  completion_time       DateTime?
  progress_data         Json?
  users                 users     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
}

model user_graph_projections {
  projection_id   String   @id
  user_id         String
  status          String   @default("completed")
  projection_data Json
  metadata        Json?
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt
  users           users    @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([user_id, created_at(sort: Desc)])
}

model user_sessions {
  session_id     String   @id
  user_id        String
  device_info    Json?
  ip_address     String?
  user_agent     String?
  created_at     DateTime @default(now())
  expires_at     DateTime
  last_active_at DateTime
  users          users    @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([user_id])
}

model users {
  user_id                           String                   @id
  email                             String                   @unique
  hashed_password                   String?
  name                              String?
  preferences                       Json?
  region                            String                   @default("us")
  timezone                          String?                  @default("UTC")
  language_preference               String?                  @default("en")
  profile_picture_url               String?
  created_at                        DateTime                 @default(now())
  last_active_at                    DateTime?
  account_status                    String                   @default("active")
  concepts_created_in_cycle         Int                      @default(0)
  knowledge_graph_schema            Json?
  last_cycle_started_at             DateTime?
  memory_profile                    Json?
  next_conversation_context_package Json?
  cards                             cards[]
  communities                       communities[]
  concepts                          concepts[]
  conversations                     conversations[]
  derived_artifacts                 derived_artifacts[]
  growth_events                     growth_events[]
  interaction_logs                  interaction_logs[]
  media_items                       media_items[]
  memory_units                      memory_units[]
  proactive_prompts                 proactive_prompts[]
  user_challenges                   user_challenges[]
  user_graph_projections            user_graph_projections[]
  user_sessions                     user_sessions[]
}
```

## **Part 2: Current Repository Implementation Patterns**

### **Tech Lead Decision: Official Prisma Accessor Pattern**

**OFFICIAL PROJECT STANDARD (V11.3+):** Use `lowercase_plural` Prisma accessors throughout the codebase.

- ✅ **CORRECT:** `this.db.prisma.users`
- ✅ **CORRECT:** `this.db.prisma.conversations`
- ✅ **CORRECT:** `this.db.prisma.conversation_messages`
- ✅ **CORRECT:** `this.db.prisma.memory_units`

**Rationale:** This pattern matches the actual generated Prisma client and has been consistently implemented across all current repositories. Changing this would require extensive refactoring with minimal benefit.

### **Current Repository Base Pattern**

```typescript
// packages/database/src/repositories/[Entity]Repository.ts
// Current Implementation Pattern

import { DatabaseService } from '../DatabaseService';
import type { users } from '@2dots1line/database'; // Uses generated Prisma types

export class UserRepository {
  constructor(private db: DatabaseService) {}

  async findById(userId: string): Promise<users | null> {
    return this.db.prisma.users.findUnique({
      where: { user_id: userId },
    });
  }

  async create(data: CreateUserData): Promise<users> {
    return this.db.prisma.users.create({
      data: {
        user_id: randomUUID(),
        account_status: 'active',
        ...data,
      },
    });
  }

  // Additional methods following same pattern...
}
```

### **Currently Implemented Repositories**

**Location:** `packages/database/src/repositories/`

1. ✅ **UserRepository** - Full implementation
2. ✅ **ConversationRepository** - Full implementation with message handling
3. ✅ **MemoryRepository** - Full implementation
4. ✅ **ConceptRepository** - Full implementation
5. ✅ **CardRepository** - Full implementation
6. ✅ **MediaRepository** - Full implementation
7. ✅ **DerivedArtifactRepository** - Full implementation
8. ✅ **GrowthEventRepository** - Full implementation
9. ✅ **InteractionLogRepository** - Full implementation
10. ✅ **ProactivePromptRepository** - Full implementation
11. ✅ **GraphProjectionRepository** - Full implementation

### **Current DatabaseService Implementation**

```typescript
// packages/database/src/DatabaseService.ts
// V9.7 Current Implementation

export class DatabaseService {
  public readonly prisma: PrismaClient;
  public readonly neo4j: Neo4jDriver;
  public readonly weaviate: WeaviateClient;
  public readonly redis: Redis;

  private static instance: DatabaseService;

  private constructor() {
    this.prisma = prisma; // Singleton Prisma client
    this.neo4j = neo4jDriver(/* config */);
    this.weaviate = weaviate.client(/* config */);
    this.redis = new Redis(/* config */);
  }

  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
  }
}
```

## **Part 3: Current Worker Implementation Status**

### **InsightEngine Current Implementation**

**Location:** `workers/insight-worker/src/InsightEngine.ts`

✅ **IMPLEMENTED:** 283 lines, full strategic cycle processing
- Uses correct `this.db.prisma.conversations`, `this.db.prisma.memory_units` patterns
- Implements 4-phase workflow: Data Compilation → LLM Synthesis → Persistence → Event Publishing
- Direct tool injection (V11.0 headless architecture)
- Comprehensive error handling
- BullMQ integration for CardWorker events

### **InsightDataCompiler Current Implementation**

**Location:** `workers/insight-worker/src/InsightDataCompiler.ts`

✅ **IMPLEMENTED:** 494 lines, full data compilation logic
- Three input packages: IngestionActivitySummary, GraphAnalysisPackage, StrategicInsightPackage
- Uses correct Prisma accessor patterns throughout
- Neo4j integration with fallbacks
- Comprehensive data analysis methods

### **DialogueAgent Current Implementation**

**Location:** `services/dialogue-service/src/DialogueAgent.ts`

✅ **IMPLEMENTED:** 310 lines, V10.9 implementation
- Single synthesis call architecture
- Tool dependency injection
- Redis context management
- Proper conversation message recording using `this.conversationRepo.addMessage()`

## **Part 4: Current Database Connection Management**

### **Connection Pooling Current State**

```typitten
// packages/database/src/DatabaseService.ts - Actual Implementation

export class DatabaseService {
  // Singleton pattern enforced
  private static instance: DatabaseService;

  private constructor() {
    // PostgreSQL via Prisma
    this.prisma = prisma; // From singleton prisma-client.ts

    // Neo4j with basic configuration
    this.neo4j = neo4jDriver(
      process.env.NEO4J_URI_DOCKER || 'bolt://localhost:7687',
      neo4jAuth.basic(process.env.NEO4J_USER!, process.env.NEO4J_PASSWORD!)
    );

    // Weaviate basic setup
    this.weaviate = weaviate.client({
      scheme: (process.env.WEAVIATE_SCHEME_DOCKER as 'http' | 'https') || 'http',
      host: process.env.WEAVIATE_HOST_DOCKER || 'localhost:8080',
    });

    // Redis with environment-based configuration
    this.redis = new Redis({
      host: process.env.NODE_ENV === 'production' ? process.env.REDIS_HOST_DOCKER : 'localhost',
      port: process.env.NODE_ENV === 'production' ? parseInt(process.env.REDIS_PORT_FOR_APP_IN_DOCKER || '6379') : 6379,
      connectTimeout: 5000,
      lazyConnect: true,
      maxRetriesPerRequest: 3
    });
  }
}
```

## **Part 5: Testing Infrastructure Current State**

### **Test Files Currently Implemented**

✅ **DialogueAgent.test.ts** - 24 comprehensive tests
✅ **InsightEngine.test.ts** - 24 comprehensive tests covering all phases
✅ **IngestionAnalyst.test.ts** - Full test suite
✅ **PresentationWorkers.test.ts** - Worker testing patterns

**Test Patterns Used:**
- Jest with TypeScript
- Comprehensive mocking of all dependencies
- Database transaction isolation
- BullMQ job simulation
- Error scenario coverage

## **Part 6: Neo4j Schema Current State**

**Location:** `packages/database/schemas/neo4j.cypher`

Current relationship types and node patterns match the PostgreSQL entities:
- User nodes with userId properties
- MemoryUnit and Concept nodes
- RELATED_TO, HIGHLIGHTS, OWNS relationships
- Basic indexing for performance

## **Part 7: Weaviate Schema Current State**

**Location:** `packages/database/schemas/weaviate.json`

Current vector store configuration:
- UserKnowledgeItem class
- text2vec-openai vectorizer
- Multi-tenant support via userId
- Basic property schema for content, metadata, and source tracking

---

## **Summary: Current Implementation vs V11.0 Goals**

### **✅ Successfully Implemented:**
1. Headless service architecture (InsightEngine, DialogueAgent)
2. Repository pattern with consistent Prisma accessors
3. Comprehensive database schemas
4. Tool injection architecture
5. Multi-database integration (PostgreSQL, Neo4j, Weaviate, Redis)
6. Testing infrastructure
7. BullMQ worker system

### **🔄 Implementation Gaps Identified:**
1. Some advanced Neo4j queries could be optimized
2. Weaviate schema could be expanded for better semantic search
3. Additional repository methods for complex queries
4. Performance monitoring and optimization
5. Advanced connection pooling configurations

### **📋 Tech Lead Review Points:**
1. **Prisma Pattern:** Current `lowercase_plural` pattern is working well across all repositories
2. **Tool Architecture:** Direct injection is successfully reducing latency
3. **Testing Coverage:** Comprehensive test suites are in place and functioning
4. **Database Performance:** Current singleton pattern is adequate for current scale
5. **Error Handling:** Robust error handling implemented throughout

This document accurately reflects the **current state** of the V11.0 implementation as it exists in the codebase today. 