# V11.0 Cosmos Architecture Design Document

## Overview

This document outlines the comprehensive redesign of the 3D Knowledge Cosmos visualization system, transitioning from a monolithic JSON-based projection system to a scalable, query-driven architecture that supports real-time spatial queries, time travel experiences, and efficient rendering of large knowledge graphs.

## ⚠️ Post-Migration Schema Update

**This document has been updated to reflect the standardized field naming schema implemented in V11.0.** All database schemas (PostgreSQL, Neo4j, Weaviate) now use consistent field names:

- **Primary Keys**: `entity_id` for entities, specific IDs for non-entities (`conversation_id`, `message_id`, etc.)
- **Standardized Fields**: `title`, `content`, `type`, `status`, `created_at`, `updated_at`
- **Cross-Database Consistency**: Same `entity_id` values across PostgreSQL, Neo4j, and Weaviate
- **Nullable Updates**: `updated_at` is nullable across all tables
- **Unified Indexes**: Generic indexes that work across all entity types

See [7.1_V11.0_Field_Naming_Standardization_Migration_Plan.md](../V11.0/7.1_V11.0_Field_Naming_Standardization_Migration_Plan.md) for complete migration details.

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Current Architecture Analysis](#current-architecture-analysis)
3. [New Architecture Design](#new-architecture-design)
4. [Data Structure Changes](#data-structure-changes)
5. [Worker Responsibilities](#worker-responsibilities)
6. [API Design](#api-design)
7. [Frontend Rendering Capabilities](#frontend-rendering-capabilities)
8. [PM2 Service Implications](#pm2-service-implications)
9. [Migration Strategy](#migration-strategy)
10. [Performance Implications](#performance-implications)
11. [Implementation Timeline](#implementation-timeline)

---

## Executive Summary

### Problem Statement

The current cosmos visualization system suffers from several critical limitations:

- **Monolithic Storage**: Entire graph projections stored as large JSON objects in `user_graph_projections.projection_data`
- **Complete Regeneration**: Every node addition requires full projection rebuild
- **No Spatial Indexing**: Cannot efficiently query nodes by 3D position
- **Memory Inefficiency**: Large JSON objects consume significant memory
- **Limited Query Types**: Only supports full projection retrieval
- **Poor Scalability**: Performance degrades with graph size

### Solution Overview

The V11.0 redesign introduces:

- **Normalized Storage**: 3D coordinates stored directly in existing entity tables
- **Incremental Updates**: Individual node coordinate updates instead of full regeneration
- **Spatial Indexing**: PostgreSQL PostGIS for efficient 3D spatial queries
- **Query-Driven Rendering**: Unified filtering system with three MECE categories (attribute-based, spatial, set-based)
- **Time Travel Features**: Chronological navigation through memories
- **Performance Optimization**: Viewport culling, LOD system, dynamic loading

---

## Current Architecture Analysis

### Data Flow (Current)

```
1. IngestionAnalyst creates entities → PostgreSQL + Neo4j
2. IngestionAnalyst triggers EmbeddingWorker → TextEmbeddingTool → Weaviate (full vectors)
3. InsightEngine processes cycle → Creates/updates nodes & edges in Neo4j
4. GraphProjectionWorker triggered → Fetches entire graph from Neo4j
5. Fetches all vectors from Weaviate → Python DimensionReducer → 3D coordinates
6. Stores complete projection as JSON in user_graph_projections.projection_data
7. Frontend fetches entire JSON projection
8. Renders all nodes regardless of camera position
```

### Current Data Sources

#### PostgreSQL Tables (Post-Migration Schema)
- `concepts` - User concepts with standardized fields (`entity_id`, `user_id`, `title`, `content`, `type`, `status`, `created_at`, `updated_at`)
- `memory_units` - User memory units with standardized fields (`entity_id`, `user_id`, `title`, `content`, `type`, `status`, `created_at`, `updated_at`)
- `derived_artifacts` - Generated artifacts with standardized fields (`entity_id`, `user_id`, `title`, `content`, `type`, `status`, `created_at`, `updated_at`)
- `communities` - Concept communities with standardized fields (`entity_id`, `user_id`, `title`, `content`, `type`, `status`, `created_at`, `updated_at`)
- `proactive_prompts` - AI-generated prompts with standardized fields (`entity_id`, `user_id`, `content`, `type`, `status`, `created_at`, `updated_at`)
- `user_graph_projections` - **Large JSON projections** (bottleneck) - stores 3D coordinates
- `conversations` - Chat conversations (`conversation_id`, `user_id`, `title`, `content`, `type`, `status`, `created_at`, `ended_at`, `updated_at`)
- `growth_events` - User growth tracking (`entity_id`, `user_id`, `title`, `content`, `type`, `status`, `created_at`, `updated_at`)
- `conversation_messages` - Individual messages (`message_id`, `conversation_id`, `content`, `type`, `status`, `created_at`)
- `user_cycles` - Strategic analysis cycles (`cycle_id`, `user_id`, `type`, `status`, `created_at`, `ended_at`, `completed_at`)
- `interaction_logs` - User interaction tracking (`interaction_id`, `user_id`, `content`, `type`, `created_at`)
- `cards` - UI card data (`card_id`, `user_id`, `title`, `content`, `type`, `status`, `created_at`, `updated_at`)
- `media_items` - Media attachments (`media_id`, `user_id`, `title`, `content`, `type`, `status`, `created_at`, `updated_at`)
- `user_sessions` - User session data (`session_id`, `user_id`, `title`, `content`, `type`, `status`, `created_at`, `ended_at`)
- `users` - User accounts (`user_id`, `title`, `content`, `type`, `status`, `created_at`, `updated_at`)

**Key Schema Changes:**
- All entity tables now use `entity_id` as primary key (UUID)
- Standardized field names: `title`, `content`, `type`, `status`, `created_at`, `updated_at`
- `updated_at` is nullable across all tables
- Non-entity tables use specific ID names: `conversation_id`, `message_id`, `cycle_id`, `interaction_id`, `card_id`, `media_id`, `session_id`

#### Neo4j Graph (Post-Migration Schema)
- **Standardized Node Properties**: All entity types now have consistent properties:
  - `entity_id` - Universal identifier (same as PostgreSQL)
  - `user_id` - User reference for filtering
  - `entity_type` - Which entity table (concept, memory_unit, derived_artifact, etc.)
  - `title` - Display name for UI
  - `content` - Main content for display
  - `type` - Sub-type within each entity (e.g., 'value', 'insight_summary', 'engagement')
  - `status` - Lifecycle state for filtering
  - `created_at` - Creation timestamp
  - `updated_at` - Update timestamp (nullable)

- **Unified Constraints**: Single `entity_id_unique` constraint across all entity types
- **Unified Indexes**: Generic indexes (`user_id_idx`, `entity_type_idx`, `type_idx`, `status_idx`, `created_at_idx`) that work across all entity types
- **Node Types**: Concepts, MemoryUnits, DerivedArtifacts, Communities, ProactivePrompts, GrowthEvents
- **Relationships**: CONNECTED_TO, RELATED_TO, DERIVED_FROM, etc.
- **Used by**: `Neo4jService.fetchFullGraphStructure()`

**Key Schema Changes:**
- All entity nodes use `entity_id` as primary identifier
- Standardized field names across all node types
- Added `entity_type` field to distinguish between different entity tables
- Unified constraint and index strategy for better performance

#### Weaviate Vectors (Post-Migration Schema)
- **Standardized UserKnowledgeItem Class** with consistent properties:
  - `entity_id` - Universal identifier (same as PostgreSQL and Neo4j)
  - `user_id` - User reference for filtering
  - `entity_type` - Which entity table (concept, memory_unit, derived_artifact, etc.)
  - `content` - Main content for vector search (standardized from `textContent`)
  - `title` - Display title for search results
  - `type` - Sub-type within each entity (e.g., 'value', 'insight_summary', 'engagement')
  - `embedding_model_version` - Model version for embeddings
  - `created_at` - Timestamp for ordering
  - `status` - Lifecycle state for filtering

- **Vector Search Capabilities**: 768D embeddings for semantic similarity search
- **Used by**: `HybridRetrievalTool` for semantic search and graph traversal
- **Cross-Database Consistency**: Same `entity_id` values across PostgreSQL, Neo4j, and Weaviate

**Key Schema Changes:**
- Renamed `sourceEntityId` → `entity_id` for consistency
- Renamed `sourceEntityType` → `entity_type` for clarity
- Standardized `textContent` → `content`
- Removed redundant `externalId` field (was identical to `sourceEntityId`)
- Removed unused fields (`importanceScore`, `tags`, duplicate `embeddingModelVersion`)
- Added proper type distinction between `entity_type` (which table) and `type` (sub-types)

### InsightEngine's Role in Graph Construction

#### Current InsightEngine Functionality

The InsightEngine is a critical component that creates and updates nodes and edges in the Neo4j graph structure. It operates on a cycle-based schedule and performs strategic analysis to enhance the knowledge graph.

**Key Responsibilities:**

1. **Strategic Analysis**: Uses StrategicSynthesisTool to analyze user data and generate insights
2. **Node Creation**: Creates new nodes in both PostgreSQL and Neo4j
3. **Edge Creation**: Establishes relationships between nodes
4. **Graph Updates**: Modifies existing nodes and relationships
5. **Ontology Management**: Handles concept merging, archiving, and community creation

#### Node Creation and Updates

**1. Derived Artifacts (Post-Migration Schema):**
```typescript
// InsightEngine creates DerivedArtifact nodes with standardized fields
private async createNeo4jArtifact(artifact: any): Promise<void> {
  const createArtifactCypher = `
    CREATE (a:DerivedArtifact {
      entity_id: $entityId,
      user_id: $userId,
      entity_type: 'derived_artifact',
      title: $title,
      content: $content,
      type: $type,
      status: 'active',
      created_at: datetime(),
      source_concept_ids: $sourceConceptIds,
      source_memory_unit_ids: $sourceMemoryUnitIds
    })
    RETURN a.entity_id as entityId
  `;
  
  // Create DERIVED_FROM relationships with source concepts
  const sourceRelationshipCypher = `
    MATCH (a:DerivedArtifact {entity_id: $entityId})
    MATCH (c:Concept {entity_id: $conceptEntityId})
    CREATE (a)-[r:DERIVED_FROM {
      relationship_type: 'concept_source',
      created_at: datetime()
    }]->(c)
    RETURN r
  `;
}
```

**2. Proactive Prompts (Post-Migration Schema):**
```typescript
// InsightEngine creates ProactivePrompt nodes with standardized fields
private async createNeo4jPrompt(prompt: any): Promise<void> {
  const createPromptCypher = `
    MERGE (p:ProactivePrompt {entity_id: $entityId})
    SET p.user_id = $userId,
        p.entity_type = 'proactive_prompt',
        p.title = $content,  // Use content as title since no separate title field
        p.content = $content,
        p.type = $type,
        p.status = 'pending',
        p.created_at = datetime(),
        p.metadata = $metadata
    RETURN p.entity_id as entityId
  `;
}
```

**3. Communities (Post-Migration Schema):**
```typescript
// InsightEngine creates Community nodes with standardized fields
private async createNeo4jCommunity(community: any, memberConceptIds: string[]): Promise<void> {
  const createCommunityCypher = `
    CREATE (c:Community {
      entity_id: $entityId,
      user_id: $userId,
      entity_type: 'community',
      title: $title,
      content: $content,
      type: 'community',
      status: 'active',
      created_at: datetime(),
      member_count: $memberCount
    })
    RETURN c.entity_id as entityId
  `;
  
  // Create MEMBER_OF relationships
  const memberRelationshipCypher = `
    MATCH (c:Community {entity_id: $entityId})
    MATCH (concept:Concept {entity_id: $conceptEntityId})
    CREATE (concept)-[r:MEMBER_OF {
      created_at: datetime(),
      membership_strength: $strength
    }]->(c)
    RETURN r
  `;
}
```

#### Edge Creation and Updates

**1. Strategic Relationships (Post-Migration Schema):**
```typescript
// InsightEngine creates strategic relationships between concepts
private async createStrategicRelationships(relationships: any[]): Promise<void> {
  for (const rel of relationships) {
    const cypher = `
      MATCH (source:Concept {entity_id: $sourceEntityId}), (target:Concept {entity_id: $targetEntityId})
      CREATE (source)-[r:STRATEGIC_RELATIONSHIP {
        type: $relationshipType,
        strength: $strength,
        strategic_value: $strength,
        created_at: datetime(),
        relationship_id: $relationshipId
      }]->(target)
      RETURN r.relationship_id as relationshipId
    `;
  }
}
```

**2. Concept Merging:**
```typescript
// InsightEngine merges concepts and updates relationships
private async updateNeo4jMergedConcepts(merge: any): Promise<void> {
  // Update primary concept with merged properties
  const updatePrimaryCypher = `
    MATCH (primary:Concept {id: $primaryId})
    SET primary.merged_concepts = $mergedConcepts,
        primary.merge_rationale = $mergeRationale,
        primary.merged_at = datetime()
    RETURN primary
  `;
  
  // Archive secondary concepts
  const archiveSecondaryCypher = `
    MATCH (secondary:Concept {id: $secondaryId})
    SET secondary.status = 'merged',
        secondary.merged_into_concept_id = $primaryId,
        secondary.merged_at = datetime()
    RETURN secondary
  `;
}
```

**3. Concept Archiving:**
```typescript
// InsightEngine archives outdated concepts (Post-Migration Schema)
private async updateNeo4jConceptStatus(entityId: string, status: string): Promise<void> {
  const cypher = `
    MATCH (c:Concept {entity_id: $entityId})
    SET c.status = $status,
        c.archived_at = datetime(),
        c.archive_rationale = $archiveRationale
    RETURN c.entity_id as entityId
  `;
}
```

#### Complete InsightEngine Processing Flow

```typescript
async processUserCycle(job: Job<InsightJobData>): Promise<void> {
  // Phase I: Data Compilation and Context Gathering
  const { strategicInput } = await this.gatherComprehensiveContext(userId, job.id, cycleDates);
  
  // Phase II: Strategic Synthesis
  const analysisOutput = await this.strategicSynthesisTool.execute(strategicInput);
  
  // Phase III: Persistence, Graph Update & State Propagation
  const newEntities = await this.persistStrategicUpdates(userId, analysisOutput, cycleId);
  
  // Phase IV: Event Publishing for Presentation Layer
  await this.publishEvents(userId, newEntities);
}
```

#### Entities Created by InsightEngine

1. **DerivedArtifacts**: AI-generated content based on user data
2. **ProactivePrompts**: Engagement prompts for user interaction
3. **Communities**: Groupings of related concepts
4. **MergedConcepts**: Consolidated concepts from merging operations
5. **StrategicRelationships**: High-level connections between concepts
6. **ArchivedConcepts**: Concepts marked for archival

#### Impact on Cosmos Visualization

The InsightEngine's graph construction activities directly impact the cosmos visualization:

1. **New Nodes**: Each new entity becomes a node in the 3D cosmos
2. **New Edges**: Relationships create visual connections between nodes
3. **Graph Structure**: Strategic relationships influence spatial positioning
4. **Semantic Clustering**: Communities create natural groupings in 3D space
5. **Temporal Evolution**: Cycle-based updates create time-based graph evolution

### Embedding and Dimension Reduction Pipeline

#### Current Pipeline (Detailed)

**1. Entity Creation & Embedding Generation:**
```typescript
// IngestionAnalyst creates entities and triggers embedding
await this.embeddingQueue.add('create_embedding', {
  entityId: entity.id,
  entityType: entity.type,
  textContent: textContent,
  userId
});

// InsightEngine also creates ProactivePrompts and triggers embedding
await this.embeddingQueue.add('generate_embedding', {
  entityId: prompt.prompt_id,
  entityType: 'ProactivePrompt',
  textContent: prompt.prompt_text,
  userId
});
```

**2. EmbeddingWorker Processing:**
```typescript
// EmbeddingWorker generates 768D vectors
const embedding = await this.textEmbeddingTool.execute({
  payload: {
    text_to_embed: textContent,
    model_id: this.config.embeddingModelVersion!
  },
  user_id: userId
});

// Store in Weaviate
const weaviateId = await this.storeEmbeddingInWeaviate({
  entityId,
  entityType,
  textContent,
  userId,
  vector: embedding.result.vector // 768D vector
});
```

**3. GraphProjectionWorker Processing:**
```typescript
// Fetch all vectors from Weaviate
const vectors = await this.fetchEmbeddingsFromWeaviate(graphData.nodes);

// Call Python dimension reducer service
const coordinates3D = await this.callDimensionReducer(vectors);
```

**4. Dimension Reducer Service (Python):**
```python
# py-services/dimension-reducer/app.py
@app.post("/reduce")
async def reduce_dimensions(request: DimensionReductionRequest):
    # Convert 768D vectors to 3D coordinates using UMAP/t-SNE
    X = np.array(request.vectors, dtype=np.float32)  # [n_nodes, 768]
    
    reducer = umap.UMAP(
        n_components=3,
        n_neighbors=15,
        min_dist=0.1,
        random_state=42,
        metric='cosine'
    )
    
    coordinates = reducer.fit_transform(X)  # [n_nodes, 3]
    return DimensionReductionResponse(coordinates=coordinates.tolist())
```

**5. Storage as Large JSON:**
```typescript
// Store complete projection as JSON
const projection = {
  nodes: graphData.nodes.map((node, i) => ({
    id: node.id,
    type: node.type,
    title: node.title,
    position: coordinates3D[i], // [x, y, z]
    // ... other properties
  })),
  edges: graphData.edges,
  metadata: { /* ... */ }
};

await this.storeProjection(projection);
```

#### New Pipeline (Proposed)

**1. Entity Creation (Same):**
```typescript
// IngestionAnalyst creates entities → PostgreSQL + Neo4j
// Triggers EmbeddingWorker → Weaviate (768D vectors)
```

**2. Incremental Coordinate Updates:**
```typescript
// GraphProjectionWorker handles individual entities
private async handleIncrementalUpdate(data: NewEntitiesCreatedEvent): Promise<void> {
  for (const entity of data.entities) {
    // 1. Get entity data
    const entityData = await this.getEntityData(entity.id, entity.type);
    
    // 2. Get embedding from Weaviate
    const embedding = await this.getEntityEmbedding(entity.id, entity.type);
    
    // 3. Calculate position (incremental)
    const position = await this.calculateIncrementalPosition(embedding, entityData);
    
    // 4. Store coordinates in entity table
    await this.updateEntityCoordinates(entity.id, entity.type, position);
  }
}
```

**3. Direct Coordinate Storage:**
```sql
-- Store 3D coordinates directly in entity tables
UPDATE concepts 
SET position_x = $1, position_y = $2, position_z = $3 
WHERE concept_id = $4;

UPDATE memory_units 
SET position_x = $1, position_y = $2, position_z = $3 
WHERE muid = $4;

UPDATE proactive_prompts 
SET position_x = $1, position_y = $2, position_z = $3 
WHERE prompt_id = $4;
```

### Proactive Prompts in the Cosmos

#### Unique Characteristics
Proactive prompts have special characteristics that make them interesting for cosmos visualization:

1. **AI-Generated Content**: Created by InsightEngine, not user input
2. **Temporal Nature**: Generated at specific cycles, creating temporal clusters
3. **Engagement Focus**: Designed to prompt user interaction
4. **Source Agent Tracking**: Can be grouped by which agent created them
5. **Status-Based Filtering**: Can filter by pending/completed status

#### Visual Representation
```typescript
// Proactive prompts could have special visual treatment
const ProactivePromptNode: React.FC<{ prompt: ProactivePrompt }> = ({ prompt }) => {
  const getPromptVisualStyle = (status: string) => {
    switch (status) {
      case 'pending':
        return { 
          color: '#8844ff', 
          opacity: 0.8,
          animation: 'pulse' // Draw attention to pending prompts
        };
      case 'completed':
        return { 
          color: '#44ff88', 
          opacity: 0.6,
          animation: 'none'
        };
      default:
        return { color: '#8844ff', opacity: 0.7 };
    }
  };
  
  return (
    <mesh style={getPromptVisualStyle(prompt.status)}>
      <sphereGeometry args={[prompt.importance_score * 2, 16, 16]} />
      <meshBasicMaterial />
    </mesh>
  );
};
```

#### Time Travel Integration
Proactive prompts add a unique dimension to time travel experiences:

```typescript
// Enhanced time travel that includes prompts
const TimeTravelTour: React.FC<{ items: (MemoryUnit | ProactivePrompt)[] }> = ({ items }) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  
  const renderTimeTravelItem = (item: MemoryUnit | ProactivePrompt) => {
    if ('prompt_text' in item) {
      // This is a proactive prompt
      return (
        <div className="time-travel-prompt">
          <h3>AI Prompt</h3>
          <p>{item.prompt_text}</p>
          <span className="source">Generated by {item.source_agent}</span>
        </div>
      );
    } else {
      // This is a memory unit
      return (
        <div className="time-travel-memory">
          <h3>{item.title}</h3>
          <p>{item.content}</p>
        </div>
      );
    }
  };
  
  return (
    <div className="time-travel-container">
      {renderTimeTravelItem(items[currentIndex])}
    </div>
  );
};
```

### The Incremental Positioning Challenge

The current dimension reduction approach has a fundamental issue: UMAP and t-SNE are stochastic algorithms that produce different results when run on different batches of data. This means:

1. **Non-Deterministic Results**: Same node gets different positions in different batches
2. **Batch Dependency**: Parameters change based on batch size  
3. **No Incremental Learning**: Cannot add new points to existing layouts

Our solution addresses this by using a **hybrid approach** that combines the quality of UMAP with the efficiency and determinism of linear transformation.

## Hybrid UMAP + Linear Transformation System

### System Overview

The hybrid system uses **two complementary approaches** based on the current node count:

- **UMAP Learning**: Runs at configurable intervals (default: every 500 nodes) to learn the manifold structure
- **Linear Transformation**: Used between UMAP learning runs for fast, deterministic positioning

### Decision Logic

```typescript
class HybridUMAPLinearSystem {
  private readonly config: {
    umapInterval: number;        // Default: 500 nodes
    minNodesForUMAP: number;    // Default: 500 nodes
    maxNodesForUMAP: number;    // Default: 10000 nodes (optional limit)
  };
  
  constructor(config?: Partial<typeof this.config>) {
    this.config = {
      umapInterval: 500,
      minNodesForUMAP: 500,
      maxNodesForUMAP: 10000,
      ...config
    };
  }
  
  async processNewNodes(userId: string, newNodes: Node[]): Promise<void> {
    const currentNodeCount = await this.getCurrentNodeCount(userId);
    const totalNodes = currentNodeCount + newNodes.length;
    
    if (this.shouldRunUMAP(totalNodes)) {
      // UMAP Learning: Learn manifold structure + create transformation matrix
      await this.runUMAPLearning(userId, newNodes);
    } else {
      // Linear Transformation: Use stored matrix for fast positioning
      await this.runLinearTransformation(userId, newNodes);
    }
  }
  
  private shouldRunUMAP(totalNodes: number): boolean {
    // Run UMAP at regular intervals starting from minNodesForUMAP
    return totalNodes >= this.config.minNodesForUMAP && 
           totalNodes <= (this.config.maxNodesForUMAP || Infinity) &&
           totalNodes % this.config.umapInterval === 0;
  }
}
```

### UMAP Learning Mode

**When**: At configurable intervals (default: every 500 nodes starting from 500)
**Purpose**: Learn the optimal manifold structure for the current graph

```typescript
async runUMAPLearning(userId: string, newNodes: Node[]): Promise<void> {
  // 1. Get ALL nodes (existing + new)
  const allNodes = await this.getAllNodes(userId);
  const allEmbeddings = await this.getEmbeddingsForNodes(allNodes);
  
  // 2. Run UMAP to learn manifold structure
  const umapCoordinates = await this.runUMAP(allEmbeddings);
  
  // 3. Create linear transformation matrix using Ridge regression
  const transformationMatrix = await this.createLinearTransformationMatrix(
    allEmbeddings, 
    umapCoordinates
  );
  
  // 4. Store matrix for future use
  await this.storeTransformationMatrix(userId, transformationMatrix);
  
  // 5. Update all coordinates
  await this.updateAllCoordinates(allNodes, umapCoordinates);
}
```

### Linear Transformation Mode

**When**: Between UMAP learning runs (e.g., 501-999, 1001-1499, etc.)
**Purpose**: Fast, deterministic positioning using learned transformation

```typescript
async runLinearTransformation(userId: string, newNodes: Node[]): Promise<void> {
  // 1. Get stored transformation matrix
  const matrix = await this.getTransformationMatrix(userId);
  
  // 2. Transform new embeddings using matrix multiplication
  const embeddings = await this.getEmbeddingsForEntities(newNodes);
  const coordinates = await this.transformWithLinearMatrix(embeddings, matrix);
  
  // 3. Store new coordinates
  await this.storeNewCoordinates(newNodes, coordinates);
}
```

### Configuration Management

The system supports flexible configuration through environment variables or config files:

```typescript
// Environment variables
const config = {
  umapInterval: parseInt(process.env.UMAP_INTERVAL) || 500,
  minNodesForUMAP: parseInt(process.env.MIN_NODES_FOR_UMAP) || 500,
  maxNodesForUMAP: parseInt(process.env.MAX_NODES_FOR_UMAP) || 10000
};

// Or from config file
const config = await loadConfig('cosmos-projection.json');
```

**Configuration Options:**
- `umapInterval`: How often to run UMAP learning (default: 500)
- `minNodesForUMAP`: Minimum nodes before first UMAP run (default: 500)
- `maxNodesForUMAP`: Optional maximum nodes for UMAP runs (default: unlimited)

### System Benefits

- **Deterministic**: Linear transformation is 100% deterministic
- **Efficient**: O(k) time complexity for new nodes (k = new node count)
- **Quality**: UMAP learning preserves complex manifold structure
- **Scalable**: Performance improves as graph grows
- **Memory efficient**: Only stores transformation matrix (~9KB per user)
- **Configurable**: Easy to tune intervals based on usage patterns

### Implementation Details

#### 1. UMAP Learning Mode

**Trigger**: When total node count reaches 500, 1000, 1500, 2000, etc.
**Process**: Learn manifold structure and create transformation matrix

```typescript
class UMAPLearningMode {
  async runUMAPLearning(userId: string, newNodes: Node[]): Promise<void> {
    // 1. Get ALL nodes (existing + new)
    const allNodes = await this.getAllNodes(userId);
    const allEmbeddings = await this.getEmbeddingsForNodes(allNodes);
    
    // 2. Run UMAP to learn the manifold
    const umapCoordinates = await this.runUMAP(allEmbeddings);
    
    // 3. Create linear transformation matrix using Ridge regression
    const transformationMatrix = await this.createLinearTransformationMatrix(
      allEmbeddings, 
      umapCoordinates
    );
    
  // 4. Store the matrix in user_graph_projections table
  await this.storeTransformationMatrix(userId, transformationMatrix);
  
  // 5. Update all coordinates in entity tables
  await this.updateAllCoordinates(allNodes, umapCoordinates);
    
    console.log(`[UMAPLearning] Created linear transformation matrix for ${allNodes.length} nodes`);
  }
  
  private async createLinearTransformationMatrix(
    embeddings: number[][], 
    coordinates: number[][]
  ): Promise<number[][]> {
    // Use Ridge regression to create transformation matrix
    // Solves: coordinates = transformation_matrix @ embeddings
    // with L2 regularization to prevent overfitting
    
    const ridge = new RidgeRegression({ alpha: 0.1 });
    ridge.fit(embeddings, coordinates);
    
    return ridge.coef_.T; // [768, 3] matrix
  }
}
```

#### 2. Linear Transformation Mode

**Trigger**: Between UMAP learning runs (e.g., 501-699, 701-999, 1001-1499, etc.)
**Process**: Fast positioning using stored transformation matrix

```typescript
class LinearTransformationMode {
  async runLinearTransformation(userId: string, newNodes: Node[]): Promise<void> {
    // 1. Get stored transformation matrix
    const transformationMatrix = await this.getTransformationMatrix(userId);
    if (!transformationMatrix) {
      throw new Error(`No transformation matrix for user ${userId}`);
    }
    
    // 2. Get embeddings for new nodes
    const newEmbeddings = await this.getEmbeddingsForNodes(newNodes);
    
    // 3. Transform using simple matrix multiplication
    const newCoordinates = await this.transformWithLinearMatrix(
      newEmbeddings, 
      transformationMatrix
    );
    
    // 4. Store new coordinates
    await this.storeNewCoordinates(newNodes, newCoordinates);
    
    console.log(`[LinearTransform] Transformed ${newNodes.length} nodes using linear matrix`);
  }
  
  private async transformWithLinearMatrix(
    embeddings: number[][], 
    matrix: number[][]
  ): Promise<number[][]> {
    // Simple matrix multiplication: new_coordinates = matrix @ new_embeddings
    const A = np.array(embeddings);      // [n_new_nodes, 768]
    const M = np.array(matrix);          // [768, 3]
    const result = A @ M                 // [n_new_nodes, 3]
    
    return result.tolist();
  }
}
```

#### 3. Database Schema Changes

**Reuse Existing `user_graph_projections` Table:**
```sql
-- Add transformation matrix column to existing table
ALTER TABLE user_graph_projections ADD COLUMN transformation_matrix JSONB;

-- The existing table structure:
-- user_id VARCHAR(255) PRIMARY KEY
-- projection_data JSONB  -- Can store both projection data and matrix
-- transformation_matrix JSONB  -- NEW: Store the 768x3 matrix
-- created_at TIMESTAMP
-- updated_at TIMESTAMP
```

**Enhanced Entity Tables:**
```sql
-- Add 3D coordinates to existing entity tables
ALTER TABLE concepts ADD COLUMN position_x FLOAT;
ALTER TABLE concepts ADD COLUMN position_y FLOAT;
ALTER TABLE concepts ADD COLUMN position_z FLOAT;

ALTER TABLE memory_units ADD COLUMN position_x FLOAT;
ALTER TABLE memory_units ADD COLUMN position_y FLOAT;
ALTER TABLE memory_units ADD COLUMN position_z FLOAT;

ALTER TABLE derived_artifacts ADD COLUMN position_x FLOAT;
ALTER TABLE derived_artifacts ADD COLUMN position_y FLOAT;
ALTER TABLE derived_artifacts ADD COLUMN position_z FLOAT;

ALTER TABLE proactive_prompts ADD COLUMN position_x FLOAT;
ALTER TABLE proactive_prompts ADD COLUMN position_y FLOAT;
ALTER TABLE proactive_prompts ADD COLUMN position_z FLOAT;

-- Add spatial indexes
CREATE INDEX idx_concepts_spatial ON concepts(position_x, position_y, position_z);
CREATE INDEX idx_memory_units_spatial ON memory_units(position_x, position_y, position_z);
CREATE INDEX idx_derived_artifacts_spatial ON derived_artifacts(position_x, position_y, position_z);
CREATE INDEX idx_proactive_prompts_spatial ON proactive_prompts(position_x, position_y, position_z);
```

#### 4. Transformation Matrix Storage

**Store Matrix in Existing Table:**
```typescript
class TransformationMatrixStorage {
  async storeTransformationMatrix(userId: string, matrix: number[][]): Promise<void> {
    await this.postgresService.query(`
      INSERT INTO user_graph_projections (user_id, transformation_matrix, updated_at)
      VALUES ($1, $2, $3)
      ON CONFLICT (user_id) DO UPDATE SET
        transformation_matrix = $2,
        updated_at = $3
    `, [userId, JSON.stringify(matrix), new Date()]);
  }
  
  async getTransformationMatrix(userId: string): Promise<number[][] | null> {
    const result = await this.postgresService.query(`
      SELECT transformation_matrix FROM user_graph_projections WHERE user_id = $1
    `, [userId]);
    
    return result.rows[0]?.transformation_matrix 
      ? JSON.parse(result.rows[0].transformation_matrix) 
      : null;
  }
}
```

#### 5. Enhanced Dimension Reducer Service

```python
# py-services/dimension-reducer/app.py
class HybridUMAPLinearService:
    def __init__(self):
        self.transformation_matrices = {}  # Store matrices per user
    
    async def run_umap_and_create_matrix(self, user_id: str, vectors: np.ndarray) -> dict:
        """Run UMAP and create linear transformation matrix"""
        # Run UMAP
        reducer = umap.UMAP(
            n_components=3,
            n_neighbors=15,
            min_dist=0.1,
            spread=5.0,
            random_state=42,
            metric='cosine'
        )
        
        coordinates = reducer.fit_transform(vectors)
        
        # Create linear transformation matrix using Ridge regression
        from sklearn.linear_model import Ridge
        ridge = Ridge(alpha=0.1)
        ridge.fit(vectors, coordinates)
        matrix = ridge.coef_.T  # [768, 3] matrix
        
        # Store matrix
        self.transformation_matrices[user_id] = matrix
        
        return {
            "coordinates": coordinates.tolist(),
            "matrix": matrix.tolist()
        }
    
    async def transform_with_linear_matrix(self, user_id: str, vectors: np.ndarray) -> np.ndarray:
        """Transform new vectors using stored linear matrix"""
        if user_id not in self.transformation_matrices:
            raise ValueError(f"No transformation matrix for user {user_id}")
        
        matrix = self.transformation_matrices[user_id]
        return vectors @ matrix  # Simple matrix multiplication

# New API endpoints
@app.post("/umap-and-create-matrix")
async def umap_and_create_matrix(request: UMAPAndCreateMatrixRequest):
    user_id = request.user_id
    vectors = np.array(request.vectors)
    
    result = await hybrid_service.run_umap_and_create_matrix(user_id, vectors)
    return result

@app.post("/transform-with-linear-matrix")
async def transform_with_linear_matrix(request: TransformWithLinearMatrixRequest):
    user_id = request.user_id
    vectors = np.array(request.vectors)
    
    coordinates = await hybrid_service.transform_with_linear_matrix(user_id, vectors)
    return {"coordinates": coordinates.tolist()}
```

#### 5. Performance Characteristics

```typescript
// Performance analysis
const performance = {
  umap_learning: {
    time: "O(n log n)",     // Every 500 nodes
    memory: "O(n)",         // All embeddings
    frequency: "Every 500 nodes"
  },
  linear_transform: {
    time: "O(k)",           // Every new node
    memory: "O(1)",         // Just the matrix
    frequency: "Every new node"
  }
};

// Memory usage per user:
const memoryUsage = {
  transformation_matrix: 768 * 3 * 4, // 9 KB (768x3 matrix * 4 bytes)
  total: "~9 KB per user"
};

// For 1000 users: ~9 MB total
// Much more efficient than storing reference vectors!
```

#### 6. System Behavior Examples

```typescript
// Example system behavior with default config (500-node intervals):
const examples = {
  "Node 500": "UMAP Learning Mode → Learn manifold + create matrix",
  "Node 501": "Linear Transformation Mode → Use stored matrix",
  "Node 999": "Linear Transformation Mode → Use stored matrix", 
  "Node 1000": "UMAP Learning Mode → Learn manifold + update matrix",
  "Node 1001": "Linear Transformation Mode → Use updated matrix",
  "Node 1500": "UMAP Learning Mode → Learn manifold + update matrix",
  "Node 1501": "Linear Transformation Mode → Use updated matrix",
  // ... continues with configurable intervals
};

// Example with custom config (1000-node intervals):
const customConfig = {
  umapInterval: 1000,
  minNodesForUMAP: 1000,
  maxNodesForUMAP: 5000
};
// Would run UMAP at: 1000, 2000, 3000, 4000, 5000
```

### Current Query Paths

1. **Semantic Search Path:**
   ```
   User Query → HRT → Weaviate (vectors) → Neo4j (graph) → PostgreSQL (metadata)
   ```

2. **Current Cosmos Path:**
   ```
   Frontend → API Gateway → PostgreSQL (user_graph_projections) → Large JSON
   ```

3. **Node Details Path:**
   ```
   Frontend → API Gateway → PostgreSQL (individual tables) → Specific entity data
   ```

### Current Problems

1. **Large JSON Storage**: `user_graph_projections.projection_data` contains entire graph as JSON
2. **No Spatial Indexing**: Can't query by 3D coordinates efficiently
3. **Complete Regeneration**: Every update requires full projection rebuild
4. **No Incremental Updates**: Can't add/update individual nodes
5. **Memory Inefficient**: Large JSON objects in memory
6. **Limited Query Types**: Only full projection retrieval supported

---

## New Architecture Design

### Data Flow (New)

```
1. IngestionAnalyst creates entities → PostgreSQL + Neo4j
2. IngestionAnalyst triggers EmbeddingWorker → TextEmbeddingTool → Weaviate (full vectors)
3. InsightEngine processes cycle → Creates/updates nodes & edges in Neo4j
4. GraphProjectionWorker triggered → Fetches vectors from Weaviate → DimensionReducer → PostgreSQL (3D coordinates)
5. Frontend queries based on need:
   - Unified query system → PostgreSQL with MECE filters (attribute-based, spatial, set-based)
   - HRT integration → Weaviate (full vectors) + Neo4j → nodeIds → PostgreSQL coordinates
   - Time travel → HRT → Weaviate + Neo4j → nodeIds → PostgreSQL coordinates
6. Dynamic rendering based on camera viewport
```

### Core Design Principles

1. **Single Source of Truth**: 3D coordinates stored with actual entity data
2. **Query-Driven Rendering**: Unified filtering system with three MECE categories
3. **Incremental Updates**: Individual node updates instead of full regeneration
4. **Spatial Optimization**: Efficient 3D spatial queries with PostGIS
5. **Performance First**: Viewport culling, LOD, dynamic loading
6. **Backward Compatibility**: Gradual migration from old to new system

---

## Data Structure Changes

### Current vs New Approach

#### Current (Problematic)
```sql
-- Large JSON storage
CREATE TABLE user_graph_projections (
  projection_id TEXT PRIMARY KEY,
  user_id TEXT,
  projection_data JSONB,  -- Entire graph as JSON
  created_at TIMESTAMP
);
```

#### New (Recommended)
```sql
-- Add 3D coordinates directly to existing entity tables
ALTER TABLE concepts ADD COLUMN position_x FLOAT;
ALTER TABLE concepts ADD COLUMN position_y FLOAT;
ALTER TABLE concepts ADD COLUMN position_z FLOAT;

ALTER TABLE memory_units ADD COLUMN position_x FLOAT;
ALTER TABLE memory_units ADD COLUMN position_y FLOAT;
ALTER TABLE memory_units ADD COLUMN position_z FLOAT;

-- Add spatial indexes
CREATE INDEX idx_concepts_position_3d ON concepts 
USING GIST (ST_MakePoint(position_x, position_y, position_z));
```

### Why Not Separate Node/Edge Tables?

**Problems with separate tables:**
1. **Data Duplication**: Would duplicate data already in entity tables
2. **Referential Integrity Issues**: Complex foreign key relationships
3. **Data Consistency Problems**: Two sources of truth for same data
4. **Query Complexity**: Complex joins to get actual entity data

**Benefits of adding coordinates to existing tables:**
1. **No Data Duplication**: Coordinates live with actual data
2. **Referential Integrity**: Natural foreign key relationships
3. **Query Simplicity**: Direct access without complex joins
4. **Performance**: Spatial indexes on actual entity tables
5. **Consistency**: Single source of truth

### Updated Prisma Schema

```prisma
model concepts {
  concept_id             String       @id
  user_id                String
  name                   String
  type                   String
  description            String?
  community_id           String?
  created_at             DateTime     @default(now())
  last_updated_ts        DateTime
  merged_into_concept_id String?
  salience               Float?
  status                 String       @default("active")
  
  // NEW: 3D coordinates for cosmos visualization
  position_x             Float?
  position_y             Float?
  position_z             Float?
  
  communities            communities? @relation(fields: [community_id], references: [community_id])
  concepts               concepts?    @relation("conceptsToconcepts", fields: [merged_into_concept_id], references: [concept_id], onDelete: NoAction, onUpdate: NoAction)
  other_concepts         concepts[]   @relation("conceptsToconcepts")
  users                  users        @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  
  @@index([user_id, status])
  @@index([position_x, position_y, position_z]) // Spatial index
}

model memory_units {
  muid                   String         @id
  user_id                String
  title                  String
  content                String
  creation_ts            DateTime
  ingestion_ts           DateTime       @default(now())
  last_modified_ts       DateTime
  importance_score       Float?
  sentiment_score        Float?
  source_conversation_id String?
  
  // NEW: 3D coordinates for cosmos visualization
  position_x             Float?
  position_y             Float?
  position_z             Float?
  
  media_items            media_items[]
  conversations          conversations? @relation(fields: [source_conversation_id], references: [id])
  users                  users          @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  
  @@index([user_id, creation_ts])
  @@index([position_x, position_y, position_z]) // Spatial index
}

model proactive_prompts {
  prompt_id              String   @id
  user_id                String
  cycle_id               String?
  prompt_text            String
  source_agent           String
  status                 String   @default("pending")
  created_at             DateTime @default(now())
  metadata               Json?
  
  // NEW: 3D coordinates for cosmos visualization
  position_x             Float?
  position_y             Float?
  position_z             Float?
  
  users                  users    @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  
  @@index([user_id, created_at])
  @@index([position_x, position_y, position_z]) // Spatial index
}

// Similar changes for derived_artifacts, communities, etc.
```

---

## Worker Responsibilities

### Current InsightEngine

**Current Responsibilities:**
- **Strategic Analysis**: Analyzes user data using StrategicSynthesisTool
- **Node Creation**: Creates DerivedArtifacts, ProactivePrompts, Communities in PostgreSQL + Neo4j
- **Edge Creation**: Establishes strategic relationships, DERIVED_FROM, MEMBER_OF relationships
- **Graph Updates**: Merges concepts, archives outdated concepts, updates relationships
- **Event Publishing**: Triggers GraphProjectionWorker via `cycle_artifacts_created` events

**Current Process:**
```typescript
// InsightEngine operates on cycles
async processUserCycle(job: Job<InsightJobData>): Promise<void> {
  // 1. Gather comprehensive context
  const { strategicInput } = await this.gatherComprehensiveContext(userId, job.id, cycleDates);
  
  // 2. Strategic synthesis via LLM
  const analysisOutput = await this.strategicSynthesisTool.execute(strategicInput);
  
  // 3. Persist updates to PostgreSQL + Neo4j
  const newEntities = await this.persistStrategicUpdates(userId, analysisOutput, cycleId);
  
  // 4. Publish events to trigger other workers
  await this.publishEvents(userId, newEntities);
}
```

### Current GraphProjectionWorker

**Current Responsibilities:**
- Listens to `new_entities_created` and `cycle_artifacts_created` events
- Fetches entire graph structure from Neo4j
- Generates 3D coordinates via Python dimension reducer
- Stores complete projection as JSON in `user_graph_projections`

**Current Process:**
```typescript
// Current: Full regeneration
private async processJob(job: Job<GraphProjectionEvent>): Promise<void> {
  // 1. Fetch entire graph from Neo4j
  const graphStructure = await this.neo4jService.fetchFullGraphStructure(userId);
  
  // 2. Generate embeddings for all nodes
  const vectors = await this.fetchEmbeddingsFromWeaviate(graphStructure.nodes);
  
  // 3. Reduce to 3D coordinates
  const coordinates3D = await this.callDimensionReducer(vectors);
  
  // 4. Store complete projection as JSON
  await this.storeProjection(projection);
}
```

### New GraphProjectionWorker (Hybrid UMAP + Linear Transformation)

**New Responsibilities:**
- **Hybrid Processing**: UMAP learning + linear transformation phases
- **Matrix Management**: Store and update transformation matrices
- **Phase Detection**: Determine when to run UMAP vs linear transformation
- **Coordinate Management**: Store coordinates in entity tables
- **Event Handling**: Process `new_entities_created` events

**New Process:**
```typescript
// Enhanced GraphProjectionWorker with hybrid approach
async processJob(job: Job<GraphProjectionEvent>): Promise<void> {
  const { data } = job;
  const { userId, entities } = data;
  
  const currentNodeCount = await this.getCurrentNodeCount(userId);
  const totalNodes = currentNodeCount + entities.length;
  
  if (this.shouldRunUMAP(totalNodes)) {
    await this.handleUMAPLearningPhase(userId, entities);
  } else {
    await this.handleLinearTransformationPhase(userId, entities);
  }
}

private shouldRunUMAP(totalNodes: number): boolean {
  return totalNodes >= this.config.minNodesForUMAP && 
         totalNodes <= (this.config.maxNodesForUMAP || Infinity) &&
         totalNodes % this.config.umapInterval === 0;
}

private async handleUMAPLearningPhase(userId: string, entities: Entity[]): Promise<void> {
  // 1. Get all nodes and run UMAP
  const allNodes = await this.getAllNodes(userId);
  const allEmbeddings = await this.getEmbeddingsForNodes(allNodes);
  const umapCoordinates = await this.runUMAP(allEmbeddings);
  
  // 2. Create linear transformation matrix using Ridge regression
  const transformationMatrix = await this.createLinearTransformationMatrix(
    allEmbeddings, 
    umapCoordinates
  );
  
  // 3. Store matrix and update coordinates
  await this.storeTransformationMatrix(userId, transformationMatrix);
  await this.updateAllCoordinates(allNodes, umapCoordinates);
}

private async handleLinearTransformationPhase(userId: string, entities: Entity[]): Promise<void> {
  // 1. Get stored transformation matrix
  const matrix = await this.getTransformationMatrix(userId);
  
  // 2. Transform new embeddings using matrix multiplication
  const embeddings = await this.getEmbeddingsForEntities(entities);
  const coordinates = await this.transformWithLinearMatrix(embeddings, matrix);
  
  // 3. Store new coordinates
  await this.storeNewCoordinates(entities, coordinates);
}
```

### New Worker Types (Optional)

#### Coordinate Update Worker
```typescript
// Dedicated worker for coordinate updates
export class CoordinateUpdateWorker {
  private worker: Worker;
  
  constructor() {
    this.worker = new Worker('coordinate-update-queue', async (job) => {
      const { nodeId, userId, entityType, changes } = job.data;
      await this.updateNodeCoordinates(nodeId, userId, entityType, changes);
    });
  }
}
```

#### Spatial Query Worker
```typescript
// Worker for processing spatial queries asynchronously
export class SpatialQueryWorker {
  private worker: Worker;
  
  constructor() {
    this.worker = new Worker('spatial-query-queue', async (job) => {
      const { query, userId, queryType } = job.data;
      
      switch (queryType) {
        case 'viewport':
          return await this.handleViewportQuery(query, userId);
        case 'time-travel':
          return await this.handleTimeTravelQuery(query, userId);
        case 'filtered':
          return await this.handleFilteredQuery(query, userId);
      }
    });
  }
}
```

---

## API Design

### Current API Endpoints

**Current:**
```typescript
// Single endpoint for full projection
GET /api/v1/graph-projection/latest
// Returns: Complete JSON projection with all nodes and edges
```

### New API Endpoints

#### Unified Query Endpoint
```typescript
// Single endpoint for all query types
POST /api/v1/cosmos/query
{
  // Attribute filters
  "attributeFilters": {
    "entityTypes": ["MemoryUnit", "Concept"],
    "dateRange": {
      "start": "2024-01-01",
      "end": "2024-12-31"
    },
    "importanceRange": {
      "min": 0.7,
      "max": 1.0
    },
    "textSearch": "swimming"
  },
  
  // Spatial filters
  "spatialFilters": {
    "viewport": {
      "min": [0, 0, 0],
      "max": [100, 100, 100]
    },
    "radius": {
      "center": [50, 50, 50],
      "radius": 25
    }
  },
  
  // Set-based filters
  "nodeIds": ["concept-123", "mu-456", "prompt-789"]
}

// Response: Filtered nodes
{
  "success": true,
  "data": [
    {
      "id": "concept-123",
      "type": "Concept",
      "title": "Machine Learning",
      "position_x": 10.5,
      "position_y": 5.2,
      "position_z": -3.1,
      "importance_score": 0.8,
      "created_at": "2024-01-15T10:30:00Z"
    }
  ]
}
```

#### Query Types (MECE Categories)

**1. Attribute-Based Filters:**
- `entityTypes`: Filter by entity type (Concept, MemoryUnit, etc.)
- `dateRange`: Filter by creation date range
- `importanceRange`: Filter by importance score range
- `textSearch`: Filter by title/name text search
- `relationshipCount`: Filter by number of relationships

**2. Spatial Filters:**
- `viewport`: Filter by 3D bounding box
- `radius`: Filter by distance from center point
- `boundingBox`: Filter by custom 3D bounds

**3. Set-Based Filters:**
- `nodeIds`: Filter by predefined set of node IDs (e.g., HRT results)

### Query Processing Logic

#### Unified Query Processing
```typescript
public processCosmosQuery = async (req: Request, res: Response): Promise<void> => {
  const query: CosmosQuery = req.body;
  const userId = req.user?.id || 'dev-user-123';
  
  let sql = 'SELECT * FROM all_entities WHERE 1=1';
  const params: any[] = [];
  let paramIndex = 1;
  
  // Apply attribute filters
  if (query.attributeFilters?.entityTypes) {
    sql += ` AND entity_type = ANY($${paramIndex++})`;
    params.push(query.attributeFilters.entityTypes);
  }
  
  if (query.attributeFilters?.dateRange) {
    sql += ` AND created_at BETWEEN $${paramIndex++} AND $${paramIndex++}`;
    params.push(query.attributeFilters.dateRange.start, query.attributeFilters.dateRange.end);
  }
  
  if (query.attributeFilters?.importanceRange) {
    sql += ` AND importance_score BETWEEN $${paramIndex++} AND $${paramIndex++}`;
    params.push(query.attributeFilters.importanceRange.min, query.attributeFilters.importanceRange.max);
  }
  
  if (query.attributeFilters?.textSearch) {
    sql += ` AND (title ILIKE $${paramIndex++} OR name ILIKE $${paramIndex++})`;
    const searchTerm = `%${query.attributeFilters.textSearch}%`;
    params.push(searchTerm, searchTerm);
  }
  
  // Apply spatial filters
  if (query.spatialFilters?.viewport) {
    const { min, max } = query.spatialFilters.viewport;
    sql += ` AND position_x BETWEEN $${paramIndex++} AND $${paramIndex++}`;
    sql += ` AND position_y BETWEEN $${paramIndex++} AND $${paramIndex++}`;
    sql += ` AND position_z BETWEEN $${paramIndex++} AND $${paramIndex++}`;
    params.push(min[0], max[0], min[1], max[1], min[2], max[2]);
  }
  
  if (query.spatialFilters?.radius) {
    const { center, radius } = query.spatialFilters.radius;
    sql += ` AND SQRT((position_x - $${paramIndex++})^2 + (position_y - $${paramIndex++})^2 + (position_z - $${paramIndex++})^2) <= $${paramIndex++}`;
    params.push(center[0], center[1], center[2], radius);
  }
  
  // Apply set-based filters
  if (query.nodeIds && query.nodeIds.length > 0) {
    sql += ` AND node_id = ANY($${paramIndex++})`;
    params.push(query.nodeIds);
  }
  
  const nodes = await this.postgresService.query(sql, params);
  res.json({ success: true, data: nodes });
};
```

#### Query Examples

**HRT Similarity Search:**
```typescript
// 1. Get HRT results
const hrtResults = await hrtService.search('swimming', userId);

// 2. Query cosmos with HRT node IDs
const query: CosmosQuery = {
  nodeIds: hrtResults.map(r => r.nodeId),
  spatialFilters: { viewport: cameraBounds }
};

const nodes = await cosmosService.processQuery(query);
```

**Viewport + Entity Type:**
```typescript
const query: CosmosQuery = {
  spatialFilters: { viewport: cameraBounds },
  attributeFilters: { entityTypes: ['concept', 'memory_unit'] }
};
```

**Time Range + Importance:**
```typescript
const query: CosmosQuery = {
  attributeFilters: { 
    dateRange: { start: new Date('2024-01-01'), end: new Date('2024-12-31') },
    importanceRange: { min: 0.8, max: 1.0 }
  }
};
```

---

## Frontend Rendering Capabilities

### Current Rendering Architecture

#### 3D Rendering Stack
- **Framework**: React Three Fiber (R3F) + Three.js
- **Canvas**: Full viewport (100vw x 100vh) with high-performance settings
- **Camera**: PerspectiveCamera with OrbitControls
- **Rendering**: WebGL with antialiasing and high-performance preference

#### Current Components

**Graph3D (Main Renderer):**
```typescript
// Current capabilities:
- Full viewport 3D canvas
- Node rendering with importance-based sizing
- Edge rendering with glow effects
- Hover highlighting and connections
- Manual camera controls (WASD + mouse)
- Real-time node/edge visibility controls
```

**NodeMesh (Individual Nodes):**
```typescript
// Current features:
- Sphere geometry with 32x32 segments
- Importance-based scaling (1.2x to 2.8x)
- Entity type color coding:
  * MemoryUnit: Blue (#4488ff)
  * Concept: Green (#44ff44) 
  * Community: Orange (#ff8844)
  * DerivedArtifact: Pink (#ff4488)
  * ProactivePrompt: Purple (#8844ff)
- Hover effects and scaling
- Gentle rotation animation
- Click handling
```

**EdgeMesh (Connections):**
```typescript
// Current features:
- Line geometry with glow effects
- Weight-based opacity
- Animated flowing effects (optional)
- Additive blending for visibility
- Memoized geometry for performance
```

### Current Performance Characteristics

#### Limitations
1. **No Frustum Culling**: Renders all nodes regardless of camera view
2. **No LOD System**: All nodes use same geometry detail
3. **No Instancing**: Each node is a separate mesh
4. **No Spatial Indexing**: Linear search for interactions
5. **Memory Usage**: All nodes loaded in memory at once

#### Current Performance Profile
- **Node Limit**: ~100-500 nodes before performance degradation
- **Edge Limit**: ~1000-2000 edges before slowdown
- **Memory**: ~50-100MB for typical graphs
- **Frame Rate**: 30-60 FPS depending on complexity

### New Rendering Architecture Framework

#### 1. Core Rendering Hierarchy

```typescript
// Main rendering hierarchy
interface CosmosRenderingSystem {
  // Level 1: Core Systems
  sceneManager: SceneManager;
  cameraManager: CameraManager;
  lightingManager: LightingManager;
  
  // Level 2: Procedural Systems
  proceduralGenerator: ProceduralGenerator;
  dynamicLoader: DynamicLoader;
  effectManager: EffectManager;
  
  // Level 3: Node Systems
  nodeRenderer: NodeRenderer;
  connectionRenderer: ConnectionRenderer;
  backgroundRenderer: BackgroundRenderer;
  
  // Level 4: Interaction Systems
  interactionManager: InteractionManager;
  discoveryManager: DiscoveryManager;
  animationManager: AnimationManager;
}
```

#### 2. Scene Management System

```typescript
class SceneManager {
  private scene: THREE.Scene;
  private renderer: THREE.WebGLRenderer;
  private camera: THREE.Camera;
  
  // Layer management for different rendering passes
  private layers = {
    background: new THREE.Group(),      // NASA star field
    environment: new THREE.Group(),     // Cosmic dust, particles
    nodes: new THREE.Group(),           // All node types
    connections: new THREE.Group(),     // Connection lines
    effects: new THREE.Group(),         // Special effects
    ui: new THREE.Group()               // UI elements
  };
  
  // NASA star field integration
  private starField: SphericalStarField;
  private dynamicResolution: DynamicStarFieldResolution;
  private coordinateSystem: CoordinateSystemManager;
  
  constructor(camera: THREE.Camera) {
    this.scene = new THREE.Scene();
    this.camera = camera;
    this.initializeNASAStarField();
    this.setupLayers();
  }
  
  private initializeNASAStarField(): void {
    // Initialize NASA star field system
    this.starField = new SphericalStarField(this.camera);
    this.dynamicResolution = new DynamicStarFieldResolution(this.camera);
    this.coordinateSystem = new CoordinateSystemManager();
  }
  
  private setupLayers(): void {
    // Add NASA star field to background layer
    this.layers.background.add(this.starField.sphere);
    
    // Add other layers
    this.scene.add(this.layers.background);
    this.scene.add(this.layers.environment);
    this.scene.add(this.layers.nodes);
    this.scene.add(this.layers.connections);
    this.scene.add(this.layers.effects);
    this.scene.add(this.layers.ui);
  }
  
  // Layer management
  addToLayer(layer: keyof typeof this.layers, object: THREE.Object3D): void {
    this.layers[layer].add(object);
  }
  
  removeFromLayer(layer: keyof typeof this.layers, object: THREE.Object3D): void {
    this.layers[layer].remove(object);
  }
  
  // Update NASA star field
  update(): void {
    // Update star field for parallax and twinkling
    this.starField.update();
    
    // Update dynamic resolution based on camera distance
    this.dynamicResolution.updateResolution();
    
    // Update star field texture if resolution changed
    const newTexture = this.dynamicResolution.getCurrentStarMap();
    if (newTexture !== this.starField.material.uniforms.starMap.value) {
      this.starField.material.uniforms.starMap.value = newTexture;
    }
  }
  
  // Rendering pipeline
  render(): void {
    this.renderer.render(this.scene, this.camera);
  }
}
```

#### Layered Render Passes and Multi-Pass Effects

- Background Pass: NASA spherical starfield and distant skydome shaders render first, back-face inside sphere, no depth writes.
- Ambient Procedural Pass: low-frequency volumetrics (nebula impostors, dust, sparse starfield) with additive blending and depthWrite=false.
- Node Core Pass: deterministic graph nodes (concepts, memory units, prompts, artifacts) placed from PostgreSQL coordinates; instanced where possible.
- Node Effect Pass: per-node procedural effects (e.g., corona, energy rings, particles) composed over cores; materials favor additive/transparent pipelines.
- Connection Pass: batched/instanced lines or ribbons; culled by frustum and distance LOD.
- UI/HUD Pass: screen-space gizmos, labels, discovery hints.

Notes:
- Multi-pass composition mirrors the original universe system’s approach: distinct buffers of positions/colors per pass, blended for richness without overwhelming a single material.
- Effects can request worker-produced attributes and assemble materials on the main thread only.

#### 3. Procedural Generation Framework

**Inspired by [Across The Multiverse](https://github.com/jesuisundev/acrossthemultiverse) Source Structure:**

The procedural generation system is inspired by the `src/` directory structure from Across The Multiverse, which contains:
- **`src/generation/`** - Procedural universe generation algorithms
- **`src/shaders/`** - GLSL shader files for cosmic effects
- **`src/materials/`** - Material definitions and shader management
- **`src/effects/`** - Particle systems and visual effects
- **`src/objects/`** - 3D object generation and management

```typescript
class ProceduralGenerator {
  private generators = new Map<string, NodeGenerator>();
  private effectGenerators = new Map<string, EffectGenerator>();
  
  constructor() {
    this.initializeGenerators();
  }
  
  private initializeGenerators(): void {
    // Node generators for different types
    this.generators.set('concept', new ConceptGenerator());
    this.generators.set('memory', new MemoryGenerator());
    this.generators.set('prompt', new PromptGenerator());
    this.generators.set('artifact', new ArtifactGenerator());
    this.generators.set('community', new CommunityGenerator());
    
    // Effect generators for cosmic objects (inspired by Across The Multiverse)
    this.effectGenerators.set('galaxy', new GalaxyEffectGenerator());
    this.effectGenerators.set('giant', new GiantStarEffectGenerator());
    this.effectGenerators.set('nebula', new NebulaEffectGenerator());
    this.effectGenerators.set('singularity', new SingularityEffectGenerator());
    this.effectGenerators.set('star', new StarEffectGenerator());
    this.effectGenerators.set('sun', new SunEffectGenerator());
  }
  
  generateNode(nodeData: NodeData): THREE.Object3D {
    const generator = this.generators.get(nodeData.type);
    if (!generator) {
      throw new Error(`No generator found for node type: ${nodeData.type}`);
    }
    
    return generator.generate(nodeData);
  }
  
  generateEffect(effectType: string, nodeData: NodeData): THREE.Object3D {
    const generator = this.effectGenerators.get(effectType);
    if (!generator) {
      throw new Error(`No effect generator found for type: ${effectType}`);
    }
    
    return generator.generate(nodeData);
  }
}
```

#### 3.1 Infinite Space via Cluster Grid

Goal: emulate infinite, performant space by partitioning the world into camera-aligned clusters that are populated, updated, and disposed based on proximity and direction of travel. Inspired by the author’s description of grid-based dynamic loading and pacing the render queue to avoid frame spikes (see "I built the entire universe (and beyond) in JavaScript" [blog](https://www.jesuisundev.com/en/i-built-the-entire-universe-in-javascript/)).

Specifications:
- Parameters: `clusterSize` (e.g., 1500–3000), `renderDistance` (rings: 2–4), `clusterRenderDelayMs` (30–60ms), `maxResidentClusters` (cap), `hysteresis` (retain recently visited).
- Indexing: map of `"x,y,z" -> ClusterHandle` with state {queued | populating | resident}.
- Queueing: breadth-first from camera cell; bias toward view direction; only one populate/display slice at a time to maintain frame budget.
- Disposal: LRU-style removal beyond `renderDistance + hysteresis`; pooled geometry/material reuse.
- Seeding: ambient passes can be generated purely procedurally; deterministic nodes are injected according to stored 3D coordinates within the cluster bounds.

Interface sketch:

```typescript
type ClusterKey = `${number},${number},${number}`;

interface ClusterGridConfig {
  clusterSize: number;
  renderDistance: number;
  clusterRenderDelayMs: number;
  maxResidentClusters: number;
  hysteresis: number;
}

class ClusterGrid {
  constructor(private readonly config: ClusterGridConfig) {}
  update(cameraPosition: THREE.Vector3, cameraDirection: THREE.Vector3): void {}
  enqueue(key: ClusterKey): void {}
  disposeFar(): void {}
}
```

Scheduling:
- Main loop calls `grid.update(...)`; if no populate is in progress, take next key from queue, request worker attributes, and schedule display after `clusterRenderDelayMs`.
- On rapid camera jumps, cancel outstanding queue items and requeue closest-first to avoid wasted work.

Determinism:
- Procedural randomness seeded per `ClusterKey` to ensure stable visuals across sessions; deterministic nodes remain fixed from database coordinates.

#### 3.2 Web Workers & Contracts

Principle: all heavy math (hundreds of thousands of random/spiral computations, color interpolation, turbulence) runs off the main thread. Workers return raw attribute buffers (typed arrays), never Three.js objects.

Worker categories:
- StarfieldWorker: low-density star background attributes (positions, colors) within cluster bounds.
- GalaxyWorker (subtypes: `cyclic`, `spear`): multi-pass spiral generation akin to `_getCyclicAttributesInRandomPosition` with power-law randomness and center→rim color lerp.
- NebulaWorker: cloud/impostor distributions with color pools, falloff fields.
- Giant/WhiteDwarfWorker: high-energy point clouds (multiple passes) with color pools and budgeted vertices.

Message contracts:

Request
```ts
{
  clustersToPopulate: ClusterKey[];
  parameters: { grid: { clusterSize: number } };
  currentUniverse: {
    matters: {
      // per-effect budgets, color pools, spiral params, material ranges
      starfield?: any; galaxy?: any; nebula?: any; giant?: any; strangerthings?: any;
    };
  };
  subtype?: string; // e.g., 'cyclic' | 'spear'
}
```

Response
```ts
{
  [clusterKey: string]: {
    firstPassStarsRandomAttributes?: { positions: Float32Array; colors: Float32Array };
    secondPassStarsRandomAttributes?: { positions: Float32Array; colors: Float32Array };
    thirdPassStarsRandomAttributes?: { positions: Float32Array; colors: Float32Array };
  }
}
```

Scheduling & Backpressure:
- Single-cluster display lock to avoid concurrent heavy DOM/GL state changes; batches are spaced by `clusterRenderDelayMs`.
- On camera chunk change, unfinished requests are ignored on receipt if the key is now outside the active set.

Security & Limits:
- Cap vertices per pass; validate typed array lengths; pool and reuse buffers where applicable to reduce GC churn.


#### 4. Node Generator Interface

```typescript
interface NodeGenerator {
  generate(nodeData: NodeData): THREE.Object3D;
  update(node: THREE.Object3D, nodeData: NodeData): void;
  dispose(node: THREE.Object3D): void;
}

// Base generator with common functionality
abstract class BaseNodeGenerator implements NodeGenerator {
  protected shaderManager: ShaderManager;
  protected geometryManager: GeometryManager;
  protected materialManager: MaterialManager;
  
  constructor() {
    this.shaderManager = new ShaderManager();
    this.geometryManager = new GeometryManager();
    this.materialManager = new MaterialManager();
  }
  
  abstract generate(nodeData: NodeData): THREE.Object3D;
  
  update(node: THREE.Object3D, nodeData: NodeData): void {
    // Common update logic
    this.updatePosition(node, nodeData);
    this.updateScale(node, nodeData);
    this.updateMaterial(node, nodeData);
  }
  
  dispose(node: THREE.Object3D): void {
    // Common disposal logic
    if (node.geometry) node.geometry.dispose();
    if (node.material) {
      if (Array.isArray(node.material)) {
        node.material.forEach(mat => mat.dispose());
      } else {
        node.material.dispose();
      }
    }
  }
  
  protected updatePosition(node: THREE.Object3D, nodeData: NodeData): void {
    if (nodeData.position) {
      node.position.set(nodeData.position.x, nodeData.position.y, nodeData.position.z);
    }
  }
  
  protected updateScale(node: THREE.Object3D, nodeData: NodeData): void {
    const scale = 1 + (nodeData.importance_score || 0) * 2;
    node.scale.setScalar(scale);
  }
  
  protected updateMaterial(node: THREE.Object3D, nodeData: NodeData): void {
    // Update material based on node data
  }
}
```

#### 5. Cosmic Object Mapping

**Based on [Across The Multiverse](https://github.com/jesuisundev/acrossthemultiverse) Cosmic Object Folders:**

The cosmic object mapping is inspired by the specific folder structure in Across The Multiverse:
- **`src/objects/galaxy/`** - Galaxy generation and rendering
- **`src/objects/giant/`** - Giant star implementations
- **`src/objects/nebula/`** - Nebula effects and shaders
- **`src/objects/singularity/`** - Black hole and singularity effects
- **`src/objects/star/`** - Star generation and twinkling
- **`src/objects/sun/`** - Sun-like star implementations

| Effect Type | Visual Characteristics | Color Scheme | Animation | Generation Method |
|-------------|----------------------|--------------|-----------|------------------|
| **Galaxy** | Spiral arms, central bulge, halo | Golden core, blue arms | Slow rotation | Procedural Algorithm |
| **Giant Star** | Intense energy, large size, solar flares | White/yellow/red (temperature) | Intense pulsing, stellar wind | Procedural Algorithm |
| **White Dwarf** | Intense white core, energy rings, pulsation | Pure white to blue gradient | Pulsation, energy field | Procedural Algorithm |
| **Nebula** | Colorful gas clouds, turbulence | Magenta/cyan/yellow | Flowing, turbulent | Procedural Algorithm |
| **Singularity** | Gravitational lensing, event horizon | Black with accretion disk | Gravitational distortion | Procedural Algorithm |
| **Star** | Twinkling, moderate size | White/yellow/orange/red | Gentle twinkling | Procedural Algorithm |
| **Sun** | Solar flares, corona, solar wind | Yellow with flares | Solar activity | Procedural Algorithm |
| **Saturn** | Ringed planet, distinctive appearance | Golden rings, blue-green planet | Slow rotation | Procedural + Texture Skin |
| **Jupiter** | Large gas giant, impressive size | Brown/red bands, Great Red Spot | Atmospheric rotation | Procedural + Texture Skin |
| **Earth** | Blue planet with continents | Blue oceans, green/brown land | Slow rotation | Procedural + Texture Skin |
| **Moon** | Earth's natural satellite | Gray/white surface | Orbital motion | Procedural + Texture Skin |
| **Mars** | Red planet | Red/orange surface | Slow rotation | Procedural + Texture Skin |
| **Mercury** | Small, close to sun | Gray surface | Fast orbital motion | Procedural + Texture Skin |
| **Venus** | Cloud-covered planet | Yellow/white clouds | Slow rotation | Procedural + Texture Skin |
| **Neptune** | Blue ice giant | Deep blue with white clouds | Slow rotation | Procedural + Texture Skin |
| **Pluto** | Dwarf planet | Brown/red surface | Slow orbital motion | Procedural + Texture Skin |

#### 6. NASA Star Maps Background Integration

**Based on [NASA Deep Star Maps 2020](https://svs.gsfc.nasa.gov/4851/) Scientific Visualization:**

The background starfield system uses NASA's high-quality star maps created from 1.7 billion stars using data from Hipparcos-2, Tycho-2, and Gaia Data Release 2. These maps provide scientifically accurate star positions, brightness, and colors for an immersive 3D space environment.

**NASA Star Maps Features:**
- **Data Source**: 1.7 billion stars from multiple astronomical catalogs
- **Resolutions**: 4K, 8K, 16K, 32K, 64K (up to 3.8 GB files)
- **Formats**: OpenEXR half-float format for high dynamic range
- **Coordinate Systems**: Both celestial (ICRF/J2000) and galactic coordinates
- **Constellation Data**: Official IAU constellation boundaries and figures
- **Scientific Accuracy**: Based on real astronomical observations

**Asset Integration:**
```typescript
// Enhanced AssetManager for NASA star maps
class AssetManager {
  private static assets = new Map<string, any>();
  
  static async loadAssets(): Promise<void> {
    // Load NASA star maps
    await this.loadNASAStarMaps();
    
    // Load shaders
    await this.loadShaders();
    
    // Load textures
    await this.loadTextures();
  }
  
  private static async loadNASAStarMaps(): Promise<void> {
    const starMapResolutions = ['4k', '8k', '16k', '32k', '64k'];
    
    for (const resolution of starMapResolutions) {
      // Load celestial coordinate version for 3D mapping
      const celestialMap = await new THREE.TextureLoader().loadAsync(
        `/static/nasa-starmaps/starmap_2020_${resolution}.exr`
      );
      
      // Load galactic coordinate version for different perspectives
      const galacticMap = await new THREE.TextureLoader().loadAsync(
        `/static/nasa-starmaps/starmap_2020_${resolution}_gal.exr`
      );
      
      this.assets.set(`nasaStarmap_${resolution}_celestial`, celestialMap);
      this.assets.set(`nasaStarmap_${resolution}_galactic`, galacticMap);
    }
  }
}
```

**3D Spherical Background System:**
```typescript
class SphericalStarField {
  private sphere: THREE.Mesh;
  private material: THREE.ShaderMaterial;
  private camera: THREE.Camera;
  
  constructor(camera: THREE.Camera) {
    this.camera = camera;
    this.createSphericalBackground();
  }
  
  private createSphericalBackground(): void {
    // Create a large sphere (radius: 1000 units)
    const geometry = new THREE.SphereGeometry(1000, 64, 32);
    
    // Use custom shader material for 3D effect
    this.material = new THREE.ShaderMaterial({
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      uniforms: {
        starMap: { value: AssetManager.getAsset('nasaStarmap_16k_celestial') },
        cameraPosition: { value: new THREE.Vector3() },
        time: { value: 0 },
        parallaxStrength: { value: 0.1 }
      },
      side: THREE.BackSide, // Render inside of sphere
      transparent: true
    });
    
    this.sphere = new THREE.Mesh(geometry, this.material);
  }
  
  private getVertexShader(): string {
    return `
      varying vec3 vWorldPosition;
      varying vec2 vUv;
      
      void main() {
        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
  }
  
  private getFragmentShader(): string {
    return `
      uniform sampler2D starMap;
      uniform vec3 cameraPosition;
      uniform float time;
      uniform float parallaxStrength;
      
      varying vec3 vWorldPosition;
      varying vec2 vUv;
      
      void main() {
        // Calculate direction from camera to sphere surface
        vec3 direction = normalize(vWorldPosition - cameraPosition);
        
        // Convert 3D direction to spherical coordinates (RA, Dec)
        float ra = atan(direction.z, direction.x) / (2.0 * 3.14159) + 0.5;
        float dec = asin(direction.y) / 3.14159 + 0.5;
        
        // Add subtle parallax effect based on camera movement
        vec2 parallaxOffset = (cameraPosition.xy * 0.001) * parallaxStrength;
        vec2 starMapUV = vec2(ra, dec) + parallaxOffset;
        
        // Sample the NASA star map
        vec4 starColor = texture2D(starMap, starMapUV);
        
        // Add subtle twinkling effect
        float twinkle = sin(time * 2.0 + ra * 10.0) * 0.1 + 0.9;
        starColor.rgb *= twinkle;
        
        gl_FragColor = starColor;
      }
    `;
  }
  
  update(): void {
    // Update camera position uniform for parallax effect
    this.material.uniforms.cameraPosition.value.copy(this.camera.position);
    this.material.uniforms.time.value += 0.01;
  }
}
```

**Dynamic Resolution Management:**
```typescript
class DynamicStarFieldResolution {
  private currentResolution: string = '4k';
  private camera: THREE.Camera;
  
  constructor(camera: THREE.Camera) {
    this.camera = camera;
  }
  
  updateResolution(): void {
    const distance = this.camera.position.length();
    
    // Adjust resolution based on camera distance
    if (distance > 500) {
      this.currentResolution = '64k'; // High detail when far
    } else if (distance > 200) {
      this.currentResolution = '32k';
    } else if (distance > 100) {
      this.currentResolution = '16k';
    } else if (distance > 50) {
      this.currentResolution = '8k';
    } else {
      this.currentResolution = '4k'; // Lower detail when close
    }
  }
  
  getCurrentStarMap(): THREE.Texture {
    return AssetManager.getAsset(`nasaStarmap_${this.currentResolution}_celestial`);
  }
}
```

**Coordinate System Integration:**
```typescript
class CoordinateSystemManager {
  private useCelestial: boolean = true;
  
  switchCoordinateSystem(): void {
    this.useCelestial = !this.useCelestial;
    this.updateStarFieldTexture();
  }
  
  private updateStarFieldTexture(): void {
    const resolution = this.getCurrentResolution();
    const coordinateType = this.useCelestial ? 'celestial' : 'galactic';
    const texture = AssetManager.getAsset(`nasaStarmap_${resolution}_${coordinateType}`);
    
    this.starField.material.uniforms.starMap.value = texture;
  }
}
```

#### 7. ArtAstra.js Celestial Objects Integration

**Based on [ArtAstra.js Library](https://github.com/SDEscobedo/artastra) for Realistic Planet Rendering:**

The celestial object system leverages ArtAstra.js for creating scientifically accurate and visually stunning planets, moons, and other celestial bodies. This library provides pre-built Three.js objects with realistic textures and materials.

**Note on Star Generation**: Both ArtAstra.js and Across The Multiverse provide star generation capabilities. We use **Across The Multiverse star generation** (procedural) for individual star nodes and effects, as it offers more sophisticated twinkling effects, dynamic parameters, and better integration with our procedural effect system. ArtAstra.js star generation is not used to avoid duplication.

**ArtAstra.js Features:**
- **Pre-built Celestial Objects**: Sun, Mercury, Venus, Earth, Moon, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto
- **Solar System Creation**: Complete solar system with `CreateSolarSystem()`
- **Texture Assets**: High-quality planet textures and materials
- **Animation Support**: Solar system updates with `UpdateSolarSystem()`
- **MIT License**: Open source and freely usable

**Celestial Object Integration:**
```typescript
// Enhanced AssetManager for ArtAstra.js integration
class CelestialObjectManager {
  private artAstra: any;
  private celestialObjects = new Map<string, THREE.Object3D>();
  
  constructor(THREE: any) {
    // Initialize ArtAstra.js library
    this.artAstra = ArtAstra(THREE);
  }
  
  createCelestialObject(type: string, scale: number, position: THREE.Vector3): THREE.Object3D {
    let celestialObject: THREE.Object3D;
    
    switch (type.toLowerCase()) {
      case 'sun':
        celestialObject = this.artAstra.CreateSun(scale, position);
        break;
      case 'mercury':
        celestialObject = this.artAstra.CreateMercury(scale, position);
        break;
      case 'venus':
        celestialObject = this.artAstra.CreateVenus(scale, position);
        break;
      case 'earth':
        celestialObject = this.artAstra.CreateEarth(scale, position);
        break;
      case 'moon':
        celestialObject = this.artAstra.CreateMoon(scale, position);
        break;
      case 'mars':
        celestialObject = this.artAstra.CreateMars(scale, position);
        break;
      case 'jupiter':
        celestialObject = this.artAstra.CreateJupiter(scale, position);
        break;
      case 'saturn':
        celestialObject = this.artAstra.CreateSaturn(scale, position);
        break;
      case 'uranus':
        celestialObject = this.artAstra.CreateUranus(scale, position);
        break;
      case 'neptune':
        celestialObject = this.artAstra.CreateNeptune(scale, position);
        break;
      case 'pluto':
        celestialObject = this.artAstra.CreatePluto(scale, position);
        break;
      default:
        throw new Error(`Unknown celestial object type: ${type}`);
    }
    
    this.celestialObjects.set(type, celestialObject);
    return celestialObject;
  }
  
  updateSolarSystem(scene: THREE.Scene, camera: THREE.Camera): void {
    this.artAstra.UpdateSolarSystem(scene, camera);
  }
}
```

**Unified Effect System with Texture Library:**
```typescript
// Configurable effect mapping system
interface EffectMapping {
  nodeType?: string;
  importanceRange?: { min: number; max: number };
  customRules?: (nodeData: NodeData) => boolean;
  effectType: string;
  effectCategory: 'procedural' | 'custom';
  textureSkin?: string;  // Optional texture skin from library
  parameters?: Record<string, any>;
}

// Effect categories based on generation method
enum EffectCategory {
  PROCEDURAL = 'procedural',    // Algorithm-based with optional texture skins
  CUSTOM = 'custom'             // User-defined effects
}

// Texture skin library
interface TextureSkin {
  id: string;
  name: string;
  category: 'planet' | 'star' | 'nebula' | 'galaxy' | 'custom';
  diffuseMap?: string;
  normalMap?: string;
  specularMap?: string;
  emissiveMap?: string;
  bumpMap?: string;
  roughnessMap?: string;
  metallicMap?: string;
  opacityMap?: string;
  parameters?: {
    scale?: number;
    rotation?: number;
    offset?: { x: number; y: number };
    tiling?: { x: number; y: number };
  };
}

// Unified texture library system
class TextureLibrary {
  private textures = new Map<string, TextureSkin>();
  private loadedTextures = new Map<string, THREE.Texture>();
  private textureLoader = new THREE.TextureLoader();
  
  constructor() {
    this.initializeDefaultTextures();
  }
  
  private initializeDefaultTextures(): void {
    // ArtAstra.js planet textures
    this.addTextureSkin({
      id: 'jupiter',
      name: 'Jupiter',
      category: 'planet',
      diffuseMap: '/textures/artastra/jupiter_diffuse.jpg',
      normalMap: '/textures/artastra/jupiter_normal.jpg',
      specularMap: '/textures/artastra/jupiter_specular.jpg',
      parameters: { scale: 1.0, tiling: { x: 1, y: 1 } }
    });
    
    this.addTextureSkin({
      id: 'saturn',
      name: 'Saturn',
      category: 'planet',
      diffuseMap: '/textures/artastra/saturn_diffuse.jpg',
      normalMap: '/textures/artastra/saturn_normal.jpg',
      parameters: { scale: 1.0, tiling: { x: 1, y: 1 } }
    });
    
    this.addTextureSkin({
      id: 'earth',
      name: 'Earth',
      category: 'planet',
      diffuseMap: '/textures/artastra/earth_diffuse.jpg',
      normalMap: '/textures/artastra/earth_normal.jpg',
      specularMap: '/textures/artastra/earth_specular.jpg',
      parameters: { scale: 1.0, tiling: { x: 1, y: 1 } }
    });
    
    // Custom procedural textures
    this.addTextureSkin({
      id: 'nebula_blue',
      name: 'Blue Nebula',
      category: 'nebula',
      diffuseMap: '/textures/procedural/nebula_blue.jpg',
      emissiveMap: '/textures/procedural/nebula_blue_emissive.jpg',
      parameters: { scale: 2.0, tiling: { x: 2, y: 2 } }
    });
    
    this.addTextureSkin({
      id: 'galaxy_spiral',
      name: 'Spiral Galaxy',
      category: 'galaxy',
      diffuseMap: '/textures/procedural/galaxy_spiral.jpg',
      emissiveMap: '/textures/procedural/galaxy_spiral_emissive.jpg',
      parameters: { scale: 1.5, tiling: { x: 1, y: 1 } }
    });
  }
  
  addTextureSkin(skin: TextureSkin): void {
    this.textures.set(skin.id, skin);
  }
  
  getTextureSkin(id: string): TextureSkin | undefined {
    return this.textures.get(id);
  }
  
  async loadTexture(skinId: string): Promise<THREE.Texture> {
    if (this.loadedTextures.has(skinId)) {
      return this.loadedTextures.get(skinId)!;
    }
    
    const skin = this.getTextureSkin(skinId);
    if (!skin || !skin.diffuseMap) {
      throw new Error(`Texture skin not found: ${skinId}`);
    }
    
    const texture = await this.textureLoader.loadAsync(skin.diffuseMap);
    this.loadedTextures.set(skinId, texture);
    return texture;
  }
  
  createMaterial(skinId: string, baseMaterial: THREE.Material): THREE.Material {
    const skin = this.getTextureSkin(skinId);
    if (!skin) {
      return baseMaterial;
    }
    
    const material = baseMaterial.clone();
    
    // Apply texture maps
    if (skin.diffuseMap) {
      material.map = this.loadedTextures.get(skinId);
    }
    if (skin.normalMap) {
      material.normalMap = this.textureLoader.load(skin.normalMap);
    }
    if (skin.specularMap) {
      material.specularMap = this.textureLoader.load(skin.specularMap);
    }
    if (skin.emissiveMap) {
      material.emissiveMap = this.textureLoader.load(skin.emissiveMap);
    }
    
    // Apply parameters
    if (skin.parameters) {
      if (skin.parameters.scale) {
        material.map?.repeat.setScalar(skin.parameters.scale);
      }
      if (skin.parameters.rotation) {
        material.map?.rotation = skin.parameters.rotation;
      }
      if (skin.parameters.offset) {
        material.map?.offset.set(skin.parameters.offset.x, skin.parameters.offset.y);
      }
    }
    
    return material;
  }
}

class ConfigurableEffectManager {
  private effectMappings: EffectMapping[] = [];
  private proceduralGenerators = new Map<string, EffectGenerator>();
  private customGenerators = new Map<string, EffectGenerator>();
  private textureLibrary: TextureLibrary;
  
  constructor(THREE: any) {
    this.textureLibrary = new TextureLibrary();
    this.initializeGenerators(THREE);
    this.initializeDefaultMappings();
  }
  
  private initializeGenerators(THREE: any): void {
    // Procedural generators (algorithm-based with texture skin support)
    this.proceduralGenerators.set('galaxy', new GalaxyEffectGenerator(this.textureLibrary));
    this.proceduralGenerators.set('giant', new GiantStarEffectGenerator(this.textureLibrary));
    this.proceduralGenerators.set('whiteDwarf', new WhiteDwarfEffectGenerator(this.textureLibrary));
    this.proceduralGenerators.set('nebula', new NebulaEffectGenerator(this.textureLibrary));
    this.proceduralGenerators.set('singularity', new SingularityEffectGenerator(this.textureLibrary));
    this.proceduralGenerators.set('star', new StarEffectGenerator(this.textureLibrary));
    this.proceduralGenerators.set('sun', new SunEffectGenerator(this.textureLibrary));
    
    // Planet generators (procedural geometry with realistic textures)
    this.proceduralGenerators.set('jupiter', new PlanetEffectGenerator('jupiter', this.textureLibrary));
    this.proceduralGenerators.set('saturn', new PlanetEffectGenerator('saturn', this.textureLibrary));
    this.proceduralGenerators.set('earth', new PlanetEffectGenerator('earth', this.textureLibrary));
    this.proceduralGenerators.set('moon', new PlanetEffectGenerator('moon', this.textureLibrary));
    this.proceduralGenerators.set('mars', new PlanetEffectGenerator('mars', this.textureLibrary));
    this.proceduralGenerators.set('mercury', new PlanetEffectGenerator('mercury', this.textureLibrary));
    this.proceduralGenerators.set('venus', new PlanetEffectGenerator('venus', this.textureLibrary));
    this.proceduralGenerators.set('neptune', new PlanetEffectGenerator('neptune', this.textureLibrary));
    this.proceduralGenerators.set('pluto', new PlanetEffectGenerator('pluto', this.textureLibrary));
  }
  
  private initializeDefaultMappings(): void {
    // Default mappings - can be overridden by user configuration
    this.effectMappings = [
      // High importance nodes get impressive effects
      {
        importanceRange: { min: 0.8, max: 1.0 },
        effectType: 'jupiter',
        effectCategory: 'procedural',
        textureSkin: 'jupiter',
        parameters: { scale: 1.5 }
      },
      // Low importance nodes get subtle effects
      {
        importanceRange: { min: 0.0, max: 0.3 },
        effectType: 'star',
        effectCategory: 'procedural',
        parameters: { twinkle: 0.5 }
      },
      // Communities get distinctive effects
      {
        nodeType: 'Community',
        effectType: 'galaxy',
        effectCategory: 'procedural',
        textureSkin: 'galaxy_spiral',
        parameters: { spiralArms: 3 }
      },
      // Prompts get attention-grabbing effects
      {
        nodeType: 'ProactivePrompt',
        effectType: 'sun',
        effectCategory: 'procedural',
        parameters: { solarFlares: true }
      }
    ];
  }
}

// Enhanced effect generators with texture skin support
class BaseEffectGenerator {
  protected textureLibrary: TextureLibrary;
  
  constructor(textureLibrary: TextureLibrary) {
    this.textureLibrary = textureLibrary;
  }
  
  protected createMaterial(skinId?: string, baseMaterial?: THREE.Material): THREE.Material {
    if (!skinId) {
      return baseMaterial || new THREE.MeshBasicMaterial();
    }
    
    const baseMat = baseMaterial || new THREE.MeshPhongMaterial();
    return this.textureLibrary.createMaterial(skinId, baseMat);
  }
}

class GalaxyEffectGenerator extends BaseEffectGenerator {
  generate(nodeData: NodeData, skinId?: string): THREE.Object3D {
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    const material = this.createMaterial(skinId, new THREE.MeshPhongMaterial({
      emissive: new THREE.Color(0x4444ff),
      transparent: true,
      opacity: 0.8
    }));
    
    const galaxy = new THREE.Mesh(geometry, material);
    
    // Add spiral arms effect
    const spiralArms = nodeData.parameters?.spiralArms || 3;
    this.addSpiralArms(galaxy, spiralArms);
    
    return galaxy;
  }
  
  private addSpiralArms(galaxy: THREE.Object3D, armCount: number): void {
    // Procedural spiral arm generation
    for (let i = 0; i < armCount; i++) {
      const arm = new THREE.Group();
      // Add spiral arm geometry and effects
      galaxy.add(arm);
    }
  }
}

class PlanetEffectGenerator extends BaseEffectGenerator {
  private planetType: string;
  
  constructor(planetType: string, textureLibrary: TextureLibrary) {
    super(textureLibrary);
    this.planetType = planetType;
  }
  
  generate(nodeData: NodeData, skinId?: string): THREE.Object3D {
    const geometry = new THREE.SphereGeometry(1, 64, 32);
    const material = this.createMaterial(skinId || this.planetType, new THREE.MeshPhongMaterial({
      shininess: 30,
      specular: new THREE.Color(0x222222)
    }));
    
    const planet = new THREE.Mesh(geometry, material);
    
    // Add atmospheric effects if specified
    if (nodeData.parameters?.atmospheric) {
      this.addAtmosphere(planet);
    }
    
    return planet;
  }
  
  private addAtmosphere(planet: THREE.Object3D): void {
    const atmosphereGeometry = new THREE.SphereGeometry(1.1, 32, 16);
    const atmosphereMaterial = new THREE.MeshPhongMaterial({
      color: new THREE.Color(0x87CEEB),
      transparent: true,
      opacity: 0.3,
      side: THREE.BackSide
    });
    
    const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
    planet.add(atmosphere);
  }
}

class NebulaEffectGenerator extends BaseEffectGenerator {
  generate(nodeData: NodeData, skinId?: string): THREE.Object3D {
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    const material = this.createMaterial(skinId, new THREE.MeshPhongMaterial({
      emissive: new THREE.Color(0xff44ff),
      transparent: true,
      opacity: 0.6
    }));
    
    const nebula = new THREE.Mesh(geometry, material);
    
    // Add turbulence effect
    const turbulence = nodeData.parameters?.turbulence || 0.7;
    this.addTurbulence(nebula, turbulence);
    
    return nebula;
  }
  
  private addTurbulence(nebula: THREE.Object3D, intensity: number): void {
    // Procedural turbulence effect
    const turbulenceGroup = new THREE.Group();
    // Add turbulence geometry and shaders
    nebula.add(turbulenceGroup);
  }
}

class WhiteDwarfEffectGenerator extends BaseEffectGenerator {
  generate(nodeData: NodeData, skinId?: string): THREE.Object3D {
    // Create the main white dwarf object
    const whiteDwarf = new THREE.Group();
    
    // Core sphere with custom white dwarf shader
    const coreGeometry = new THREE.SphereGeometry(0.3, 32, 16);
    const coreMaterial = this.createWhiteDwarfShader(nodeData.parameters);
    const core = new THREE.Mesh(coreGeometry, coreMaterial);
    whiteDwarf.add(corona);
    
    // Corona layer with intense energy
    const coronaGeometry = new THREE.SphereGeometry(0.6, 32, 16);
    const coronaMaterial = new THREE.MeshPhongMaterial({
      color: new THREE.Color(0xffffff),
      emissive: new THREE.Color(0xffffff),
      emissiveIntensity: 1.5,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
    whiteDwarf.add(corona);
    
    // Energy field with procedural shader
    const energyField = this.createEnergyField(nodeData.parameters);
    whiteDwarf.add(energyField);
    
    // Particle system for stellar wind
    const particleSystem = this.createParticleSystem(nodeData.parameters);
    whiteDwarf.add(particleSystem);
    
    // Pulsation animation
    this.addPulsationAnimation(whiteDwarf, nodeData.parameters);
    
    return whiteDwarf;
  }
  
  private createWhiteDwarfShader(parameters: any): THREE.ShaderMaterial {
    // Based on the actual white dwarf shader from Across The Multiverse
    // Reference: https://github.com/jesuisundev/acrossthemultiverse/blob/main/src/shaders/giant/whitedwarf/fragment.glsl
    
    const vertexShader = `
      varying vec3 vPosition;
      varying vec3 vNormal;
      varying vec2 vUv;
      
      void main() {
        vPosition = position;
        vNormal = normal;
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    
    const fragmentShader = `
      uniform float time;
      uniform float intensity;
      uniform vec3 coreColor;
      uniform vec3 coronaColor;
      
      varying vec3 vPosition;
      varying vec3 vNormal;
      varying vec2 vUv;
      
      void main() {
        // Distance from center
        float dist = length(vPosition);
        
        // Core intensity based on distance
        float coreIntensity = 1.0 - smoothstep(0.0, 0.3, dist);
        
        // Corona intensity
        float coronaIntensity = 1.0 - smoothstep(0.3, 0.6, dist);
        
        // Pulsation effect
        float pulsation = 1.0 + sin(time * 2.0) * 0.2;
        
        // Energy field effect
        float energyField = sin(dist * 10.0 - time * 3.0) * 0.5 + 0.5;
        
        // Combine effects
        vec3 finalColor = mix(coronaColor, coreColor, coreIntensity);
        finalColor += energyField * vec3(0.2, 0.4, 0.8);
        
        // Apply pulsation
        finalColor *= pulsation;
        
        // Add intensity
        finalColor *= intensity;
        
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;
    
    return new THREE.ShaderMaterial({
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: {
        time: { value: 0.0 },
        intensity: { value: parameters?.intensity || 1.0 },
        coreColor: { value: new THREE.Color(0xffffff) },
        coronaColor: { value: new THREE.Color(0x88ccff) }
      },
      transparent: true,
      side: THREE.DoubleSide
    });
  }
  
  private createEnergyField(parameters: any): THREE.Object3D {
    const energyGroup = new THREE.Group();
    
    // Create multiple energy rings
    const ringCount = parameters?.ringCount || 3;
    for (let i = 0; i < ringCount; i++) {
      const ringGeometry = new THREE.RingGeometry(0.8 + i * 0.3, 1.0 + i * 0.3, 32);
      const ringMaterial = new THREE.MeshBasicMaterial({
        color: new THREE.Color(0xffffff),
        emissive: new THREE.Color(0xffffff),
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2;
      ring.rotation.z = (i * Math.PI) / ringCount;
      energyGroup.add(ring);
    }
    
    return energyGroup;
  }
  
  private createParticleSystem(parameters: any): THREE.Object3D {
    const particleCount = parameters?.particleCount || 1000;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);
    
    for (let i = 0; i < particleCount; i++) {
      // Random positions in spherical distribution
      const radius = Math.random() * 2 + 1;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      
      positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = radius * Math.cos(phi);
      
      // White to blue color gradient
      const colorIntensity = Math.random();
      colors[i * 3] = 1.0; // R
      colors[i * 3 + 1] = 0.8 + colorIntensity * 0.2; // G
      colors[i * 3 + 2] = 0.6 + colorIntensity * 0.4; // B
      
      sizes[i] = Math.random() * 0.1 + 0.05;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
      size: 0.1,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    return new THREE.Points(particleGeometry, particleMaterial);
  }
  
  private addPulsationAnimation(whiteDwarf: THREE.Object3D, parameters: any): void {
    const pulsationSpeed = parameters?.pulsationSpeed || 1.0;
    const pulsationIntensity = parameters?.pulsationIntensity || 0.2;
    
    // Animate the core pulsation
    const core = whiteDwarf.children[0] as THREE.Mesh;
    const originalScale = core.scale.clone();
    
    const animate = () => {
      const time = Date.now() * 0.001 * pulsationSpeed;
      const pulsation = 1 + Math.sin(time) * pulsationIntensity;
      core.scale.copy(originalScale).multiplyScalar(pulsation);
      
      // Animate emissive intensity
      if (core.material instanceof THREE.MeshBasicMaterial) {
        core.material.emissiveIntensity = 2.0 + Math.sin(time * 2) * 0.5;
      }
      
      requestAnimationFrame(animate);
    };
    
    animate();
  }
}

class GiantStarEffectGenerator extends BaseEffectGenerator {
  generate(nodeData: NodeData, skinId?: string): THREE.Object3D {
    const giantStar = new THREE.Group();
    
    // Main star body with intense energy
    const starGeometry = new THREE.SphereGeometry(1, 32, 16);
    const starMaterial = new THREE.MeshPhongMaterial({
      color: new THREE.Color(0xff6600),
      emissive: new THREE.Color(0xff3300),
      emissiveIntensity: 1.5,
      shininess: 100
    });
    const star = new THREE.Mesh(starGeometry, starMaterial);
    giantStar.add(star);
    
    // Solar flares
    this.addSolarFlares(giantStar, nodeData.parameters);
    
    // Convection cells
    this.addConvectionCells(giantStar, nodeData.parameters);
    
    // Stellar wind
    this.addStellarWind(giantStar, nodeData.parameters);
    
    return giantStar;
  }
  
  private addSolarFlares(giantStar: THREE.Object3D, parameters: any): void {
    const flareCount = parameters?.flareCount || 8;
    const flareIntensity = parameters?.flareIntensity || 1.0;
    
    for (let i = 0; i < flareCount; i++) {
      const flareGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
      const flareMaterial = new THREE.MeshBasicMaterial({
        color: new THREE.Color(0xffff00),
        emissive: new THREE.Color(0xffff00),
        emissiveIntensity: flareIntensity,
        transparent: true,
        opacity: 0.8
      });
      
      const flare = new THREE.Mesh(flareGeometry, flareMaterial);
      
      // Random position on sphere surface
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      flare.position.set(
        Math.sin(phi) * Math.cos(theta),
        Math.sin(phi) * Math.sin(theta),
        Math.cos(phi)
      );
      
      // Point flare outward from center
      flare.lookAt(flare.position.clone().multiplyScalar(2));
      
      giantStar.add(flare);
    }
  }
  
  private addConvectionCells(giantStar: THREE.Object3D, parameters: any): void {
    const cellCount = parameters?.cellCount || 12;
    
    for (let i = 0; i < cellCount; i++) {
      const cellGeometry = new THREE.SphereGeometry(0.8, 16, 8);
      const cellMaterial = new THREE.MeshPhongMaterial({
        color: new THREE.Color(0xff4400),
        emissive: new THREE.Color(0xff2200),
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide
      });
      
      const cell = new THREE.Mesh(cellGeometry, cellMaterial);
      
      // Random position and rotation
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      cell.position.set(
        Math.sin(phi) * Math.cos(theta) * 0.1,
        Math.sin(phi) * Math.sin(theta) * 0.1,
        Math.cos(phi) * 0.1
      );
      
      cell.rotation.set(
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2
      );
      
      giantStar.add(cell);
    }
  }
  
  private addStellarWind(giantStar: THREE.Object3D, parameters: any): void {
    const windIntensity = parameters?.windIntensity || 1.0;
    const windSpeed = parameters?.windSpeed || 1.0;
    
    // Create particle system for stellar wind
    const particleCount = 500;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
      // Start particles at random positions on sphere surface
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const radius = 1.1 + Math.random() * 0.2;
      
      positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = radius * Math.cos(phi);
      
      // Velocity pointing outward
      const velocity = new THREE.Vector3(
        Math.sin(phi) * Math.cos(theta),
        Math.sin(phi) * Math.sin(theta),
        Math.cos(phi)
      ).multiplyScalar(windSpeed * (0.5 + Math.random() * 0.5));
      
      velocities[i * 3] = velocity.x;
      velocities[i * 3 + 1] = velocity.y;
      velocities[i * 3 + 2] = velocity.z;
      
      // Orange to red color gradient
      const colorIntensity = Math.random();
      colors[i * 3] = 1.0; // R
      colors[i * 3 + 1] = 0.3 + colorIntensity * 0.4; // G
      colors[i * 3 + 2] = 0.0; // B
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
      size: 0.05,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    giantStar.add(particleSystem);
    
    // Animate particles
    const animate = () => {
      const positions = particleGeometry.attributes.position.array as Float32Array;
      const velocities = particleGeometry.attributes.velocity.array as Float32Array;
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += velocities[i * 3] * 0.016;
        positions[i * 3 + 1] += velocities[i * 3 + 1] * 0.016;
        positions[i * 3 + 2] += velocities[i * 3 + 2] * 0.016;
        
        // Reset particles that are too far away
        const distance = Math.sqrt(
          positions[i * 3] ** 2 + 
          positions[i * 3 + 1] ** 2 + 
          positions[i * 3 + 2] ** 2
        );
        
        if (distance > 3) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          positions[i * 3] = 1.1 * Math.sin(phi) * Math.cos(theta);
          positions[i * 3 + 1] = 1.1 * Math.sin(phi) * Math.sin(theta);
          positions[i * 3 + 2] = 1.1 * Math.cos(phi);
        }
      }
      
      particleGeometry.attributes.position.needsUpdate = true;
      requestAnimationFrame(animate);
    };
    
    animate();
  }
}
  
  // Allow users to configure effect mappings
  addEffectMapping(mapping: EffectMapping): void {
    this.effectMappings.push(mapping);
  }
  
  removeEffectMapping(index: number): void {
    this.effectMappings.splice(index, 1);
  }
  
  clearEffectMappings(): void {
    this.effectMappings = [];
  }
  
  // Get effect for a specific node
  getEffectForNode(nodeData: NodeData): { effectType: string; category: string; parameters: any } {
    for (const mapping of this.effectMappings) {
      if (this.mappingMatches(mapping, nodeData)) {
        return {
          effectType: mapping.effectType,
          category: mapping.effectCategory,
          parameters: mapping.parameters || {}
        };
      }
    }
    
    // Default fallback
    return {
      effectType: 'star',
      category: 'procedural',
      parameters: {}
    };
  }
  
  private mappingMatches(mapping: EffectMapping, nodeData: NodeData): boolean {
    // Check node type
    if (mapping.nodeType && nodeData.type !== mapping.nodeType) {
      return false;
    }
    
    // Check importance range
    if (mapping.importanceRange) {
      const importance = nodeData.importance_score || 0;
      if (importance < mapping.importanceRange.min || importance > mapping.importanceRange.max) {
        return false;
      }
    }
    
    // Check custom rules
    if (mapping.customRules && !mapping.customRules(nodeData)) {
      return false;
    }
    
    return true;
  }
}

// Enhanced node generator with configurable effects
class ConfigurableNodeGenerator extends BaseNodeGenerator {
  private effectManager: ConfigurableEffectManager;
  
  constructor(THREE: any) {
    super();
    this.effectManager = new ConfigurableEffectManager(THREE);
  }
  
  generate(nodeData: NodeData): THREE.Object3D {
    // Get effect configuration for this node
    const effectConfig = this.effectManager.getEffectForNode(nodeData);
    
    // Create the appropriate effect based on category
    let effectObject: THREE.Object3D;
    
    switch (effectConfig.category) {
      case 'procedural':
        effectObject = this.createProceduralEffect(effectConfig, nodeData);
        break;
      case 'realistic':
        effectObject = this.createRealisticEffect(effectConfig, nodeData);
        break;
      case 'custom':
        effectObject = this.createCustomEffect(effectConfig, nodeData);
        break;
      default:
        throw new Error(`Unknown effect category: ${effectConfig.category}`);
    }
    
    // Add custom properties for our cosmos system
    effectObject.userData = {
      nodeId: nodeData.id,
      nodeType: nodeData.type,
      importance: nodeData.importance_score,
      effectType: effectConfig.effectType,
      effectCategory: effectConfig.category
    };
    
    return effectObject;
  }
  
  private createProceduralEffect(effectConfig: any, nodeData: NodeData): THREE.Object3D {
    // Procedural effects: algorithm-based, limitless variations
    const generator = this.effectManager.proceduralGenerators.get(effectConfig.effectType);
    if (!generator) {
      throw new Error(`Unknown procedural effect: ${effectConfig.effectType}`);
    }
    
    return generator.generate(nodeData);
  }
  
  private createRealisticEffect(effectConfig: any, nodeData: NodeData): THREE.Object3D {
    // Realistic effects: texture-mapped, authentic appearance
    const generator = this.effectManager.realisticGenerators.get(effectConfig.effectType);
    if (!generator) {
      throw new Error(`Unknown realistic effect: ${effectConfig.effectType}`);
    }
    
    return generator.generate(nodeData);
  }
  
  private createCustomEffect(effectConfig: any, nodeData: NodeData): THREE.Object3D {
    // Custom effects: user-defined generators
    const generator = this.effectManager.customGenerators.get(effectConfig.effectType);
    if (!generator) {
      throw new Error(`Unknown custom effect: ${effectConfig.effectType}`);
    }
    
    return generator.generate(nodeData);
  }
}
```

**Enhanced Procedural Generator:**
```typescript
class ProceduralGenerator {
  private generators = new Map<string, NodeGenerator>();
  private effectGenerators = new Map<string, EffectGenerator>();
  private configurableNodeGenerator: ConfigurableNodeGenerator;
  private effectManager: ConfigurableEffectManager;
  
  constructor(THREE: any) {
    this.configurableNodeGenerator = new ConfigurableNodeGenerator(THREE);
    this.effectManager = new ConfigurableEffectManager(THREE);
    this.initializeGenerators(THREE);
  }
  
  private initializeGenerators(THREE: any): void {
    // Use configurable node generator for all node types
    this.generators.set('concept', this.configurableNodeGenerator);
    this.generators.set('memory', this.configurableNodeGenerator);
    this.generators.set('prompt', this.configurableNodeGenerator);
    this.generators.set('artifact', this.configurableNodeGenerator);
    this.generators.set('community', this.configurableNodeGenerator);
    
    // Effect generators for cosmic objects (inspired by Across The Multiverse)
    this.effectGenerators.set('galaxy', new GalaxyEffectGenerator());
    this.effectGenerators.set('giant', new GiantStarEffectGenerator());
    this.effectGenerators.set('nebula', new NebulaEffectGenerator());
    this.effectGenerators.set('singularity', new SingularityEffectGenerator());
    this.effectGenerators.set('star', new StarEffectGenerator());
    this.effectGenerators.set('sun', new SunEffectGenerator());
  }
  
  // Configuration methods for users
  addEffectMapping(mapping: EffectMapping): void {
    this.effectManager.addEffectMapping(mapping);
  }
  
  removeEffectMapping(index: number): void {
    this.effectManager.removeEffectMapping(index);
  }
  
  clearEffectMappings(): void {
    this.effectManager.clearEffectMappings();
  }
  
  // Get current effect mappings for UI
  getEffectMappings(): EffectMapping[] {
    return this.effectManager.effectMappings;
  }
  
  // Generate node with configurable effects
  generateNode(nodeData: NodeData): THREE.Object3D {
    return this.configurableNodeGenerator.generate(nodeData);
  }
  
  // Direct effect creation methods (for advanced users)
  createRealisticObject(type: string, scale: number, position: THREE.Vector3): THREE.Object3D {
    return this.configurableNodeGenerator.effectManager.realisticGenerators.get(type)?.generate({
      position: { x: position.x, y: position.y, z: position.z },
      importance_score: 1.0
    } as NodeData) || new THREE.Object3D();
  }
  
  createProceduralEffect(effectType: string, nodeData: NodeData): THREE.Object3D {
    const generator = this.effectGenerators.get(effectType);
    if (!generator) {
      throw new Error(`Unknown effect type: ${effectType}`);
    }
    return generator.generate(nodeData);
  }
}
```

**Enhanced Scene Management with Celestial Objects:**
```typescript
class SceneManager {
  private layers = {
    background: new THREE.Group(),      // NASA star field
    environment: new THREE.Group(),     // Cosmic dust, particles
    celestial: new THREE.Group(),       // ArtAstra.js celestial objects
    nodes: new THREE.Group(),           // All node types
    connections: new THREE.Group(),     // Connection lines
    effects: new THREE.Group(),         // Special effects
    ui: new THREE.Group()               // UI elements
  };
  
  private celestialManager: CelestialObjectManager;
  
  constructor(camera: THREE.Camera, THREE: any) {
    this.scene = new THREE.Scene();
    this.camera = camera;
    this.celestialManager = new CelestialObjectManager(THREE);
    this.initializeNASAStarField();
    this.setupLayers();
  }
  
  private setupLayers(): void {
    // Add NASA star field to background layer
    this.layers.background.add(this.starField.sphere);
    
    // Add other layers
    this.scene.add(this.layers.background);
    this.scene.add(this.layers.environment);
    this.scene.add(this.layers.celestial); // NEW: Celestial objects layer
    this.scene.add(this.layers.nodes);
    this.scene.add(this.layers.connections);
    this.scene.add(this.layers.effects);
    this.scene.add(this.layers.ui);
  }
  
  // Add celestial object to scene
  addCelestialObject(celestialObject: THREE.Object3D): void {
    this.layers.celestial.add(celestialObject);
  }
  
  // Update celestial objects (solar system animation)
  update(): void {
    // Update NASA star field
    this.starField.update();
    
    // Update celestial objects (solar system animation)
    this.celestialManager.updateSolarSystem(this.scene, this.camera);
    
    // Update dynamic resolution
    this.dynamicResolution.updateResolution();
  }
}
```

#### 8. Effect Configuration UI

**User-Configurable Effect Mapping System:**

The effect system provides a flexible UI for users to configure how different node types and attributes map to visual effects from both libraries.

**Configuration Interface:**
```typescript
// Effect configuration UI component
interface EffectConfigUI {
  // Add new effect mapping
  addMapping(mapping: EffectMapping): void;
  
  // Edit existing mapping
  editMapping(index: number, mapping: EffectMapping): void;
  
  // Remove mapping
  removeMapping(index: number): void;
  
  // Preview effect for node
  previewEffect(nodeData: NodeData): THREE.Object3D;
  
  // Save configuration
  saveConfiguration(): void;
  
  // Load configuration
  loadConfiguration(config: EffectMapping[]): void;
}

// Example configuration UI
class EffectConfigurationPanel {
  private effectManager: ConfigurableEffectManager;
  private previewScene: THREE.Scene;
  
  constructor(effectManager: ConfigurableEffectManager) {
    this.effectManager = effectManager;
    this.setupUI();
  }
  
  private setupUI(): void {
    // Create UI elements for effect configuration
    this.createMappingForm();
    this.createPreviewPanel();
    this.createLibrarySelector();
  }
  
  private createMappingForm(): void {
    // Form for creating new effect mappings
    const form = document.createElement('div');
    form.innerHTML = `
      <h3>Add Effect Mapping</h3>
      <select id="nodeType">
        <option value="">Any Node Type</option>
        <option value="Concept">Concept</option>
        <option value="MemoryUnit">Memory Unit</option>
        <option value="ProactivePrompt">Proactive Prompt</option>
        <option value="DerivedArtifact">Derived Artifact</option>
        <option value="Community">Community</option>
      </select>
      
      <div>
        <label>Importance Range:</label>
        <input type="range" id="importanceMin" min="0" max="1" step="0.1" value="0">
        <input type="range" id="importanceMax" min="0" max="1" step="0.1" value="1">
      </div>
      
      <select id="effectCategory">
        <option value="procedural">Procedural (Algorithm-based)</option>
        <option value="custom">Custom</option>
      </select>
      
      <select id="effectType">
        <!-- Procedural effects -->
        <option value="galaxy">Galaxy</option>
        <option value="giant">Giant Star</option>
        <option value="nebula">Nebula</option>
        <option value="singularity">Singularity</option>
        <option value="star">Star</option>
        <option value="sun">Sun</option>
        <option value="jupiter">Jupiter</option>
        <option value="saturn">Saturn</option>
        <option value="earth">Earth</option>
        <option value="moon">Moon</option>
        <option value="mars">Mars</option>
        <option value="mercury">Mercury</option>
        <option value="venus">Venus</option>
        <option value="neptune">Neptune</option>
        <option value="pluto">Pluto</option>
      </select>
      
      <select id="textureSkin">
        <option value="">No Texture Skin</option>
        <option value="jupiter">Jupiter Texture</option>
        <option value="saturn">Saturn Texture</option>
        <option value="earth">Earth Texture</option>
        <option value="nebula_blue">Blue Nebula Texture</option>
        <option value="galaxy_spiral">Spiral Galaxy Texture</option>
        <option value="custom">Custom Texture</option>
      </select>
      
      <button onclick="addMapping()">Add Mapping</button>
    `;
    
    document.body.appendChild(form);
  }
  
  private createPreviewPanel(): void {
    // 3D preview panel for testing effects
    const previewContainer = document.createElement('div');
    previewContainer.innerHTML = `
      <h3>Effect Preview</h3>
      <div id="preview-canvas"></div>
      <button onclick="previewEffect()">Preview Effect</button>
    `;
    
    document.body.appendChild(previewContainer);
  }
  
  private createLibrarySelector(): void {
    // Category-specific options
    const categoryOptions = document.createElement('div');
    categoryOptions.innerHTML = `
      <h3>Effect Parameters</h3>
      <div id="procedural-options" style="display: none;">
        <h4>Procedural Effects (Algorithm-based, limitless variations)</h4>
        <label>Spiral Arms (Galaxy):</label>
        <input type="number" id="spiralArms" min="1" max="10" value="3">
        <label>Twinkle Intensity (Star):</label>
        <input type="range" id="twinkle" min="0" max="1" step="0.1" value="0.5">
        <label>Nebula Turbulence:</label>
        <input type="range" id="turbulence" min="0" max="1" step="0.1" value="0.7">
        <label>Solar Flare Intensity (Sun):</label>
        <input type="range" id="solarFlares" min="0" max="1" step="0.1" value="0.8">
      </div>
      
      <div id="realistic-options" style="display: none;">
        <h4>Realistic Effects (Texture-mapped, authentic appearance)</h4>
        <label>Scale Multiplier:</label>
        <input type="range" id="scale" min="0.1" max="3" step="0.1" value="1">
        <label>Atmospheric Effects:</label>
        <input type="checkbox" id="atmospheric" checked>
        <label>Surface Detail Level:</label>
        <select id="detailLevel">
          <option value="low">Low</option>
          <option value="medium" selected>Medium</option>
          <option value="high">High</option>
        </select>
      </div>
      
      <div id="custom-options" style="display: none;">
        <h4>Custom Effects (User-defined)</h4>
        <label>Custom Generator:</label>
        <input type="text" id="customGenerator" placeholder="Generator class name">
        <label>Custom Parameters:</label>
        <textarea id="customParams" placeholder='{"param1": "value1", "param2": 123}'></textarea>
      </div>
    `;
    
    document.body.appendChild(categoryOptions);
  }
}

// Example usage and configuration
const exampleConfigurations = {
  // High importance nodes get impressive effects with realistic textures
  highImportance: {
    importanceRange: { min: 0.8, max: 1.0 },
    effectType: 'jupiter',
    effectCategory: 'procedural',
    textureSkin: 'jupiter',
    parameters: { scale: 1.5, atmospheric: true }
  },
  
  // Low importance nodes get subtle effects without textures
  lowImportance: {
    importanceRange: { min: 0.0, max: 0.3 },
    effectType: 'star',
    effectCategory: 'procedural',
    parameters: { twinkle: 0.5 }
  },
  
  // Communities get distinctive effects with custom textures
  communities: {
    nodeType: 'Community',
    effectType: 'galaxy',
    effectCategory: 'procedural',
    textureSkin: 'galaxy_spiral',
    parameters: { spiralArms: 3, turbulence: 0.7 }
  },
  
  // Prompts get attention-grabbing effects
  prompts: {
    nodeType: 'ProactivePrompt',
    effectType: 'sun',
    effectCategory: 'procedural',
    parameters: { solarFlares: 0.8 }
  },
  
  // Nebula with custom texture
  nebulaWithTexture: {
    nodeType: 'DerivedArtifact',
    effectType: 'nebula',
    effectCategory: 'procedural',
    textureSkin: 'nebula_blue',
    parameters: { turbulence: 0.8 }
  },
  
  // Custom rule example
  customRule: {
    customRules: (nodeData: NodeData) => {
      return nodeData.title?.includes('AI') || false;
    },
    effectType: 'singularity',
    effectCategory: 'procedural',
    parameters: { intensity: 0.8 }
  }
};
```

#### 9. Shader System and Static Assets

**Inspired by [Across The Multiverse](https://github.com/jesuisundev/acrossthemultiverse) Asset Organization:**

The shader system is based on the `static/` and `src/shaders/` directories from Across The Multiverse:

**Static Assets Structure:**
- **`static/nasa-starmaps/`** - NASA Deep Star Maps 2020 in various resolutions
- **`static/artastra-textures/`** - ArtAstra.js planet textures and materials
- **`static/shaders/`** - GLSL shader files for cosmic effects
- **`static/textures/`** - Procedural texture generation
- **`static/audio/`** - Spatial audio for immersive experience
- **`static/models/`** - 3D model assets (if needed)

**Shader File Organization:**
```
src/shaders/
├── galaxy/
│   ├── galaxyVertex.glsl
│   ├── galaxyFragment.glsl
│   └── galaxyGeometry.glsl
├── nebula/
│   ├── nebulaVertex.glsl
│   ├── nebulaFragment.glsl
│   └── nebulaNoise.glsl
├── star/
│   ├── starVertex.glsl
│   ├── starFragment.glsl
│   └── starTwinkle.glsl
└── singularity/
    ├── singularityVertex.glsl
    ├── singularityFragment.glsl
    └── lensing.glsl
```

**Shader Manager Implementation:**
```typescript
class ShaderManager {
  private shaderCache = new Map<string, THREE.ShaderMaterial>();
  
  async loadShader(shaderName: string): Promise<THREE.ShaderMaterial> {
    if (this.shaderCache.has(shaderName)) {
      return this.shaderCache.get(shaderName)!;
    }
    
    // Load shader files from static/shaders/ directory
    const [vertexShader, fragmentShader] = await Promise.all([
      this.loadShaderFile(`static/shaders/${shaderName}/${shaderName}Vertex.glsl`),
      this.loadShaderFile(`static/shaders/${shaderName}/${shaderName}Fragment.glsl`)
    ]);
    
    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: this.getShaderUniforms(shaderName),
      transparent: true,
      blending: THREE.AdditiveBlending
    });
    
    this.shaderCache.set(shaderName, material);
    return material;
  }
  
  private async loadShaderFile(path: string): Promise<string> {
    const response = await fetch(path);
    return await response.text();
  }
  
  private getShaderUniforms(shaderName: string): any {
    switch (shaderName) {
      case 'galaxy':
        return {
          time: { value: 0 },
          color: { value: new THREE.Color('#ffaa00') },
          density: { value: 0.8 }
        };
      case 'nebula':
        return {
          time: { value: 0 },
          color: { value: new THREE.Color('#ff00ff') },
          turbulence: { value: 0.5 }
        };
      case 'star':
        return {
          time: { value: 0 },
          color: { value: new THREE.Color('#ffffff') },
          twinkle: { value: 0.5 }
        };
      case 'singularity':
        return {
          time: { value: 0 },
          color: { value: new THREE.Color('#000000') },
          gravity: { value: 0.8 }
        };
      default:
        return {};
    }
  }
}
```

#### 7. Dynamic Loading System

```typescript
class DynamicLoader {
  private loadedChunks = new Map<string, CosmosChunk>();
  private loadingQueue: string[] = [];
  private sceneManager: SceneManager;
  private proceduralGenerator: ProceduralGenerator;
  
  constructor(sceneManager: SceneManager, proceduralGenerator: ProceduralGenerator) {
    this.sceneManager = sceneManager;
    this.proceduralGenerator = proceduralGenerator;
  }
  
  async updateLoading(camera: THREE.Camera, query: CosmosQuery): Promise<void> {
    // Calculate visible chunks
    const visibleChunks = this.calculateVisibleChunks(camera);
    
    // Load new chunks
    const chunksToLoad = visibleChunks.filter(chunkId => 
      !this.loadedChunks.has(chunkId)
    );
    
    // Unload distant chunks
    const chunksToUnload = Array.from(this.loadedChunks.keys())
      .filter(chunkId => !visibleChunks.includes(chunkId));
    
    // Process loading queue
    await this.processLoadingQueue(chunksToLoad, chunksToUnload);
  }
  
  private async processLoadingQueue(
    chunksToLoad: string[], 
    chunksToUnload: string[]
  ): Promise<void> {
    // Load new chunks
    for (const chunkId of chunksToLoad) {
      const chunk = await this.loadChunk(chunkId);
      this.loadedChunks.set(chunkId, chunk);
      this.addChunkToScene(chunk);
    }
    
    // Unload distant chunks
    for (const chunkId of chunksToUnload) {
      const chunk = this.loadedChunks.get(chunkId);
      if (chunk) {
        this.removeChunkFromScene(chunk);
        this.disposeChunk(chunk);
        this.loadedChunks.delete(chunkId);
      }
    }
  }
}
```

#### 8. Build Configuration and Asset Management

**Based on [Across The Multiverse](https://github.com/jesuisundev/acrossthemultiverse) Build System:**

The build configuration is inspired by the `bundler/` directory and `package.json` from Across The Multiverse:

**Bundler Configuration:**
```javascript
// bundler/webpack.config.js (inspired by Across The Multiverse)
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'cosmos.bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.glsl$/,
        use: 'raw-loader'
      },
      {
        test: /\.(png|jpg|gif|hdr)$/,
        use: 'file-loader'
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    }),
    new CopyWebpackPlugin({
      patterns: [
        { from: 'static/shaders', to: 'shaders' },
        { from: 'static/textures', to: 'textures' },
        { from: 'static/audio', to: 'audio' }
      ]
    })
  ]
};
```

**Package.json Dependencies:**
```json
{
  "dependencies": {
    "three": "^0.158.0",
    "@react-three/fiber": "^8.15.0",
    "@react-three/drei": "^9.88.0",
    "simplex-noise": "^4.0.1"
  },
  "devDependencies": {
    "webpack": "^5.88.0",
    "raw-loader": "^4.0.2",
    "file-loader": "^6.2.0",
    "copy-webpack-plugin": "^11.0.0"
  }
}
```

**Asset Loading Strategy:**
```typescript
// Based on Across The Multiverse static asset management
class AssetManager {
  private static assets = new Map<string, any>();
  
  static async loadAssets(): Promise<void> {
    // Load shaders
    await this.loadShaders();
    
    // Load textures
    await this.loadTextures();
    
    // Load audio
    await this.loadAudio();
  }
  
  private static async loadShaders(): Promise<void> {
    const shaderNames = ['galaxy', 'nebula', 'star', 'singularity', 'sun', 'giant'];
    
    for (const name of shaderNames) {
      const [vertex, fragment] = await Promise.all([
        fetch(`/shaders/${name}/${name}Vertex.glsl`).then(r => r.text()),
        fetch(`/shaders/${name}/${name}Fragment.glsl`).then(r => r.text())
      ]);
      
      this.assets.set(`${name}Shader`, { vertex, fragment });
    }
  }
  
  private static async loadTextures(): Promise<void> {
    const textureNames = ['noise', 'starfield', 'nebula'];
    
    for (const name of textureNames) {
      const texture = await new THREE.TextureLoader().loadAsync(`/textures/${name}.png`);
      this.assets.set(`${name}Texture`, texture);
    }
  }
  
  static getAsset(name: string): any {
    return this.assets.get(name);
  }
}
```

#### 9. Main Cosmos Component

```typescript
class CosmosRenderer {
  private sceneManager: SceneManager;
  private cameraManager: CameraManager;
  private proceduralGenerator: ProceduralGenerator;
  private dynamicLoader: DynamicLoader;
  private interactionManager: InteractionManager;
  private discoveryManager: DiscoveryManager;
  private animationManager: AnimationManager;
  
  constructor() {
    this.initializeSystems();
  }
  
  private initializeSystems(): void {
    this.sceneManager = new SceneManager();
    this.cameraManager = new CameraManager();
    this.proceduralGenerator = new ProceduralGenerator();
    this.dynamicLoader = new DynamicLoader(this.sceneManager, this.proceduralGenerator);
    this.interactionManager = new InteractionManager();
    this.discoveryManager = new DiscoveryManager();
    this.animationManager = new AnimationManager();
  }
  
  async render(query: CosmosQuery): Promise<void> {
    // Update camera
    this.cameraManager.update();
    
    // Update NASA star field (parallax, twinkling, resolution)
    this.sceneManager.update();
    
    // Update dynamic loading
    await this.dynamicLoader.updateLoading(this.cameraManager.camera, query);
    
    // Update interactions
    this.interactionManager.update();
    
    // Update discovery
    this.discoveryManager.update();
    
    // Update animations
    this.animationManager.update();
    
    // Render scene
    this.sceneManager.render();
  }
}
```

### Enhanced Rendering Capabilities Summary

#### What's New:
1. **NASA Star Field Background**: Scientifically accurate starfield using [NASA Deep Star Maps 2020](https://svs.gsfc.nasa.gov/4851/) with 1.7 billion stars
2. **ArtAstra.js Celestial Objects**: Realistic planets, moons, and celestial bodies using [ArtAstra.js library](https://github.com/SDEscobedo/artastra)
3. **3D Spherical Mapping**: Converts flat star maps into immersive 3D spherical background
4. **Dynamic Resolution**: Automatically adjusts star map resolution based on camera distance (4K to 64K)
5. **Parallax Effects**: Subtle movement and twinkling based on camera position
6. **Procedural Generation**: Dynamic creation of cosmic objects based on node data
7. **Layer-Based Rendering**: Efficient rendering with proper depth ordering
8. **Dynamic Loading**: Load/unload nodes based on camera position
9. **Cosmic Effects**: Galaxy, nebula, star, and singularity effects
10. **Modular Architecture**: Easy to add new node types and effects
11. **Performance Optimization**: LOD system, instancing, frustum culling

#### Performance Improvements:
- **Node Limit**: 10,000+ nodes with viewport culling
- **Memory Usage**: 80% reduction with dynamic loading
- **Frame Rate**: Consistent 60 FPS with LOD system
- **Loading Time**: 90% faster with spatial queries
- **Visual Quality**: Immersive cosmic effects for each node type

#### NASA Star Field Benefits:
1. **Scientific Accuracy**: Based on real astronomical data from 1.7 billion stars
2. **High Quality**: Available up to 64K resolution (3.8 GB files) for maximum detail
3. **Multiple Coordinate Systems**: Both celestial (ICRF/J2000) and galactic coordinates
4. **Constellation Integration**: Official IAU constellation boundaries and figures
5. **3D Immersion**: Spherical mapping creates realistic space environment
6. **Performance Optimized**: Dynamic resolution based on camera distance
7. **Parallax Effects**: Subtle movement and twinkling for depth perception

#### Unified Effect System Benefits:
1. **Single Architecture**: All effects use the same procedural system with optional texture skins
2. **User Configurable**: No hardcoded node-to-effect mappings - fully customizable
3. **Flexible Mapping Rules**: Support for node type, importance range, and custom rules
4. **Texture Library Integration**: ArtAstra.js textures integrated into procedural effects
5. **Real-time Preview**: Test effects before applying to the entire cosmos
6. **Easy Extension**: Simple to add new effects, textures, or custom generators
7. **Performance Optimized**: Efficient rendering with unified architecture
8. **Developer Friendly**: Clean API for both simple and advanced use cases
9. **Future Proof**: Modular architecture supports new effects and texture libraries

#### Procedural Effects with Texture Skins Benefits:
1. **Limitless Variations**: Each generation creates unique visual results
2. **Dynamic Parameters**: Fine-tune effects with sliders and controls
3. **Texture Flexibility**: Apply any texture skin to any procedural effect
4. **Immersive Experience**: Creates true "space travel" feeling
5. **Customizable**: Easy to adjust parameters and textures for different visual styles
6. **Memory Efficient**: Textures loaded on-demand, procedural effects generated in real-time
7. **Real-time Generation**: Effects can be generated on-the-fly with different textures
8. **Scalable**: Works well with different node counts and importance levels
9. **Texture Library**: Easy to add new textures from any source (ArtAstra.js, custom, etc.)

#### Texture Library Benefits:
1. **Unified Management**: Single system for all texture assets
2. **ArtAstra.js Integration**: High-quality planet textures from ArtAstra.js
3. **Custom Textures**: Easy to add custom textures for any effect type
4. **Multiple Map Types**: Support for diffuse, normal, specular, emissive, bump maps
5. **Parameter Control**: Scale, rotation, offset, and tiling controls
6. **Lazy Loading**: Textures loaded only when needed
7. **Memory Management**: Efficient texture caching and disposal
8. **Extensible**: Simple to add new texture categories and sources

#### Architecture Benefits:
1. **Extensibility**: Easy to add new node types and effects
2. **Performance**: Layer-based rendering and dynamic loading
3. **Flexibility**: Can switch between simple and complex effects
4. **Maintainability**: Clear separation of concerns and consistent interfaces
5. **Scientific Foundation**: Real astronomical data provides authentic space experience

---

## PM2 Service Implications

### Current PM2 Configuration

```javascript
// ecosystem.config.js
{
  name: 'graph-projection-worker',
  script: './workers/graph-projection-worker/dist/index.js',
  instances: 1,
  exec_mode: 'fork',
  watch: false,
  // ... logging config
}
```

### Current Worker Behavior

**Current Process:**
1. **Triggers**: Listens to `new_entities_created` and `cycle_artifacts_created` events
2. **Process**: Generates complete 3D projection as large JSON
3. **Storage**: Stores entire projection in `user_graph_projections.projection_data`
4. **Output**: Single large JSON object for frontend

### New PM2 Configuration

#### Phase 1: Dual-Mode Operation (Backward Compatibility)

```javascript
// ecosystem.config.js
module.exports = {
  apps: [
    // ... existing apps
    {
      name: 'graph-projection-worker',
      script: './workers/graph-projection-worker/dist/index.js',
      instances: 1,
      exec_mode: 'fork',
      watch: false,
      ...baseConfig,
      // NEW: Environment variables for new features
      env: {
        ...baseEnv,
        ENABLE_NEW_STORAGE: 'true',
        ENABLE_LEGACY_STORAGE: 'true', // During migration
        ENABLE_INCREMENTAL_UPDATES: 'true',
        MAX_BATCH_SIZE: '100',
        COORDINATE_CACHE_TTL: '3600'
      },
      env_production: {
        NODE_ENV: 'production',
        ...baseEnv,
        ENABLE_NEW_STORAGE: 'true',
        ENABLE_LEGACY_STORAGE: 'false', // Disable after migration
        ENABLE_INCREMENTAL_UPDATES: 'true',
        MAX_BATCH_SIZE: '500',
        COORDINATE_CACHE_TTL: '7200'
      }
    }
  ]
};
```

### Worker Transformation

#### New InsightEngine Process
```typescript
// InsightEngine continues to create nodes and edges
async processUserCycle(job: Job<InsightJobData>): Promise<void> {
  // 1. Strategic analysis (unchanged)
  const analysisOutput = await this.strategicSynthesisTool.execute(strategicInput);
  
  // 2. Persist to PostgreSQL + Neo4j (unchanged)
  const newEntities = await this.persistStrategicUpdates(userId, analysisOutput, cycleId);
  
  // 3. Publish events for GraphProjectionWorker
  await this.publishEvents(userId, newEntities);
  
  // NEW: InsightEngine now triggers incremental coordinate updates
  await this.graphQueue.add('new_entities_created', {
    type: 'new_entities_created',
    userId,
    source: 'InsightEngine',
    entities: newEntities
  });
}
```

#### Current Worker Process
```typescript
// Current: Full regeneration
private async processJob(job: Job<GraphProjectionEvent>): Promise<void> {
  // 1. Fetch entire graph from Neo4j
  const graphStructure = await this.neo4jService.fetchFullGraphStructure(userId);
  
  // 2. Generate embeddings for all nodes
  const vectors = await this.fetchEmbeddingsFromWeaviate(graphStructure.nodes);
  
  // 3. Reduce to 3D coordinates
  const coordinates3D = await this.callDimensionReducer(vectors);
  
  // 4. Store complete projection as JSON
  await this.storeProjection(projection);
}
```

#### New Worker Process
```typescript
// New: Incremental updates
private async processJob(job: Job<GraphProjectionEvent>): Promise<void> {
  const { data } = job;
  
  if (data.type === 'new_entities_created') {
    // NEW: Handle individual entity updates
    await this.handleIncrementalUpdate(data);
  } else if (data.type === 'cycle_artifacts_created') {
    // LEGACY: Full regeneration for major changes
    await this.handleFullRegeneration(data);
  }
}

private async handleIncrementalUpdate(data: NewEntitiesCreatedEvent): Promise<void> {
  console.log(`[GraphProjectionWorker] Processing incremental update for ${data.entities.length} entities`);
  
  for (const entity of data.entities) {
    // 1. Get entity data from appropriate table
    const entityData = await this.getEntityData(entity.id, entity.type);
    
    // 2. Get 768D embedding from Weaviate
    const embedding = await this.getEntityEmbedding(entity.id, entity.type);
    
    // 3. Calculate position using dimension reducer
    const position = await this.calculateIncrementalPosition(embedding, entityData);
    
    // 4. Store 3D coordinates in entity table
    await this.updateEntityCoordinates(entity.id, entity.type, position);
  }
  
  // 5. Update projection metadata
  await this.updateProjectionMetadata(data.userId);
}

private async calculateIncrementalPosition(embedding: number[], entityData: any): Promise<[number, number, number]> {
  // Use hybrid UMAP + linear transformation approach
  const currentNodeCount = await this.getCurrentNodeCount(entityData.userId);
  const totalNodes = currentNodeCount + 1; // +1 for the new node
  
  if (this.shouldRunUMAP(totalNodes)) {
    // UMAP Learning Mode: Learn manifold structure + create transformation matrix
    return await this.runUMAPLearningForNewNode(entityData.userId, embedding);
  } else {
    // Linear Transformation Mode: Use stored matrix for fast positioning
    return await this.runLinearTransformationForNewNode(entityData.userId, embedding);
  }
}

private async updateEntityCoordinates(entityId: string, entityType: string, position: [number, number, number]): Promise<void> {
  const [x, y, z] = position;
  
  switch (entityType) {
    case 'Concept':
      await this.databaseService.prisma.concepts.update({
        where: { concept_id: entityId },
        data: { position_x: x, position_y: y, position_z: z }
      });
      break;
    case 'MemoryUnit':
      await this.databaseService.prisma.memory_units.update({
        where: { muid: entityId },
        data: { position_x: x, position_y: y, position_z: z }
      });
      break;
    case 'ProactivePrompt':
      await this.databaseService.prisma.proactive_prompts.update({
        where: { prompt_id: entityId },
        data: { position_x: x, position_y: y, position_z: z }
      });
      break;
    case 'DerivedArtifact':
      await this.databaseService.prisma.derived_artifacts.update({
        where: { artifact_id: entityId },
        data: { position_x: x, position_y: y, position_z: z }
      });
      break;
    case 'Community':
      await this.databaseService.prisma.communities.update({
        where: { community_id: entityId },
        data: { position_x: x, position_y: y, position_z: z }
      });
      break;
    // ... handle other entity types
  }
}
```

### Migration Strategy

#### Gradual Migration Process
```bash
# Step 1: Deploy with dual-mode enabled
pm2 restart graph-projection-worker

# Step 2: Run migration script
node scripts/migrate-projections.js

# Step 3: Verify new storage is working
node scripts/verify-new-storage.js

# Step 4: Disable legacy storage
pm2 restart graph-projection-worker --update-env ENABLE_LEGACY_STORAGE=false

# Step 5: Enable incremental updates
pm2 restart graph-projection-worker --update-env ENABLE_INCREMENTAL_UPDATES=true
```

#### Migration Script
```typescript
// scripts/migrate-projections.js
async function migrateAllProjections() {
  console.log('🔄 Starting projection migration...');
  
  // Get all users with projections
  const users = await prisma.users.findMany({
    where: {
      user_graph_projections: {
        some: {}
      }
    },
    select: { user_id: true }
  });
  
  for (const user of users) {
    console.log(`Migrating user ${user.user_id}...`);
    
    // Get latest projection
    const projection = await prisma.user_graph_projections.findFirst({
      where: { user_id: user.user_id },
      orderBy: { created_at: 'desc' }
    });
    
    if (projection) {
      await migrateUserProjection(user.user_id, projection);
    }
  }
  
  console.log('✅ Migration completed');
}

async function migrateUserProjection(userId: string, projection: any) {
  const projectionData = projection.projection_data;
  
  // Migrate nodes to their respective entity tables
  for (const node of projectionData.nodes || []) {
    await updateEntityCoordinates(node.id, node.type, {
      position_x: node.position[0],
      position_y: node.position[1],
      position_z: node.position[2]
    });
  }
}
```

### Monitoring & Health Checks

#### Enhanced PM2 Monitoring
```bash
# Monitor worker health
pm2 monit

# Check specific worker logs
pm2 logs graph-projection-worker --lines 100

# Restart worker if needed
pm2 restart graph-projection-worker

# Check queue status
node scripts/check-queue-status.js
```

---

## Migration Strategy

### Phase 1: Schema Updates (Week 1)

#### Database Schema Changes
```sql
-- Add 3D coordinates to existing entity tables
ALTER TABLE concepts ADD COLUMN position_x FLOAT;
ALTER TABLE concepts ADD COLUMN position_y FLOAT;
ALTER TABLE concepts ADD COLUMN position_z FLOAT;

ALTER TABLE memory_units ADD COLUMN position_x FLOAT;
ALTER TABLE memory_units ADD COLUMN position_y FLOAT;
ALTER TABLE memory_units ADD COLUMN position_z FLOAT;

-- Add spatial indexes
CREATE INDEX idx_concepts_position_3d ON concepts 
USING GIST (ST_MakePoint(position_x, position_y, position_z));

-- Add metadata table for projection tracking
CREATE TABLE projection_metadata (
  user_id TEXT PRIMARY KEY,
  last_updated TIMESTAMP DEFAULT NOW(),
  total_nodes INTEGER DEFAULT 0,
  storage_mode VARCHAR(20) DEFAULT 'legacy'
);
```

### Phase 2: Dual-Mode Worker (Week 2)

#### Worker Configuration
```typescript
// workers/graph-projection-worker/src/GraphProjectionWorker.ts
export class GraphProjectionWorker {
  private enableNewStorage: boolean;
  private enableLegacyStorage: boolean;
  
  constructor() {
    this.enableNewStorage = process.env.ENABLE_NEW_STORAGE === 'true';
    this.enableLegacyStorage = process.env.ENABLE_LEGACY_STORAGE === 'true';
  }
  
  private async processJob(job: Job<GraphProjectionEvent>): Promise<void> {
    const { data } = job;
    
    if (data.type === 'new_entities_created') {
      await this.handleIncrementalUpdate(data);
    } else if (data.type === 'cycle_artifacts_created') {
      if (this.enableNewStorage) {
        await this.handleNewFullRegeneration(data);
      }
      if (this.enableLegacyStorage) {
        await this.handleLegacyFullRegeneration(data);
      }
    }
  }
}
```

### Phase 3: API Migration (Week 3)

#### New API Endpoints
```typescript
// apps/api-gateway/src/controllers/cosmos.controller.ts
export class CosmosController {
  // NEW: Unified query endpoint
  public processCosmosQuery = async (req: Request, res: Response): Promise<void> => {
    const query: CosmosQuery = req.body;
    const userId = req.user?.id || 'dev-user-123';
    
    const nodes = await this.cosmosService.processCosmosQuery(query, userId);
    res.json({ success: true, data: nodes });
  };
}
```

### Phase 4: Frontend Migration (Week 4)

#### Gradual Frontend Updates
```typescript
// apps/web-app/src/components/cosmos/Graph3D.tsx
const Graph3D: React.FC = () => {
  const [useNewAPI, setUseNewAPI] = useState(false);
  const [nodes, setNodes] = useState<Node3D[]>([]);
  
  const loadNodes = async () => {
    if (useNewAPI) {
      // NEW: Use unified query system
      const query: CosmosQuery = {
        spatialFilters: { viewport: calculateViewportBounds(camera) }
      };
      const nodes = await cosmosService.processCosmosQuery(query);
      setNodes(nodes);
    } else {
      // LEGACY: Use full projection
      const projection = await cosmosService.getLatestProjection();
      setNodes(projection.nodes);
    }
  };
  
  return (
    <Canvas>
      <Suspense fallback={null}>
        {nodes.map(node => (
          <NodeMesh key={node.id} node={node} />
        ))}
      </Suspense>
    </Canvas>
  );
};
```

---

## Performance Implications

### Current Performance Issues

#### Memory Usage
- **Current**: 50-100MB per user for large JSON projections
- **New**: 5-10MB per user with spatial queries
- **Improvement**: 80-90% memory reduction

#### Processing Time
- **Current**: 30-60 seconds for full projection regeneration
- **New**: 1-3 seconds for incremental updates
- **Improvement**: 95% faster processing

#### Database Load
- **Current**: Single large JSON read/write operations
- **New**: Multiple small spatial queries
- **Improvement**: Better query performance with indexes

### New Performance Characteristics

#### Spatial Query Performance
```sql
-- Optimized spatial queries with PostGIS
EXPLAIN ANALYZE
SELECT node_id, title, entity_type,
       ST_Distance(position, ST_MakePoint($x, $y, $z)) as distance
FROM concepts
WHERE user_id = $1
  AND ST_DWithin(position, ST_MakePoint($x, $y, $z), $radius)
ORDER BY distance
LIMIT 100;

-- Query Plan: Index Scan using idx_concepts_position_3d
-- Execution Time: 2.5ms (vs 500ms+ for full table scan)
```

#### Frontend Rendering Performance
- **Viewport Culling**: Only render visible nodes (90% reduction)
- **LOD System**: Reduce geometry complexity for distant nodes
- **Instanced Rendering**: Batch similar nodes for better performance
- **Dynamic Loading**: Load/unload nodes based on camera movement

#### Scalability Improvements
- **Node Limit**: 100-500 nodes → 10,000+ nodes
- **User Limit**: 10-50 concurrent users → 500+ concurrent users
- **Response Time**: 2-5 seconds → 200-500ms
- **Memory Usage**: 50-100MB → 5-10MB per user

---

## Implementation Timeline

### Week 1: Foundation
- [ ] **Database Schema Updates**
  - Add 3D coordinate columns to entity tables
  - Create spatial indexes
  - Add transformation_matrix column to user_graph_projections table
  - Update Prisma schema

- [ ] **Worker Infrastructure**
  - Implement hybrid UMAP + linear transformation approach
  - Add transformation matrix management
  - Implement phase detection logic (UMAP vs linear)
  - Add environment variable configuration
  - Update PM2 configuration

### Week 2: Backend APIs & Dimension Reducer
- [ ] **New API Endpoints**
  - Unified query endpoint (`/api/v1/cosmos/query`)
  - Legacy compatibility endpoint

- [ ] **Dimension Reducer Service Updates**
  - Add `/umap-and-create-matrix` endpoint
  - Add `/transform-with-linear-matrix` endpoint
  - Implement Ridge regression for matrix creation
  - Add transformation matrix storage

- [ ] **Service Layer**
  - Implement CosmosService with new query methods
  - Add spatial query optimization
  - Implement time travel logic
  - Add caching layer

### Week 3: Frontend Integration
- [ ] **Rendering Components**
  - Update Graph3D for viewport-based rendering
  - Implement TimeTravelCamera component
  - Add LOD system for performance
  - Create spatial query hooks

- [ ] **NASA Star Field Integration**
  - Download and integrate [NASA Deep Star Maps 2020](https://svs.gsfc.nasa.gov/4851/)
  - Implement SphericalStarField class with 3D mapping
  - Add dynamic resolution management (4K to 64K)
  - Create parallax and twinkling shader effects
  - Integrate coordinate system switching (celestial/galactic)

- [ ] **Modular Effect System Implementation**
  - Install and integrate [ArtAstra.js library](https://github.com/SDEscobedo/artastra)
  - Install and integrate [Across The Multiverse](https://github.com/jesuisundev/acrossthemultiverse) effects
  - Implement ConfigurableEffectManager for flexible effect mapping
  - Create ConfigurableNodeGenerator for dynamic effect selection
  - Build EffectConfigurationPanel UI for user customization
  - Add real-time effect preview system
  - Implement custom effect support for future extensions
  - Download and integrate texture assets from both libraries

- [ ] **User Interface**
  - Add time travel controls
  - Implement query input interface
  - Add performance monitoring dashboard
  - Create migration status indicators

### Week 4: Testing & Optimization
- [ ] **Performance Testing**
  - Load testing with large graphs (10,000+ nodes)
  - Memory usage profiling
  - Database query optimization
  - Frontend rendering optimization

- [ ] **Integration Testing**
  - End-to-end time travel flows
  - Spatial query accuracy testing
  - Cross-browser compatibility
  - Mobile responsiveness

### Week 5: Migration & Cleanup
- [ ] **Data Migration**
  - Run migration scripts for existing projections
  - Verify data integrity
  - Performance comparison testing
  - User acceptance testing

- [ ] **Legacy Cleanup**
  - Remove old JSON storage code
  - Clean up dual-mode worker logic
  - Remove unused API endpoints
  - Update documentation

### Success Criteria

#### Performance Targets
- [ ] **Spatial Queries**: < 10ms average response time
- [ ] **Incremental Updates**: < 1 second processing time
- [ ] **Frontend Rendering**: 60 FPS with 10,000+ nodes
- [ ] **Memory Usage**: < 100MB per user session

#### Feature Completeness
- [ ] **Time Travel**: Smooth camera animations through memories
- [ ] **Spatial Navigation**: Efficient viewport-based rendering
- [ ] **Query Types**: All three MECE filter categories working (attribute-based, spatial, set-based)
- [ ] **Backward Compatibility**: Seamless migration from old system

#### User Experience
- [ ] **Loading Time**: < 500ms initial load
- [ ] **Smooth Animations**: 60 FPS camera movements
- [ ] **Responsive Controls**: Real-time query responses
- [ ] **Visual Clarity**: Clear node highlighting and clustering

---

## Conclusion

The V11.0 Cosmos Architecture redesign represents a fundamental shift from a monolithic JSON-based system to a scalable, query-driven architecture. This transformation addresses critical performance limitations while introducing powerful new features like time travel experiences and spatial navigation.

### Key Benefits

1. **Performance**: 80-90% reduction in memory usage and processing time
2. **Scalability**: Support for 10,000+ nodes and 500+ concurrent users
3. **User Experience**: Smooth time travel animations and spatial navigation
4. **Maintainability**: Cleaner code architecture with better separation of concerns
5. **Future-Proof**: Extensible design for additional query types and features

### Migration Strategy

The phased migration approach ensures zero downtime while gradually transitioning from the legacy system to the new architecture. Each phase builds upon the previous one, allowing for testing and validation at each step.

### Success Metrics

The implementation will be considered successful when all performance targets are met, all features are working correctly, and users experience a significant improvement in the cosmos visualization system.

---

*This document serves as the comprehensive design specification for the V11.0 Cosmos Architecture implementation. All development work should reference this document and follow the outlined design decisions and implementation timeline.*
