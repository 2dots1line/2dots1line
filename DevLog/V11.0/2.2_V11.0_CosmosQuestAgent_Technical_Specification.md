# **Technical Specification: CosmosQuestAgent V11.0**

**Document Version:** V11.0  
**Last Updated:** January 2025  
**Location:** `apps/web-app/src/services/cosmosQuestAgent.ts`

## **Executive Summary**

The `CosmosQuestAgent` is a specialized conversational agent designed for immersive memory exploration through 3D visualization. Unlike the `DialogueAgent` which uses conditional memory retrieval, the `CosmosQuestAgent` always retrieves memory and generates guided walkthrough experiences that combine AI-generated narratives with interactive 3D visualization.

**Key Innovation:** The agent creates a seamless bridge between conversational AI and spatial memory exploration, enabling users to "walk through" their personal knowledge graph while receiving contextual narratives and insights.

## **Architecture Overview**

### **Relationship to DialogueAgent**

The `CosmosQuestAgent` is designed as a **specialized sibling** to the `DialogueAgent`, sharing core infrastructure while serving a distinct purpose:

| Aspect | DialogueAgent | CosmosQuestAgent |
|--------|---------------|------------------|
| **Purpose** | General conversational AI | Memory exploration & visualization |
| **Memory Retrieval** | Conditional (LLM decides) | Always retrieve |
| **Output** | Text response | Text + 3D visualization + walkthrough |
| **User Experience** | Chat interface | Conversational + spatial exploration |
| **Decision Logic** | `respond_directly` vs `query_memory` | Always `query_memory` + generate walkthrough |

### **Core Design Principles**

1. **Always Retrieve Memory**: Bypass decision logic, always perform memory retrieval
2. **Progressive Visualization**: Stage-by-stage revelation of memory connections
3. **Guided Exploration**: AI-generated walkthrough scripts for spatial navigation
4. **Real-time Updates**: Stream results as they become available
5. **Immersive Experience**: Combine conversation with 3D visualization

## **End-to-End Flow Analysis**

### **DialogueAgent Flow (Reference)**
```
User Input → Input Pre-processing → Single Synthesis LLM Call → Decision Logic
    ↓
If 'respond_directly': Return response
If 'query_memory': HRT → Second LLM Call → Return response
    ↓
Redis Context Persistence (10min TTL)
```

### **CosmosQuestAgent Flow (Proposed)**
```
User Input → Input Pre-processing → Key Phrase Extraction → Always Retrieve Memory
    ↓
CosmosQuestTool (Fast Mode) → Progressive Visualization → LLM Response Generation
    ↓
Walkthrough Script Generation → Real-time 3D Updates → Guided Tour System
    ↓
Context Persistence (Quest-specific)
```

## **Detailed Technical Specification**

### **1. Core Dependencies**

```typescript
export interface CosmosQuestAgentDependencies {
  configService: ConfigService;
  conversationRepository: ConversationRepository;
  redisClient: Redis;
  promptBuilder: PromptBuilder;
  llmChatTool: any;
  visionCaptionTool: any;
  audioTranscribeTool: any;
  documentExtractTool: any;
  cosmosQuestTool: CosmosQuestTool; // Specialized tool
}
```

### **2. Input/Output Contracts**

#### **Input Contract**
```typescript
interface CosmosQuestInput {
  userQuestion: string;
  userId: string;
  conversationId?: string; // Optional for standalone quests
  currentMessageMedia?: Array<{
    type: string;
    url?: string;
    content?: string;
  }>;
  // Single unified quest experience - no modes needed
}
```

#### **Output Contract**
```typescript
interface QuestState {
  isProcessing: boolean;
  execution_id: string | null;
  key_phrases: KeyPhraseCapsule[];
  visualization_stages: {
    stage1: VisualizationEntity[];
    stage2: VisualizationEntity[];
    stage3: VisualizationEntity[];
  };
  walkthrough_script: WalkthroughStep[];
  response: string;
  reflective_question: string;
  error: string | null;
}

interface CosmosQuestResult {
  // Core response
  response_text: string;
  
  // Key phrase analysis
  keyPhrases: string[];
  capsules: KeyPhraseCapsule[];
  
  // Visualization data
  visualizationStages: {
    stage1: {
      type: 'semantic_similarity';
      entities: ScoredEntity[];
      starTexture: 'bright_star';
    };
    stage2: {
      type: 'graph_hops_1';
      entities: ScoredEntity[];
      starTexture: 'medium_star';
    };
    stage3: {
      type: 'graph_hops_2';
      entities: ScoredEntity[];
      starTexture: 'dim_star';
    };
  };
  
  // Walkthrough system
  walkthroughScript: WalkthroughStep[];
  reflectiveQuestion: string;
  
  // Metadata
  metadata: {
    execution_id: string;
    processing_time_ms: number;
    memory_retrieval_performed: boolean;
    entities_retrieved: number;
    visualization_stages_completed: number;
  };
  
  // Media analysis (reused from DialogueAgent)
  vision_analysis?: string;
  document_analysis?: string;
}
```

### **3. Key Phrase Capsule System**

```typescript
interface KeyPhraseCapsule {
  phrase_id: string;
  phrase: string;
  confidence_score: number;
  color: string;
  type: 'person' | 'concept' | 'event' | 'emotion' | 'activity';
  semantic_score: number;
  related_entity_ids: string[];
}
```

### **4. Walkthrough Script System**

```typescript
interface WalkthroughStep {
  step_id: string;
  entity_id: string;
  entity_type: 'MemoryUnit' | 'Concept' | 'DerivedArtifact';
  narrative: string;
  camera_position: [number, number, number];
  camera_target: [number, number, number];
  duration_ms: number; // Animation duration in ms
  transition_type: 'smooth' | 'instant' | 'zoom';
  highlight_color: string;
  related_step_ids: string[]; // Connected steps
}
```

## **Prompt Assembly Architecture**

### **Quest-Specific Prompt Templates**

The CosmosQuestAgent requires specialized prompt templates that differ from DialogueAgent's decision-based approach:

#### **1. Quest Core Identity Template**
```yaml
# config/prompt_templates.yaml - Quest-specific templates
quest_core_identity_section: |
  === QUEST CORE IDENTITY ===
  
  You are Dot's Memory Explorer, a specialized AI companion designed for immersive 
  memory exploration through 3D visualization. Your purpose is to help {{user_name}} 
  navigate their personal knowledge graph through guided conversations and spatial 
  exploration. You always retrieve memory to provide rich, contextual responses 
  and create walkthrough experiences that reveal hidden connections in their life.
  
  QUEST-SPECIFIC PRINCIPLES:
  1. Always Retrieve Memory: Every quest begins with memory retrieval - no decision logic
  2. Progressive Revelation: Reveal memory connections in stages (semantic → 1-hop → 2-hop)
  3. Spatial Storytelling: Create narratives that guide users through their memory landscape
  4. Reflective Discovery: End each quest with insights that deepen self-understanding
  5. Visual Integration: Every response considers 3D visualization and user experience
```

#### **2. Quest Operational Configuration**
```yaml
quest_operational_config_section: |
  === QUEST OPERATIONAL CONFIG ===
  
  MEMORY RETRIEVAL PROTOCOL:
  - Always perform memory retrieval (no conditional logic)
  - Extract key phrases from user questions
  - Use CosmosQuestTool for fast, visualization-optimized retrieval
  - Generate progressive visualization stages
  
  RESPONSE GENERATION PROTOCOL:
  - Create comprehensive responses using retrieved memory
  - Generate walkthrough scripts with camera positions
  - Include reflective questions for deeper exploration
  - Consider 3D visualization context in all responses
  
  QUEST EXPERIENCE:
  - Unified memory exploration through 3D visualization
  - Progressive revelation of memory connections
  - Guided walkthrough with spatial storytelling
  - Reflective insights for deeper self-understanding
```

#### **3. Quest Dynamic Context Template**
```yaml
quest_dynamic_context_section: |
  === QUEST DYNAMIC CONTEXT ===
  
  {{#user_memory_profile}}
  ## USER MEMORY PROFILE
  {{user_memory_profile}}
  {{/user_memory_profile}}
  
  {{#conversation_summaries}}
  ## RECENT CONVERSATION SUMMARIES
  {{conversation_summaries}}
  {{/conversation_summaries}}
  
  {{#session_context}}
  ## SESSION CONTEXT
  {{session_context}}
  {{/session_context}}
  
  {{#current_conversation_history}}
  ## CURRENT CONVERSATION HISTORY
  {{current_conversation_history}}
  {{/current_conversation_history}}
  
  {{#augmented_memory_context}}
  ## RETRIEVED MEMORY CONTEXT
  {{augmented_memory_context}}
  {{/augmented_memory_context}}
  
  {{#visualization_context}}
  ## VISUALIZATION CONTEXT
  {{visualization_context}}
  {{/visualization_context}}
```

#### **4. Quest Current Turn Template**
```yaml
quest_current_turn_section: |
  === QUEST CURRENT TURN ===
  
  {{#context_from_last_quest}}
  ## CONTEXT FROM LAST QUEST
  {{context_from_last_quest}}
  {{/context_from_last_quest}}
  
  ## USER QUEST REQUEST
  {{user_message}}
  
  ## QUEST RESPONSE INSTRUCTIONS
  Based on the retrieved memory context and visualization data, provide:
  
  1. **Comprehensive Response**: A rich, contextual response to the user's question
  2. **Walkthrough Script**: A sequence of steps to guide the user through relevant entities
  3. **Reflective Question**: A thought-provoking question to end the journey
  
  Return as JSON:
  {
    "response": "Your comprehensive response...",
    "walkthroughScript": [
      {
        "stepId": "step_1",
        "entityId": "entity_id",
        "entityType": "MemoryUnit",
        "narrative": "This memory shows...",
        "cameraPosition": [x, y, z],
        "cameraTarget": [x, y, z],
        "duration": 3000,
        "transitionType": "smooth",
        "highlightColor": "#ff6b6b"
      }
    ],
    "reflectiveQuestion": "What patterns do you notice in your journey?"
  }
```

### **Quest Prompt Builder Implementation**

```typescript
// apps/web-app/src/services/questPromptBuilder.ts
export class QuestPromptBuilder {
  private configService: ConfigService;
  private conversationRepo: ConversationRepository;
  
  constructor(dependencies: QuestPromptBuilderDependencies) {
    this.configService = dependencies.configService;
    this.conversationRepo = dependencies.conversationRepository;
  }
  
  public async buildQuestPrompt(input: QuestPromptBuildInput): Promise<QuestPromptBuildOutput> {
    const { userId, conversationId, finalInputText, questResult, isNewQuest } = input;
    
    // Fetch quest-specific data
    const { user, conversationHistory, recentSummaries, turnContextStr, sessionContext } = 
      await this.fetchQuestPromptData(userId, conversationId);
    
    // Get quest-specific templates
    const coreIdentityTpl = this.configService.getTemplate('quest_core_identity_section');
    const operationalConfigTpl = this.configService.getTemplate('quest_operational_config_section');
    const dynamicContextTpl = this.configService.getTemplate('quest_dynamic_context_section');
    const currentTurnTpl = this.configService.getTemplate('quest_current_turn_section');
    
    // Build quest-specific context
    const questContextData = {
      user_memory_profile: this.formatComponentContent('user_memory_profile', user.memory_profile),
      conversation_summaries: this.formatComponentContent('conversation_summaries', recentSummaries),
      session_context: sessionContext.length > 0 ? this.formatComponentContent('session_context', sessionContext) : null,
      current_conversation_history: this.formatComponentContent('current_conversation_history', conversationHistory),
      augmented_memory_context: this.formatComponentContent('augmented_memory_context', questResult.retrievedMemoryUnits),
      visualization_context: this.formatVisualizationContext(questResult.visualizationStages)
    };
    
    // Render quest-specific sections
    const section1 = Mustache.render(coreIdentityTpl, { user_name: user.name || 'User' });
    const section2 = Mustache.render(operationalConfigTpl, { user_name: user.name || 'User' });
    const section3 = Mustache.render(dynamicContextTpl, questContextData);
    const section4 = Mustache.render(currentTurnTpl, {
      context_from_last_quest: isNewQuest ? null : this.formatContextFromLastQuest(turnContextStr),
      user_message: finalInputText
    });
    
    return {
      systemPrompt: [section1, section2, section3].filter(s => s && s.trim()).join('\n\n'),
      userPrompt: section4,
      conversationHistory: conversationHistory.map(msg => ({
        role: msg.type,
        content: msg.content
      }))
    };
  }
  
  private formatVisualizationContext(visualizationStages: VisualizationStages): string {
    return `
    VISUALIZATION STAGES:
    - Stage 1 (Semantic Similarity): ${visualizationStages.stage1.entities.length} entities with bright star texture
    - Stage 2 (1-Hop Connections): ${visualizationStages.stage2.entities.length} entities with medium star texture  
    - Stage 3 (2-Hop Connections): ${visualizationStages.stage3.entities.length} entities with dim star texture
    
    Total entities for visualization: ${visualizationStages.stage1.entities.length + visualizationStages.stage2.entities.length + visualizationStages.stage3.entities.length}
    `;
  }
}
```

## **Database Persistence Architecture**

### **Quest Conversation Persistence Strategy**

The CosmosQuestAgent requires specialized database persistence that differs from DialogueAgent's approach:

#### **1. Conversation Type System**

```sql
-- Add type field to conversations table
ALTER TABLE conversations ADD COLUMN type VARCHAR(50) DEFAULT 'chat';
-- Values: 'chat', 'quest', and future interaction types

-- Add quest-specific metadata
ALTER TABLE conversations ADD COLUMN quest_metadata JSON;
-- Stores: walkthrough_script, visualization_stages, key_phrases, etc.
```

#### **2. Quest Message Persistence**

```typescript
// Quest-specific message types and metadata
interface QuestMessageMetadata {
  conversation_type: 'quest';
  key_phrases: string[];
  capsules: KeyPhraseCapsule[];
  visualization_stages: {
    stage1: { entity_count: number; star_texture: string };
    stage2: { entity_count: number; star_texture: string };
    stage3: { entity_count: number; star_texture: string };
  };
  walkthrough_script: WalkthroughStep[];
  reflective_question: string;
  entities_retrieved: number;
  processing_time_ms: number;
}
```

#### **3. Quest Persistence Service**

```typescript
// apps/web-app/src/services/questPersistenceService.ts
export class QuestPersistenceService {
  private conversationRepo: ConversationRepository;
  private redis: Redis;
  
  async persistQuestConversation(input: {
    userId: string;
    conversationId: string;
    userMessage: string;
    questResult: CosmosQuestResult;
  }): Promise<void> {
    
    // 1. Save user message with quest metadata
    await this.conversationRepo.addMessage({
      conversation_id: input.conversationId,
      type: 'user',
      content: input.userMessage,
      metadata: {
        conversationType: 'quest',
        keyPhrases: input.questResult.keyPhrases,
        capsules: input.questResult.capsules
      }
    });
    
    // 2. Save assistant response with quest metadata
    await this.conversationRepo.addMessage({
      conversation_id: input.conversationId,
      type: 'assistant',
      content: input.questResult.response_text,
      metadata: {
        conversationType: 'quest',
        visualizationStages: input.questResult.visualizationStages,
        walkthroughScript: input.questResult.walkthroughScript,
        reflectiveQuestion: input.questResult.reflectiveQuestion,
        entitiesRetrieved: input.questResult.metadata.entities_retrieved,
        processing_time_ms: input.questResult.metadata.processing_time_ms
      }
    });
    
    // 3. Update conversation with quest metadata
    await this.conversationRepo.updateConversation(input.conversationId, {
      type: 'quest',
      quest_metadata: {
        totalQuests: await this.getTotalQuestsForConversation(input.conversationId),
        lastQuestEntities: input.questResult.metadata.entities_retrieved,
        lastQuestTime: new Date().toISOString()
      }
    });
    
    // 4. Persist quest context to Redis (longer TTL than DialogueAgent)
    await this.persistQuestContext(input.conversationId, input.questResult);
  }
  
  private async persistQuestContext(conversationId: string, questResult: CosmosQuestResult): Promise<void> {
    const questContext = {
      conversationType: 'quest',
      keyPhrases: questResult.keyPhrases,
      walkthroughScript: questResult.walkthroughScript,
      visualizationStages: questResult.visualizationStages,
      reflectiveQuestion: questResult.reflectiveQuestion,
      created_at: new Date().toISOString(),
      execution_id: questResult.metadata.execution_id
    };
    
    await this.redis.set(
      `quest_context:${conversationId}`,
      JSON.stringify(questContext),
      'EX', 1800 // 30 min TTL (longer than DialogueAgent's 10 min)
    );
  }
}
```

#### **4. Quest-Specific Database Queries**

```typescript
// Quest-specific repository methods
export class QuestConversationRepository extends ConversationRepository {
  
  async getQuestHistory(conversationId: string, limit: number = 10): Promise<QuestMessage[]> {
    const messages = await this.db.conversation_messages.findMany({
      where: {
        conversation_id: conversationId,
        metadata: {
          path: ['conversationType'],
          equals: 'quest'
        }
      },
      orderBy: { created_at: 'desc' },
      take: limit
    });
    
    return messages.map(msg => ({
      ...msg,
      questMetadata: msg.metadata as QuestMessageMetadata
    }));
  }
  
  async getQuestStatistics(userId: string): Promise<QuestStatistics> {
    const quests = await this.db.conversations.findMany({
      where: {
        user_id: userId,
        type: 'quest'
      },
      select: {
        quest_metadata: true,
        created_at: true
      }
    });
    
    return {
      totalQuests: quests.length,
      averageEntitiesPerQuest: this.calculateAverageEntities(quests),
      lastQuestDate: quests[0]?.created_at
    };
  }
}
```

#### **5. Type-Based Architecture Benefits**

The `type` field approach provides several advantages:

**Extensibility**: Easy to add new interaction types (e.g., `voice`, `video`, `collaborative`, `analytics`)
**Consistency**: Same pattern across conversations, messages, and sessions
**Query Efficiency**: Simple type-based filtering and indexing
**Future-Proof**: No need to add new boolean columns for each interaction type

**Current Types**:
- `chat`: Standard DialogueAgent conversations
- `quest`: CosmosQuestAgent memory exploration

**Future Types** (examples):
- `voice`: Voice-based interactions
- `video`: Video call sessions
- `collaborative`: Multi-user sessions
- `analytics`: Data analysis sessions
- `training`: AI training sessions

#### **6. Quest Data Migration Strategy**

```sql
-- Migration for type-based fields
-- File: packages/database/prisma/migrations/add_type_fields/migration.sql

-- Add type field to conversations table
ALTER TABLE conversations 
ADD COLUMN type VARCHAR(50) DEFAULT 'chat',
ADD COLUMN quest_metadata JSON;

-- Add type field to conversation_messages table  
ALTER TABLE conversation_messages
ADD COLUMN type VARCHAR(50) DEFAULT 'chat';

-- Add type field to user_sessions table
ALTER TABLE user_sessions
ADD COLUMN type VARCHAR(50) DEFAULT 'chat';

-- Create index for type queries
CREATE INDEX idx_conversations_type ON conversations(type);
CREATE INDEX idx_conversations_user_type ON conversations(user_id, type);
CREATE INDEX idx_conversation_messages_type ON conversation_messages(type);
CREATE INDEX idx_user_sessions_type ON user_sessions(type);
```

## **UI Data Flow Architecture**

### **Progressive UI Updates**

The CosmosQuestAgent sends data to the frontend in **4 distinct batches** to create a progressive, engaging user experience:

#### **Batch 1: Key Phrase Capsules**
**Timing**: Immediately after key phrase extraction (~200ms)
**Purpose**: Display extracted key phrases as interactive chat capsules
**Data Structure**:
```typescript
interface KeyPhraseBatch {
  type: 'key_phrases';
  execution_id: string;
  capsules: KeyPhraseCapsule[];
  created_at: string;
}

interface KeyPhraseCapsule {
  phrase: string;
  confidence_score: number; // 0-1
  color: string; // Hex color for UI
  type?: string; // Optional categorization
}
```

**Example**:
```typescript
{
  type: 'key_phrases',
  execution_id: 'cq_1704067200000',
  capsules: [
    { phrase: "skating", confidence_score: 0.95, color: "#ff6b6b" },
    { phrase: "injuries", confidence_score: 0.87, color: "#4ecdc4" },
    { phrase: "recovery", confidence_score: 0.82, color: "#45b7d1" }
  ],
  created_at: '2025-01-01T12:00:00.200Z'
}
```

#### **Batch 2: Stage 1 Visualization (Semantic Similarity)**
**Timing**: After semantic grounding completes (~400ms)
**Purpose**: Display entities found through semantic similarity with bright star texture
**Data Structure**:
```typescript
interface VisualizationStage1Batch {
  type: 'visualization_stage_1';
  execution_id: string;
  stage: 1;
  entities: VisualizationEntity[];
  metadata: {
    total_entities: number;
    processing_time_ms: number;
  };
  created_at: string;
}

interface VisualizationEntity {
  entity_id: string;
  entity_type: 'MemoryUnit' | 'Concept' | 'GrowthEvent' | 'DerivedArtifact';
  position: [number, number, number]; // [x, y, z] coordinates
  star_texture: 'bright_star';
  title: string;
  relevance_score: number;
}
```

**Example**:
```typescript
{
  type: 'visualization_stage_1',
  execution_id: 'cq_1704067200000',
  stage: 1,
  entities: [
    {
      entity_id: "mem_123",
      entity_type: "MemoryUnit",
      position: [10.5, 2.3, -5.7],
      star_texture: "bright_star",
      title: "First skating lesson",
      relevance_score: 0.92
    },
    {
      entity_id: "mem_456", 
      entity_type: "MemoryUnit",
      position: [-8.2, 1.1, 3.4],
      star_texture: "bright_star",
      title: "Skating injury recovery",
      relevance_score: 0.88
    }
  ],
  metadata: {
    total_entities: 2,
    processing_time_ms: 200
  },
  created_at: '2025-01-01T12:00:00.400Z'
}
```

#### **Batch 3: Stage 2 & 3 Visualization (Graph Traversal)**
**Timing**: After graph traversal completes (~800ms)
**Purpose**: Display 1-hop and 2-hop connected entities with different star textures
**Data Structure**:
```typescript
interface VisualizationStages2And3Batch {
  type: 'visualization_stages_2_3';
  execution_id: string;
  stage2: {
    entities: VisualizationEntity[];
    description: string;
  };
  stage3: {
    entities: VisualizationEntity[];
    description: string;
  };
  metadata: {
    total_entities: number;
    processing_time_ms: number;
  };
  created_at: string;
}

interface VisualizationEntity {
  entity_id: string;
  entity_type: 'MemoryUnit' | 'Concept' | 'GrowthEvent' | 'DerivedArtifact';
  position: [number, number, number];
  star_texture: 'medium_star' | 'dim_star';
  title: string;
  relevance_score: number;
  connection_type: '1_hop' | '2_hop';
  connected_to: string[]; // Entity IDs this connects to
}
```

**Example**:
```typescript
{
  type: 'visualization_stages_2_3',
  execution_id: 'cq_1704067200000',
  stage2: {
    entities: [
      {
        entity_id: "mem_789",
        entity_type: "MemoryUnit",
        position: [5.2, -1.8, 7.3],
        star_texture: "medium_star",
        title: "Physical therapy sessions",
        relevance_score: 0.75,
        connection_type: "1_hop",
        connected_to: ["mem_123", "mem_456"]
      }
    ],
    description: "1-hop connections from semantic matches"
  },
  stage3: {
    entities: [
      {
        entity_id: "mem_101",
        entity_type: "Concept",
        position: [-2.1, 4.5, -1.2],
        star_texture: "dim_star",
        title: "Resilience and determination",
        relevance_score: 0.65,
        connection_type: "2_hop",
        connected_to: ["mem_789"]
      }
    ],
    description: "2-hop connections from 1-hop entities"
  },
  metadata: {
    total_entities: 2,
    processing_time_ms: 400
  },
  created_at: '2025-01-01T12:00:00.800Z'
}
```

#### **Batch 4: Final Response + Walkthrough Script**
**Timing**: After LLM response generation completes (~1200ms)
**Purpose**: Complete response with walkthrough script for guided tour
**Data Structure**:
```typescript
interface FinalResponseBatch {
  type: 'final_response';
  execution_id: string;
  response_text: string;
  walkthrough_script: WalkthroughStep[];
  reflective_question: string;
  metadata: {
    entities_retrieved: number;
    processing_time_ms: number;
    total_processing_time_ms: number;
  };
  created_at: string;
}

interface WalkthroughStep {
  step_id: string;
  entity_id: string;
  entity_type: 'MemoryUnit' | 'Concept' | 'GrowthEvent' | 'DerivedArtifact';
  narrative: string;
  camera_position: [number, number, number];
  camera_target: [number, number, number];
  duration_ms: number; // milliseconds
  transition_type: 'smooth' | 'instant' | 'ease_in_out';
  highlight_color: string; // Hex color
  related_step_ids: string[]; // Connected step IDs
}
```

**Example**:
```typescript
{
  type: 'final_response',
  execution_id: 'cq_1704067200000',
  response_text: "You started skating in 2018, went through these injuries and you recovered from the setback. Skating for you means determination, resilience, and personal growth. It aligns with your values of perseverance and self-improvement. Would you like me to take you on a walk through your personal cosmos graph?",
  walkthrough_script: [
    {
      step_id: "step_1",
      entity_id: "mem_123",
      entity_type: "MemoryUnit",
      narrative: "This memory shows your first skating lesson where you discovered your passion for the sport.",
      camera_position: [10.5, 2.3, -5.7],
      camera_target: [10.5, 2.3, -5.7],
      duration_ms: 3000,
      transition_type: "smooth",
      highlight_color: "#ff6b6b",
      related_step_ids: ["step_2"]
    },
    {
      step_id: "step_2",
      entity_id: "mem_456",
      entity_type: "MemoryUnit", 
      narrative: "Here's where you faced your biggest challenge - the injury that tested your resolve.",
      camera_position: [-8.2, 1.1, 3.4],
      camera_target: [-8.2, 1.1, 3.4],
      duration_ms: 3000,
      transition_type: "smooth",
      highlight_color: "#4ecdc4",
      related_step_ids: ["step_1", "step_3"]
    }
  ],
  reflective_question: "What patterns do you notice in your skating journey that reflect your personal growth?",
  metadata: {
    entities_retrieved: 4,
    processing_time_ms: 400,
    total_processing_time_ms: 1200
  },
  created_at: '2025-01-01T12:00:00.1200Z'
}
```

### **Data Transmission Methods**

#### **Method 1: WebSocket Real-time Updates (Recommended)**
```typescript
// Backend: CosmosQuestAgent
class CosmosQuestAgent {
  private websocketServer: WebSocketServer;
  
  async processQuest(input: CosmosQuestInput): Promise<CosmosQuestResult> {
    const execution_id = `cq_${Date.now()}`;
    
    // Send Batch 1: Key Phrases
    const keyPhrases = await this.extractKeyPhrases(input.userQuestion);
    this.sendToUI(execution_id, {
      type: 'key_phrases',
      execution_id,
      capsules: await this.createKeyPhraseCapsules(keyPhrases),
      created_at: new Date().toISOString()
    });
    
    // Send Batch 2: Stage 1 Visualization
    const questResult = await this.cosmosQuestTool.execute({...});
    this.sendToUI(execution_id, {
      type: 'visualization_stage_1',
      execution_id,
      stage: 1,
      entities: questResult.visualizationStages.stage1.entities,
      metadata: { total_entities: questResult.visualizationStages.stage1.entities.length },
      created_at: new Date().toISOString()
    });
    
    // Send Batch 3: Stages 2 & 3 Visualization
    this.sendToUI(execution_id, {
      type: 'visualization_stages_2_3',
      execution_id,
      stage2: questResult.visualizationStages.stage2,
      stage3: questResult.visualizationStages.stage3,
      metadata: { total_entities: questResult.visualizationStages.stage2.entities.length + questResult.visualizationStages.stage3.entities.length },
      created_at: new Date().toISOString()
    });
    
    // Send Batch 4: Final Response
    const { response, walkthroughScript, reflectiveQuestion } = await this.generateResponseWithWalkthrough(input.userQuestion, questResult);
    this.sendToUI(execution_id, {
      type: 'final_response',
      execution_id,
      response_text: response,
      walkthrough_script: walkthroughScript,
      reflective_question: reflectiveQuestion,
      metadata: { entities_retrieved: questResult.metadata.total_entities },
      created_at: new Date().toISOString()
    });
  }
  
  private sendToUI(executionId: string, data: any): void {
    this.websocketServer.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify({
          executionId,
          ...data
        }));
      }
    });
  }
}
```

```typescript
// Frontend: CosmosQuestScene
class CosmosQuestScene {
  private websocket: WebSocket;
  private questState: QuestState = {
    isProcessing: false,
    execution_id: null,
    key_phrases: [],
    visualization_stages: { stage1: [], stage2: [], stage3: [] },
    walkthrough_script: [],
    response: '',
    reflective_question: '',
    error: null
  };
  
  componentDidMount() {
    this.websocket = new WebSocket('ws://localhost:3001/quest');
    
    this.websocket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleQuestUpdate(data);
    };
  }
  
  private handleQuestUpdate(data: any): void {
    switch (data.type) {
      case 'key_phrases':
        this.setState({ key_phrases: data.capsules });
        break;
        
      case 'visualization_stage_1':
        this.setState(prevState => ({
          visualization_stages: {
            ...prevState.visualization_stages,
            stage1: data.entities
          }
        }));
        this.renderStars(data.entities, 'bright_star');
        break;
        
      case 'visualization_stages_2_3':
        this.setState(prevState => ({
          visualization_stages: {
            ...prevState.visualization_stages,
            stage2: data.stage2.entities,
            stage3: data.stage3.entities
          }
        }));
        this.renderStars(data.stage2.entities, 'medium_star');
        this.renderStars(data.stage3.entities, 'dim_star');
        break;
        
      case 'final_response':
        this.setState({
          response: data.response_text,
          walkthrough_script: data.walkthrough_script,
          reflective_question: data.reflective_question,
          isProcessing: false
        });
        break;
    }
  }
}
```

#### **Method 2: Server-Sent Events (Alternative)**
```typescript
// Backend: Express route
app.post('/api/v1/quest/process', async (req, res) => {
  const { userQuestion, userId } = req.body;
  
  // Set up SSE connection
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'Access-Control-Allow-Origin': '*'
  });
  
  const questAgent = new CosmosQuestAgent(dependencies);
  
  try {
    await questAgent.processQuest({
      userQuestion,
      userId,
      onProgress: (batch) => {
        res.write(`data: ${JSON.stringify(batch)}\n\n`);
      }
    });
  } catch (error) {
    res.write(`data: ${JSON.stringify({ type: 'error', message: error.message })}\n\n`);
  } finally {
    res.end();
  }
});
```

```typescript
// Frontend: EventSource
class CosmosQuestScene {
  private eventSource: EventSource;
  
  async processQuest(question: string) {
    this.eventSource = new EventSource(`/api/v1/quest/process?question=${encodeURIComponent(question)}`);
    
    this.eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleQuestUpdate(data);
    };
    
    this.eventSource.onerror = (error) => {
      console.error('Quest processing error:', error);
      this.eventSource.close();
    };
  }
}
```

#### **Method 3: Polling (Fallback)**
```typescript
// Backend: Store progress in Redis
class CosmosQuestAgent {
  async processQuest(input: CosmosQuestInput): Promise<CosmosQuestResult> {
    const execution_id = `cq_${Date.now()}`;
    
    // Store progress in Redis
    await this.redis.set(`quest_progress:${execution_id}`, JSON.stringify({
      status: 'processing',
      batch: 0,
      data: null
    }), 'EX', 300); // 5 min TTL
    
    // Process and update progress
    const keyPhrases = await this.extractKeyPhrases(input.userQuestion);
    await this.redis.set(`quest_progress:${execution_id}`, JSON.stringify({
      status: 'processing',
      batch: 1,
      data: { type: 'key_phrases', capsules: keyPhrases }
    }), 'EX', 300);
    
    // ... continue for other batches
  }
}
```

```typescript
// Frontend: Polling
class CosmosQuestScene {
  private pollQuestProgress(execution_id: string) {
    const pollInterval = setInterval(async () => {
      try {
        const response = await fetch(`/api/v1/quest/progress/${execution_id}`);
        const progress = await response.json();
        
        if (progress.status === 'completed') {
          clearInterval(pollInterval);
          this.handleQuestUpdate(progress.data);
        } else if (progress.data) {
          this.handleQuestUpdate(progress.data);
        }
      } catch (error) {
        console.error('Polling error:', error);
        clearInterval(pollInterval);
      }
    }, 100); // Poll every 100ms
  }
}
```

### **Recommended Implementation**

**WebSocket (Method 1)** is recommended because:
- **Real-time updates**: Immediate UI feedback
- **Efficient**: No polling overhead
- **Bidirectional**: Can handle user interactions during processing
- **Scalable**: Works well with multiple concurrent quests

### **Timeline Summary**

```
T+0ms:    User submits question
T+200ms:  Batch 1 → Key phrase capsules appear in chat
T+400ms:  Batch 2 → Bright stars appear (semantic matches)
T+800ms:  Batch 3 → Medium & dim stars appear (graph connections)
T+1200ms: Batch 4 → Full response + walkthrough script ready
```

This progressive approach creates an engaging, responsive user experience while the backend processes the complete quest result.

## **API Setup Requirements**

### **Leveraging Existing Infrastructure**

The CosmosQuestAgent can leverage most of the existing API infrastructure:

#### **Existing Components to Reuse**
- **Authentication**: `authMiddleware` from existing routes
- **Database Services**: `DatabaseService`, `ConversationRepository`, `SessionRepository`
- **Redis**: For quest context storage and progress tracking
- **Socket.IO**: Existing notification service infrastructure
- **Error Handling**: Existing error handling middleware
- **CORS**: Existing CORS configuration

#### **Existing API Endpoints to Extend**
```typescript
// Current agent routes (apps/api-gateway/src/routes/v1/agent.routes.ts)
POST /api/v1/agent/chat                    // DialogueAgent
POST /api/v1/agent/start-conversation     // DialogueAgent
GET  /api/v1/agent/conversation/:id       // DialogueAgent

// Current conversation routes
POST /api/v1/conversations/messages       // General conversation handling
POST /api/v1/conversations/new-chat       // Start new conversation
GET  /api/v1/conversations                // Get conversation history
```

### **New API Endpoints Required (Must-Have Only)**

#### **1. Quest Processing Endpoint**
```typescript
// Essential quest endpoint
POST /api/v1/quest/process                // Start quest processing with WebSocket updates
```

#### **2. WebSocket Integration**
```typescript
// Extend existing Socket.IO service for quest updates
// Current: workers/notification-worker (port 3002)
// Add quest-specific events to existing Socket.IO server
```

### **Implementation Strategy**

#### **Option 1: Extend Existing API Gateway (Recommended)**

**Pros**: 
- Leverages existing infrastructure
- Consistent with current architecture
- Minimal new dependencies

**Implementation**:
```typescript
// apps/api-gateway/src/routes/v1/quest.routes.ts
import { Router } from 'express';
import { QuestController } from '../../controllers/quest.controller';

export function createQuestRoutes(questController: QuestController): Router {
  const router = Router();

  // Essential quest endpoint only
  router.post('/process', (req, res, next) => questController.processQuest(req, res, next));
  
  return router;
}
```

```typescript
// apps/api-gateway/src/controllers/quest.controller.ts
export class QuestController {
  private cosmosQuestAgent: CosmosQuestAgent;
  private conversationRepo: ConversationRepository;
  private redis: Redis;
  
  constructor(cosmosQuestAgent: CosmosQuestAgent, conversationRepo: ConversationRepository, redis: Redis) {
    this.cosmosQuestAgent = cosmosQuestAgent;
    this.conversationRepo = conversationRepo;
    this.redis = redis;
  }
  
  /**
   * POST /api/v1/quest/process
   * Start quest processing with WebSocket updates
   */
  async processQuest(req: Request, res: Response, next: NextFunction) {
    try {
      const { userQuestion, userId, conversationId } = req.body;
      
      // Start quest processing (non-blocking)
      const executionId = `cq_${Date.now()}`;
      
      // Return execution ID immediately
      res.json({
        success: true,
        data: {
          executionId,
          status: 'processing',
          message: 'Quest processing started'
        }
      });
      
      // Process quest in background with WebSocket updates
      this.cosmosQuestAgent.processQuest({
        userQuestion,
        userId,
        conversationId,
        execution_id
      }).catch(error => {
        console.error('Quest processing error:', error);
        // Send error via WebSocket
        this.sendQuestUpdate(execution_id, {
          type: 'error',
          message: error.message
        });
      });
      
    } catch (error) {
      next(error);
    }
  }
  
  
  private sendQuestUpdate(execution_id: string, data: any): void {
    // This would integrate with existing Socket.IO service
    // Implementation depends on how we extend the notification service
  }
}
```


### **WebSocket Integration Strategy**

#### **Extend Existing Notification Service**

The existing `NotificationWorker` (port 3002) already has Socket.IO infrastructure:

```typescript
// workers/notification-worker/src/NotificationWorker.ts
// Add quest-specific event handling

export class NotificationWorker {
  // ... existing code ...
  
  /**
   * Add quest-specific event handling
   */
  private setupQuestHandlers(): void {
    if (!this.io) return;
    
    // Quest processing events
    this.io.on('quest:join', (socket: AuthenticatedSocket, data: { executionId: string }) => {
      socket.join(`quest:${data.executionId}`);
      console.log(`[Quest] User ${socket.userId} joined quest ${data.executionId}`);
    });
    
    this.io.on('quest:leave', (socket: AuthenticatedSocket, data: { executionId: string }) => {
      socket.leave(`quest:${data.executionId}`);
      console.log(`[Quest] User ${socket.userId} left quest ${data.executionId}`);
    });
  }
  
  /**
   * Send quest update to specific execution room
   */
  public sendQuestUpdate(execution_id: string, data: any): void {
    if (!this.io) return;
    
    this.io.to(`quest:${execution_id}`).emit('quest:update', {
      execution_id,
      ...data,
      created_at: new Date().toISOString()
    });
  }
}
```

#### **Quest Agent Integration**

```typescript
// apps/web-app/src/services/cosmosQuestAgent.ts
export class CosmosQuestAgent {
  private notificationWorker: NotificationWorker;
  
  constructor(dependencies: CosmosQuestAgentDependencies) {
    // ... existing dependencies ...
    this.notificationWorker = dependencies.notificationWorker;
  }
  
  async processQuest(input: CosmosQuestInput): Promise<CosmosQuestResult> {
    const execution_id = `cq_${Date.now()}`;
    
    // Send Batch 1: Key Phrases
    const keyPhrases = await this.extractKeyPhrases(input.userQuestion);
    this.notificationWorker.sendQuestUpdate(execution_id, {
      type: 'key_phrases',
      capsules: await this.createKeyPhraseCapsules(keyPhrases)
    });
    
    // Send Batch 2: Stage 1 Visualization
    const questResult = await this.cosmosQuestTool.execute({...});
    this.notificationWorker.sendQuestUpdate(execution_id, {
      type: 'visualization_stage_1',
      stage: 1,
      entities: questResult.visualizationStages.stage1.entities
    });
    
    // ... continue for other batches
    
    return questResult;
  }
}
```

### **Database Schema Updates**

#### **Required Migrations**
```sql
-- Add type field to existing tables
ALTER TABLE conversations ADD COLUMN type VARCHAR(50) DEFAULT 'chat';
ALTER TABLE conversation_messages ADD COLUMN type VARCHAR(50) DEFAULT 'chat';
ALTER TABLE user_sessions ADD COLUMN type VARCHAR(50) DEFAULT 'chat';

-- Add quest-specific metadata
ALTER TABLE conversations ADD COLUMN quest_metadata JSON;

-- Create indexes
CREATE INDEX idx_conversations_type ON conversations(type);
CREATE INDEX idx_conversations_user_type ON conversations(user_id, type);
```

### **Frontend Integration**

#### **WebSocket Connection**
```typescript
// apps/web-app/src/hooks/useQuestConnection.ts
export const useQuestConnection = () => {
  const { user } = useUserStore();
  const [questState, setQuestState] = useState<QuestState>({
    isProcessing: false,
    execution_id: null,
    key_phrases: [],
    visualization_stages: { stage1: [], stage2: [], stage3: [] },
    walkthrough_script: [],
    response: '',
    reflective_question: '',
    error: null
  });
  
  useEffect(() => {
    if (!user?.user_id) return;
    
    // Use existing Socket.IO connection from notification service
    const socket = io(process.env.NEXT_PUBLIC_NOTIFICATION_SERVICE_URL || 'http://localhost:3002', {
      auth: {
        token: localStorage.getItem('auth_token'),
        userId: user.user_id
      }
    });
    
    // Join quest room when processing starts
    const joinQuest = (execution_id: string) => {
      socket.emit('quest:join', { executionId: execution_id });
      setQuestState(prev => ({ ...prev, execution_id, isProcessing: true }));
    };
    
    // Handle quest updates
    socket.on('quest:update', (data) => {
      handleQuestUpdate(data);
    });
    
    return () => {
      socket.emit('quest:leave', { executionId: questState.execution_id });
      socket.disconnect();
    };
  }, [user?.user_id]);
  
  return { questState, joinQuest };
};
```

### **API Endpoint Summary (Must-Have Only)**

| Method | Endpoint | Purpose | Existing/New |
|--------|----------|---------|--------------|
| POST | `/api/v1/agent/chat` | DialogueAgent chat | ✅ Existing |
| POST | `/api/v1/agent/start-conversation` | Start DialogueAgent conversation | ✅ Existing |
| POST | `/api/v1/quest/process` | Start quest processing | 🆕 New |
| WebSocket | `quest:join` | Join quest room | 🆕 New (extend existing) |
| WebSocket | `quest:update` | Receive quest updates | 🆕 New (extend existing) |

### **Recommended Implementation Approach**

**Extend Existing API Gateway** approach is recommended because:

1. **Leverages Existing Infrastructure**: Reuses authentication, database, Redis, and Socket.IO
2. **Consistent Architecture**: Follows existing patterns and conventions
3. **Minimal New Dependencies**: Only 1 new endpoint + 2 WebSocket events
4. **Faster Development**: Builds on proven, working infrastructure
5. **Easier Maintenance**: Single service to maintain and scale

The implementation extends the existing API Gateway with just 1 quest endpoint and 2 WebSocket events, while leveraging the existing Socket.IO notification service for real-time updates.

## **Frontend Development & Testing Strategy**

### **Mock Data Generation for Independent Frontend Development**

When developing frontend and backend separately, you can create mock data that simulates the CosmosQuestAgent's output to test UI responsiveness and user experience.

#### **1. Mock Data Generator**

```typescript
// apps/web-app/src/utils/mockQuestData.ts
export class MockQuestDataGenerator {
  
  /**
   * Generate mock key phrase capsules (Batch 1)
   */
  static generateKeyPhraseCapsules(question: string): KeyPhraseBatch {
    const mockPhrases = this.extractMockPhrases(question);
    
    return {
      type: 'key_phrases',
      execution_id: `cq_mock_${Date.now()}`,
      capsules: mockPhrases.map((phrase, index) => ({
        phrase,
        confidence_score: 0.85 + (Math.random() * 0.15), // 0.85-1.0
        color: this.getCapsuleColor(index),
        type: this.getCapsuleCategory(phrase)
      })),
      created_at: new Date().toISOString()
    };
  }
  
  /**
   * Generate mock Stage 1 visualization (Batch 2)
   */
  static generateStage1Visualization(question: string): VisualizationStage1Batch {
    const mockEntities = this.generateMockEntities(3, 'MemoryUnit', 'bright_star');
    
    return {
      type: 'visualization_stage_1',
      execution_id: `cq_mock_${Date.now()}`,
      stage: 1,
      entities: mockEntities,
      metadata: {
        total_entities: mockEntities.length,
        processing_time_ms: 200 + Math.random() * 100
      },
      created_at: new Date().toISOString()
    };
  }
  
  /**
   * Generate mock Stages 2 & 3 visualization (Batch 3)
   */
  static generateStages2And3Visualization(question: string): VisualizationStages2And3Batch {
    const stage2Entities = this.generateMockEntities(2, 'MemoryUnit', 'medium_star');
    const stage3Entities = this.generateMockEntities(1, 'Concept', 'dim_star');
    
    return {
      type: 'visualization_stages_2_3',
      execution_id: `cq_mock_${Date.now()}`,
      stage2: {
        entities: stage2Entities,
        description: "1-hop connections from semantic matches"
      },
      stage3: {
        entities: stage3Entities,
        description: "2-hop connections from 1-hop entities"
      },
      metadata: {
        total_entities: stage2Entities.length + stage3Entities.length,
        processing_time_ms: 400 + Math.random() * 200
      },
      created_at: new Date().toISOString()
    };
  }
  
  /**
   * Generate mock final response with walkthrough script (Batch 4)
   */
  static generateFinalResponse(question: string): FinalResponseBatch {
    const mockResponse = this.generateMockResponse(question);
    const mockWalkthrough = this.generateMockWalkthroughScript();
    
    return {
      type: 'final_response',
      execution_id: `cq_mock_${Date.now()}`,
      response_text: mockResponse,
      walkthrough_script: mockWalkthrough,
      reflective_question: this.generateMockReflectiveQuestion(question),
      metadata: {
        entities_retrieved: 6,
        processing_time_ms: 400 + Math.random() * 200,
        total_processing_time_ms: 1200 + Math.random() * 300
      },
      created_at: new Date().toISOString()
    };
  }
  
  /**
   * Generate complete mock quest sequence
   */
  static generateCompleteQuestSequence(question: string): QuestMockSequence {
    const execution_id = `cq_mock_${Date.now()}`;
    
    return {
      execution_id,
      batches: [
        {
          delay: 200,
          data: this.generateKeyPhraseCapsules(question)
        },
        {
          delay: 400,
          data: this.generateStage1Visualization(question)
        },
        {
          delay: 800,
          data: this.generateStages2And3Visualization(question)
        },
        {
          delay: 1200,
          data: this.generateFinalResponse(question)
        }
      ]
    };
  }
  
  // Helper methods
  private static extractMockPhrases(question: string): string[] {
    const commonPhrases = {
      'skating': ['skating', 'ice skating', 'roller skating', 'skateboard'],
      'work': ['work', 'job', 'career', 'professional'],
      'travel': ['travel', 'trip', 'vacation', 'journey'],
      'family': ['family', 'parents', 'siblings', 'relatives'],
      'health': ['health', 'fitness', 'exercise', 'wellness'],
      'education': ['school', 'university', 'learning', 'education'],
      'hobbies': ['hobbies', 'interests', 'activities', 'passions']
    };
    
    const lowerQuestion = question.toLowerCase();
    const foundPhrases: string[] = [];
    
    Object.entries(commonPhrases).forEach(([key, phrases]) => {
      if (lowerQuestion.includes(key)) {
        foundPhrases.push(...phrases.slice(0, 2));
      }
    });
    
    // Fallback to generic phrases if no matches
    if (foundPhrases.length === 0) {
      foundPhrases.push('experience', 'memories', 'thoughts', 'feelings');
    }
    
    return foundPhrases.slice(0, 4);
  }
  
  private static generateMockEntities(count: number, entityType: string, starTexture: string): VisualizationEntity[] {
    const entities: VisualizationEntity[] = [];
    
    for (let i = 0; i < count; i++) {
      entities.push({
        entityId: `mock_${entityType.toLowerCase()}_${i + 1}`,
        entityType: entityType as any,
        position: [
          (Math.random() - 0.5) * 20, // x: -10 to 10
          (Math.random() - 0.5) * 20, // y: -10 to 10
          (Math.random() - 0.5) * 20  // z: -10 to 10
        ] as [number, number, number],
        starTexture: starTexture as any,
        title: this.generateMockEntityTitle(entityType, i),
        relevanceScore: 0.7 + Math.random() * 0.3,
        connectionType: starTexture === 'medium_star' ? '1_hop' : starTexture === 'dim_star' ? '2_hop' : undefined,
        connectedTo: starTexture !== 'bright_star' ? [`mock_memoryunit_${i}`] : undefined
      });
    }
    
    return entities;
  }
  
  private static generateMockEntityTitle(entityType: string, index: number): string {
    const titles = {
      'MemoryUnit': [
        'First day at the new job',
        'Weekend hiking adventure',
        'Family dinner celebration',
        'Learning to play guitar',
        'Moving to a new city',
        'Graduation ceremony'
      ],
      'Concept': [
        'Personal growth and development',
        'Work-life balance',
        'Creative expression',
        'Health and wellness',
        'Learning and curiosity',
        'Relationships and connections'
      ],
      'GrowthEvent': [
        'Career milestone achievement',
        'Overcoming a major challenge',
        'Discovering a new passion',
        'Building meaningful relationships',
        'Developing new skills',
        'Personal transformation'
      ]
    };
    
    const entityTitles = titles[entityType as keyof typeof titles] || titles['MemoryUnit'];
    return entityTitles[index % entityTitles.length];
  }
  
  private static generateMockResponse(question: string): string {
    const responses = {
      'skating': "You started skating in 2018, went through these injuries and you recovered from the setback. Skating for you means determination, resilience, and personal growth. It aligns with your values of perseverance and self-improvement. Would you like me to take you on a walk through your personal cosmos graph?",
      'work': "Your professional journey shows remarkable growth and adaptability. From your early career challenges to your current achievements, you've demonstrated resilience and continuous learning. Your work reflects your values of innovation and collaboration. Would you like me to take you on a walk through your professional cosmos?",
      'travel': "Your travel experiences have shaped your worldview and personal growth. Each journey has taught you something new about yourself and the world around you. These adventures reflect your curiosity and openness to new experiences. Would you like me to take you on a walk through your travel memories?",
      'default': "Your experiences reveal fascinating patterns of growth and self-discovery. These memories show your resilience, creativity, and personal evolution. Each moment has contributed to who you are today. Would you like me to take you on a walk through your personal cosmos graph?"
    };
    
    const lowerQuestion = question.toLowerCase();
    if (lowerQuestion.includes('skating')) return responses.skating;
    if (lowerQuestion.includes('work') || lowerQuestion.includes('job')) return responses.work;
    if (lowerQuestion.includes('travel')) return responses.travel;
    return responses.default;
  }
  
  private static generateMockWalkthroughScript(): WalkthroughStep[] {
    return [
      {
        stepId: "step_1",
        entityId: "mock_memoryunit_1",
        entityType: "MemoryUnit",
        narrative: "This memory shows your first significant experience in this area, where you discovered something important about yourself.",
        cameraPosition: [10.5, 2.3, -5.7],
        cameraTarget: [10.5, 2.3, -5.7],
        duration: 3000,
        transitionType: "smooth",
        highlightColor: "#ff6b6b",
        relatedSteps: ["step_2"]
      },
      {
        stepId: "step_2",
        entityId: "mock_memoryunit_2",
        entityType: "MemoryUnit",
        narrative: "Here's where you faced a challenge that tested your resolve and helped you grow.",
        cameraPosition: [-8.2, 1.1, 3.4],
        cameraTarget: [-8.2, 1.1, 3.4],
        duration: 3000,
        transitionType: "smooth",
        highlightColor: "#4ecdc4",
        relatedSteps: ["step_1", "step_3"]
      },
      {
        stepId: "step_3",
        entityId: "mock_concept_1",
        entityType: "Concept",
        narrative: "This concept represents the deeper meaning and patterns you've discovered through your experiences.",
        cameraPosition: [5.2, -1.8, 7.3],
        cameraTarget: [5.2, -1.8, 7.3],
        duration: 3000,
        transitionType: "smooth",
        highlightColor: "#45b7d1",
        relatedSteps: ["step_2"]
      }
    ];
  }
  
  private static generateMockReflectiveQuestion(question: string): string {
    const questions = [
      "What patterns do you notice in your journey that reflect your personal growth?",
      "How have these experiences shaped your current perspective?",
      "What connections do you see between these different aspects of your life?",
      "What insights about yourself emerge from exploring these memories?",
      "How do these experiences align with your values and goals?"
    ];
    
    return questions[Math.floor(Math.random() * questions.length)];
  }
  
  private static getCapsuleColor(index: number): string {
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
    return colors[index % colors.length];
  }
  
  private static getCapsuleCategory(phrase: string): string {
    const categories = {
      'skating': 'Activity',
      'work': 'Professional',
      'travel': 'Experience',
      'family': 'Relationships',
      'health': 'Wellness',
      'education': 'Learning'
    };
    
    return categories[phrase.toLowerCase() as keyof typeof categories] || 'General';
  }
}

// Types for mock data
interface QuestMockSequence {
  execution_id: string;
  batches: Array<{
    delay: number;
    data: any;
  }>;
}
```

#### **2. Mock WebSocket Service**

```typescript
// apps/web-app/src/services/mockQuestWebSocket.ts
export class MockQuestWebSocket {
  private listeners: Map<string, Function[]> = new Map();
  private isConnected: boolean = false;
  private current_execution_id: string | null = null;
  
  constructor() {
    this.setupMockConnection();
  }
  
  /**
   * Simulate WebSocket connection
   */
  private setupMockConnection(): void {
    // Simulate connection delay
    setTimeout(() => {
      this.isConnected = true;
      this.emit('connect', { message: 'Mock WebSocket connected' });
    }, 100);
  }
  
  /**
   * Join a quest room (mock)
   */
  joinQuest(execution_id: string): void {
    this.current_execution_id = execution_id;
    console.log(`[Mock WebSocket] Joined quest room: ${execution_id}`);
  }
  
  /**
   * Leave quest room (mock)
   */
  leaveQuest(execution_id: string): void {
    if (this.current_execution_id === execution_id) {
      this.current_execution_id = null;
    }
    console.log(`[Mock WebSocket] Left quest room: ${execution_id}`);
  }
  
  /**
   * Start mock quest processing
   */
  startMockQuest(question: string): void {
    if (!this.isConnected) {
      console.error('[Mock WebSocket] Not connected');
      return;
    }
    
    const sequence = MockQuestDataGenerator.generateCompleteQuestSequence(question);
    this.currentExecutionId = sequence.executionId;
    
    // Simulate progressive updates
    sequence.batches.forEach((batch, index) => {
      setTimeout(() => {
        if (this.currentExecutionId === sequence.executionId) {
          this.emit('quest:update', batch.data);
          console.log(`[Mock WebSocket] Sent batch ${index + 1}:`, batch.data.type);
        }
      }, batch.delay);
    });
  }
  
  /**
   * Add event listener
   */
  on(event: string, callback: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event)!.push(callback);
  }
  
  /**
   * Remove event listener
   */
  off(event: string, callback: Function): void {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }
  
  /**
   * Emit event to listeners
   */
  private emit(event: string, data: any): void {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }
  
  /**
   * Disconnect mock WebSocket
   */
  disconnect(): void {
    this.isConnected = false;
    this.current_execution_id = null;
    this.listeners.clear();
    console.log('[Mock WebSocket] Disconnected');
  }
}
```

#### **3. Mock Quest Hook**

```typescript
// apps/web-app/src/hooks/useMockQuest.ts
import { useState, useEffect, useCallback } from 'react';
import { MockQuestWebSocket } from '../services/mockQuestWebSocket';
import { MockQuestDataGenerator } from '../utils/mockQuestData';

export const useMockQuest = () => {
  const [questState, setQuestState] = useState<QuestState>({
    isProcessing: false,
    execution_id: null,
    key_phrases: [],
    visualization_stages: { stage1: [], stage2: [], stage3: [] },
    walkthrough_script: [],
    response: '',
    reflective_question: '',
    error: null
  });
  
  const [mockWebSocket] = useState(() => new MockQuestWebSocket());
  
  useEffect(() => {
    // Set up WebSocket listeners
    mockWebSocket.on('connect', () => {
      console.log('[Mock Quest] WebSocket connected');
    });
    
    mockWebSocket.on('quest:update', (data) => {
      handleQuestUpdate(data);
    });
    
    return () => {
      mockWebSocket.disconnect();
    };
  }, [mockWebSocket]);
  
  const handleQuestUpdate = useCallback((data: any) => {
    console.log('[Mock Quest] Received update:', data.type);
    
    switch (data.type) {
      case 'key_phrases':
        setQuestState(prev => ({
          ...prev,
          key_phrases: data.capsules
        }));
        break;
        
      case 'visualization_stage_1':
        setQuestState(prev => ({
          ...prev,
          visualization_stages: {
            ...prev.visualization_stages,
            stage1: data.entities
          }
        }));
        break;
        
      case 'visualization_stages_2_3':
        setQuestState(prev => ({
          ...prev,
          visualization_stages: {
            ...prev.visualization_stages,
            stage2: data.stage2.entities,
            stage3: data.stage3.entities
          }
        }));
        break;
        
      case 'final_response':
        setQuestState(prev => ({
          ...prev,
          response: data.response_text,
          walkthrough_script: data.walkthrough_script,
          reflective_question: data.reflective_question,
          isProcessing: false
        }));
        break;
        
      case 'error':
        setQuestState(prev => ({
          ...prev,
          error: data.message,
          isProcessing: false
        }));
        break;
    }
  }, []);
  
  const startQuest = useCallback((question: string) => {
    if (questState.isProcessing) {
      console.warn('[Mock Quest] Quest already in progress');
      return;
    }
    
    // Reset state
    setQuestState({
      isProcessing: true,
      execution_id: null,
      key_phrases: [],
      visualization_stages: { stage1: [], stage2: [], stage3: [] },
      walkthrough_script: [],
      response: '',
      reflective_question: '',
      error: null
    });
    
    // Start mock quest
    mockWebSocket.startMockQuest(question);
  }, [questState.isProcessing, mockWebSocket]);
  
  const resetQuest = useCallback(() => {
    setQuestState({
      isProcessing: false,
      execution_id: null,
      key_phrases: [],
      visualization_stages: { stage1: [], stage2: [], stage3: [] },
      walkthrough_script: [],
      response: '',
      reflective_question: '',
      error: null
    });
  }, []);
  
  return {
    questState,
    startQuest,
    resetQuest,
    isConnected: mockWebSocket.isConnected
  };
};
```

#### **4. Mock Quest Component**

```typescript
// apps/web-app/src/components/cosmos/MockQuestScene.tsx
import React, { useState } from 'react';
import { useMockQuest } from '../../hooks/useMockQuest';
import { Graph3D } from './Graph3D';
import { KeyPhraseCapsules } from './KeyPhraseCapsules';
import { WalkthroughControls } from './WalkthroughControls';

export const MockQuestScene: React.FC = () => {
  const [question, setQuestion] = useState('');
  const { questState, startQuest, resetQuest, isConnected } = useMockQuest();
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (question.trim() && !questState.isProcessing) {
      startQuest(question.trim());
    }
  };
  
  return (
    <div className="mock-quest-scene">
      <div className="quest-controls">
        <h2>Mock Quest Testing</h2>
        <p>Status: {isConnected ? 'Connected' : 'Disconnected'}</p>
        
        <form onSubmit={handleSubmit}>
          <input
            type="text"
            value={question}
            onChange={(e) => setQuestion(e.target.value)}
            placeholder="Ask a question about your memories..."
            disabled={questState.isProcessing}
          />
          <button 
            type="submit" 
            disabled={questState.isProcessing || !question.trim()}
          >
            {questState.isProcessing ? 'Processing...' : 'Start Quest'}
          </button>
        </form>
        
        <button onClick={resetQuest} disabled={questState.isProcessing}>
          Reset Quest
        </button>
      </div>
      
      <div className="quest-content">
        {/* Key Phrase Capsules */}
        {questState.keyPhrases.length > 0 && (
          <KeyPhraseCapsules capsules={questState.keyPhrases} />
        )}
        
        {/* 3D Visualization */}
        <div className="visualization-container">
          <Graph3D 
            visualizationStages={questState.visualizationStages}
            isProcessing={questState.isProcessing}
          />
        </div>
        
        {/* Response and Walkthrough */}
        {questState.response && (
          <div className="quest-response">
            <p>{questState.response}</p>
            
            {questState.walkthroughScript.length > 0 && (
              <WalkthroughControls 
                walkthroughScript={questState.walkthroughScript}
                reflectiveQuestion={questState.reflectiveQuestion}
              />
            )}
          </div>
        )}
        
        {/* Error Display */}
        {questState.error && (
          <div className="quest-error">
            <p>Error: {questState.error}</p>
          </div>
        )}
      </div>
    </div>
  );
};
```

#### **5. Testing Scenarios**

```typescript
// apps/web-app/src/utils/mockQuestScenarios.ts
export const MockQuestScenarios = {
  skating: {
    question: "What do you know about my skating experience?",
    expectedPhrases: ["skating", "ice skating", "roller skating"],
    expectedEntities: 6,
    expectedResponse: "You started skating in 2018..."
  },
  
  work: {
    question: "Tell me about my work journey",
    expectedPhrases: ["work", "job", "career"],
    expectedEntities: 5,
    expectedResponse: "Your professional journey shows remarkable growth..."
  },
  
  travel: {
    question: "What are my travel memories?",
    expectedPhrases: ["travel", "trip", "vacation"],
    expectedEntities: 4,
    expectedResponse: "Your travel experiences have shaped your worldview..."
  },
  
  error: {
    question: "This will cause an error",
    shouldError: true,
    errorMessage: "Mock error for testing"
  }
};

// Test runner
export const runMockQuestTests = async () => {
  console.log('[Mock Quest Tests] Starting test scenarios...');
  
  for (const [scenarioName, scenario] of Object.entries(MockQuestScenarios)) {
    console.log(`[Mock Quest Tests] Running scenario: ${scenarioName}`);
    
    // Test the scenario
    const result = await testScenario(scenario);
    
    if (result.success) {
      console.log(`✅ ${scenarioName}: PASSED`);
    } else {
      console.log(`❌ ${scenarioName}: FAILED - ${result.error}`);
    }
  }
};
```

### **Usage Instructions**

1. **Install Mock Quest Hook**: Use `useMockQuest()` in your components
2. **Test Different Scenarios**: Try various questions to see different mock responses
3. **Verify UI Responsiveness**: Check that all 4 batches update the UI correctly
4. **Test Error Handling**: Simulate error scenarios
5. **Performance Testing**: Verify smooth animations and transitions

### **Benefits of This Mocking Strategy**

1. **Independent Development**: Frontend can be developed without backend
2. **Realistic Testing**: Mock data closely resembles real CosmosQuestAgent output
3. **Progressive Updates**: Tests the 4-batch update system
4. **Error Scenarios**: Can test error handling and edge cases
5. **Performance Validation**: Can test UI responsiveness and animations
6. **Easy Switching**: Can easily switch between mock and real data

This mocking strategy allows you to fully develop and test the frontend UI while the backend is being implemented, ensuring a smooth integration when both are ready.

## **Implementation Architecture**

### **Phase 1: Core Agent Implementation**

```typescript
export class CosmosQuestAgent {
  private configService: ConfigService;
  private conversationRepo: ConversationRepository;
  private redis: Redis;
  private promptBuilder: PromptBuilder;
  private llmChatTool: any;
  private visionCaptionTool: any;
  private audioTranscribeTool: any;
  private documentExtractTool: any;
  private cosmosQuestTool: CosmosQuestTool;

  constructor(dependencies: CosmosQuestAgentDependencies) {
    // Initialize dependencies (same pattern as DialogueAgent)
  }

  /**
   * Main entry point for cosmos quest processing
   */
  public async processQuest(input: CosmosQuestInput): Promise<CosmosQuestResult> {
    const execution_id = `cq_${Date.now()}`;
    console.log(`[${execution_id}] Starting cosmos quest processing`);

    // --- PHASE I: INPUT PRE-PROCESSING (Reuse DialogueAgent logic) ---
    const { processedText: finalInputText, visionAnalysis, documentAnalysis } = 
      await this.processInput(input.userQuestion, input.currentMessageMedia);

    // --- PHASE II: KEY PHRASE EXTRACTION (Always extract, no decision logic) ---
    const keyPhrases = await this.extractKeyPhrases(finalInputText);
    const capsules = await this.createKeyPhraseCapsules(keyPhrases);

    // --- PHASE III: ALWAYS RETRIEVE MEMORY (Bypass decision logic) ---
    const questResult = await this.cosmosQuestTool.execute({
      keyPhrases,
      userId: input.userId,
      userQuestion: finalInputText,
      // Single unified quest experience
    });

    // --- PHASE IV: GENERATE RESPONSE + WALKTHROUGH ---
    const { response, walkthroughScript, reflectiveQuestion } = 
      await this.generateResponseWithWalkthrough(finalInputText, questResult);

    // --- PHASE V: CONTEXT PERSISTENCE (Quest-specific) ---
    await this.persistQuestContext(input.conversationId, {
      execution_id,
      keyPhrases,
      walkthroughScript,
      questResult
    });

    return {
      response_text: response,
      keyPhrases,
      capsules,
      visualizationStages: questResult.visualizationStages,
      walkthroughScript,
      reflectiveQuestion,
      metadata: {
        execution_id: execution_id,
        processing_time_ms: Date.now() - parseInt(execution_id.split('_')[1]),
        memory_retrieval_performed: true,
        entities_retrieved: questResult.retrievedMemoryUnits?.length || 0,
        visualization_stages_completed: 3
      },
      vision_analysis: visionAnalysis,
      document_analysis: documentAnalysis
    };
  }
}
```

### **Phase 2: Key Phrase Extraction (Reuse DialogueAgent Logic)**

```typescript
private async extractKeyPhrases(question: string): Promise<string[]> {
  // Reuse DialogueAgent's key phrase extraction logic
  // But always extract (no decision needed)
  
  const prompt = `
  Extract key phrases from this question for memory retrieval:
  "${question}"
  
  Return as JSON array of strings:
  ["phrase1", "phrase2", "phrase3"]
  `;
  
  const response = await this.llmChatTool.execute({
    messages: [{ role: 'user', content: prompt }],
    temperature: 0.3
  });
  
  return this.parseKeyPhrases(response);
}

private async createKeyPhraseCapsules(keyPhrases: string[]): Promise<KeyPhraseCapsule[]> {
  // Create visual capsules for each key phrase
  return keyPhrases.map((phrase, index) => ({
    phrase_id: `capsule_${Date.now()}_${index}`,
    phrase: phrase,
    confidence_score: 0.8 + (Math.random() * 0.2), // Mock confidence
    color: this.getCapsuleColor(phrase),
    type: this.categorizePhrase(phrase),
    semantic_score: 0.7 + (Math.random() * 0.3),
    related_entity_ids: [] // Will be populated by CosmosQuestTool
  }));
}
```

### **Phase 3: Response + Walkthrough Generation**

```typescript
private async generateResponseWithWalkthrough(
  question: string,
  questResult: CosmosQuestResult
): Promise<{ response: string; walkthroughScript: WalkthroughStep[]; reflectiveQuestion: string }> {
  
  const prompt = `
  Based on the retrieved memory context, provide:
  1. A comprehensive response to: "${question}"
  2. A walkthrough script that guides the user through the most relevant entities
  3. A reflective question to end the journey
  
  Retrieved Context:
  Memory Units: ${JSON.stringify(questResult.retrievedMemoryUnits?.slice(0, 5))}
  Concepts: ${JSON.stringify(questResult.retrievedConcepts?.slice(0, 5))}
  
  Generate a walkthrough script with these steps:
  - Start with the most impactful memory/concept
  - Progress through related entities
  - End with a broader perspective
  - Include camera positions and narrative for each step
  
  Return as JSON:
  {
    "response": "Your comprehensive response...",
    "walkthroughScript": [
      {
        "stepId": "step_1",
        "entityId": "entity_id",
        "entityType": "MemoryUnit",
        "narrative": "This memory shows...",
        "cameraPosition": [x, y, z],
        "cameraTarget": [x, y, z],
        "duration": 3000,
        "transitionType": "smooth",
        "highlightColor": "#ff6b6b"
      }
    ],
    "reflectiveQuestion": "What patterns do you notice in your journey?"
  }
  `;
  
  const response = await this.llmChatTool.execute({
    messages: [{ role: 'user', content: prompt }],
    temperature: 0.7
  });
  
  return this.parseWalkthroughResponse(response);
}
```

### **Phase 4: Context Persistence (Quest-Specific)**

```typescript
private async persistQuestContext(
  conversationId: string | undefined,
  context: {
    executionId: string;
    keyPhrases: string[];
    walkthroughScript: WalkthroughStep[];
    questResult: CosmosQuestResult;
  }
): Promise<void> {
  if (!conversationId) return;
  
  try {
    const questContext = {
      ...context,
      timestamp: new Date().toISOString(),
      type: 'cosmos_quest'
    };
    
    await this.redis.set(
      `quest_context:${conversationId}`,
      JSON.stringify(questContext),
      'EX', 1800 // 30 min TTL (longer than DialogueAgent)
    );
    
    console.log(`✅ CosmosQuestAgent - Quest context saved for ${conversationId}`);
  } catch (error) {
    console.error(`❌ CosmosQuestAgent - Failed to save quest context:`, error);
  }
}
```

## **CosmosQuestTool Integration**

### **Specialized Tool for Quest Mode**

```typescript
// packages/tools/src/retrieval/CosmosQuestTool.ts
export class CosmosQuestTool {
  // Reuse HRT's internal components
  private weaviate: WeaviateClient;
  private cypherBuilder: CypherBuilder;
  private hydrationAdapter: HydrationAdapter;
  
  // Skip EntityScorer for speed
  async execute(input: CosmosQuestInput): Promise<CosmosQuestResult> {
    // Stage 1: Key Phrase Processing (same as HRT)
    const processedPhrases = await this.processKeyPhrases(input.keyPhrases);
    
    // Stage 2: Semantic Grounding (same as HRT)
    const seedEntities = await this.semanticGrounding(processedPhrases, input.userId);
    
    // Stage 3: Graph Traversal (same as HRT)
    const candidateEntities = await this.graphTraversal(seedEntities, input.userId);
    
    // Stage 4: Pre-Hydration (same as HRT)
    const metadataMap = await this.preHydration(candidateEntities, input.userId);
    
    // Stage 5: Simple Ordering (skip complex scoring)
    const orderedEntities = this.simpleOrdering(candidateEntities, seedEntities);
    
    // Stage 6: Full Content Hydration (same as HRT)
    const hydratedEntities = await this.fullContentHydration(orderedEntities, input.userId);
    
    // Stage 7: Create Visualization Stages (NEW)
    const visualizationStages = this.createVisualizationStages(seedEntities, candidateEntities);
    
    return {
      retrievedMemoryUnits: hydratedEntities.memoryUnits,
      retrievedConcepts: hydratedEntities.concepts,
      visualizationStages,
      metadata: {
        totalEntities: hydratedEntities.totalCount,
        processingTime: Date.now() - startTime
      }
    };
  }
  
  private createVisualizationStages(
    seedEntities: SeedEntity[],
    candidateEntities: CandidateEntity[]
  ): VisualizationStages {
    return {
      stage1: {
        type: 'semantic_similarity',
        entities: seedEntities,
        starTexture: 'bright_star'
      },
      stage2: {
        type: 'graph_hops_1',
        entities: candidateEntities.filter(e => e.hopDistance === 1),
        starTexture: 'medium_star'
      },
      stage3: {
        type: 'graph_hops_2',
        entities: candidateEntities.filter(e => e.hopDistance === 2),
        starTexture: 'dim_star'
      }
    };
  }
}
```

## **Frontend Integration**

### **CosmosQuestScene Integration**

```typescript
// apps/web-app/src/app/cosmos/quest/CosmosQuestScene.tsx
const handleQuestInput = async (question: string) => {
  const result = await cosmosQuestAgent.processQuest({
    userQuestion: question,
    userId: 'dev-user',
    // Single unified quest experience
  });
  
  // Update visualization with progressive stages
  setVisualizationStages(result.visualizationStages);
  
  // Show LLM response
  setLlmResponse(result.response_text);
  
  // Enable walkthrough
  setWalkthroughScript(result.walkthroughScript);
  
  // Show key phrase capsules
  setKeyPhraseCapsules(result.capsules);
};
```

## **Performance Considerations**

### **Optimization Strategies**

1. **Fast Memory Retrieval**: Skip complex scoring, use simple ordering
2. **Progressive Loading**: Stream visualization stages as they complete
3. **Caching**: Cache key phrase extraction results
4. **Parallel Processing**: Run key phrase extraction and memory retrieval in parallel
5. **Lazy Loading**: Load walkthrough scripts only when needed

### **Expected Performance**

- **Key Phrase Extraction**: ~200-500ms
- **Memory Retrieval**: ~800-1500ms (faster than HRT due to simplified scoring)
- **Response Generation**: ~1000-2000ms
- **Walkthrough Script**: ~500-1000ms
- **Total Quest Time**: ~2.5-5 seconds

## **Error Handling & Graceful Degradation**

### **Error Scenarios**

1. **Memory Retrieval Failure**: Fall back to semantic search only
2. **LLM Response Failure**: Return basic response with available data
3. **Walkthrough Generation Failure**: Skip walkthrough, provide basic navigation
4. **Visualization Failure**: Fall back to static graph display

### **Graceful Degradation Strategy**

```typescript
private async handleQuestWithFallback(input: CosmosQuestInput): Promise<CosmosQuestResult> {
  try {
    return await this.processQuest(input);
  } catch (error) {
    console.error('Quest processing failed, falling back to basic mode:', error);
    
    // Fallback: Basic memory retrieval without walkthrough
    const basicResult = await this.processBasicQuest(input);
    return {
      ...basicResult,
      walkthroughScript: [], // Empty walkthrough
      reflectiveQuestion: "What would you like to explore next?"
    };
  }
}
```

## **Testing Strategy**

### **Unit Tests**

1. **Key Phrase Extraction**: Test phrase extraction accuracy
2. **Capsule Creation**: Test visual capsule generation
3. **Walkthrough Generation**: Test script creation logic
4. **Context Persistence**: Test Redis storage/retrieval

### **Integration Tests**

1. **End-to-End Quest**: Test complete quest flow
2. **CosmosQuestTool Integration**: Test tool integration
3. **Frontend Integration**: Test scene integration
4. **Performance Tests**: Test response times

### **User Acceptance Tests**

1. **Quest Experience**: Test user journey through memory exploration
2. **Visualization Quality**: Test 3D visualization effectiveness
3. **Walkthrough Smoothness**: Test camera animations
4. **Reflective Questions**: Test end-of-journey insights

## **Deployment & Configuration**

### **Environment Variables**

```bash
# Cosmos Quest specific
COSMOS_QUEST_ENABLED=true
COSMOS_QUEST_CACHE_TTL=1800
COSMOS_QUEST_MAX_ENTITIES=50
COSMOS_QUEST_WALKTHROUGH_ENABLED=true
```

### **Configuration Files**

```yaml
# config/cosmos_quest_config.yaml
cosmos_quest:
  key_phrase_extraction:
    max_phrases: 5
    confidence_threshold: 0.7
  visualization:
    max_stages: 3
    stage_duration_ms: 2000
  walkthrough:
    max_steps: 10
    default_duration_ms: 3000
    transition_types: ['smooth', 'instant', 'zoom']
```

## **Future Enhancements**

### **Phase 2 Features**

1. **Multi-Modal Quests**: Support for image/audio input
2. **Collaborative Quests**: Multiple users exploring together
3. **Quest Templates**: Pre-defined exploration patterns
4. **Advanced Animations**: More sophisticated camera movements

### **Phase 3 Features**

1. **AI-Generated Quests**: LLM creates custom exploration paths
2. **Emotional Mapping**: Visualize emotional connections
3. **Temporal Quests**: Time-based memory exploration
4. **Export/Share**: Save and share quest experiences

## **Conclusion**

The `CosmosQuestAgent` represents a new paradigm in conversational AI, combining the power of memory retrieval with immersive 3D visualization. By always retrieving memory and generating guided walkthroughs, it creates a unique user experience that bridges the gap between conversation and spatial exploration.

The agent leverages existing infrastructure from the `DialogueAgent` while introducing specialized components for quest-specific functionality, ensuring both reusability and focused purpose.

This specification provides a comprehensive foundation for implementing the CosmosQuestAgent while maintaining architectural consistency with the existing V11.0 system.
