

- I reviewed the V11.0 spec for `CosmosQuestAgent` and scanned the repo for current frontend and backend building blocks.
- I’ll propose an incremental, testable roadmap that layers features one by one on existing code (`CosmosLookupScene.tsx`) and infra (API Gateway + NotificationWorker), with clear test/verify steps per milestone.

### Ultimate goal (from the spec)
- Always retrieve memory for a user question, progressively stream 4 batches to the UI via WebSocket:
  1) key phrases,
  2) stage 1 (semantic matches),
  3) stages 2-3 (graph hops),
  4) final response + walkthrough script.
- Persist quest context and metadata; reuse infra (auth, repos, Redis, Socket.IO), and keep controllers thin.

### What exists now
- Frontend has `apps/web-app/src/app/cosmos/lookup/CosmosLookupScene.tsx` doing manual Weaviate + Neo4j fetches and projecting into `Graph3D`.
- Backend has API v1 routes/controllers (no quest endpoint yet) and a dedicated `NotificationWorker` with Socket.IO infra ready to be extended for quest rooms/events.
- Spec contains mock strategy (mock data generator, mock websocket, mock hook) to develop UI independently.

### Incremental roadmap (build → test → iterate)
- Each step is small, verifiable, and shippable. Stop after each to validate.

1) Frontend-only mocks (no backend)
- Build:
  - Add `apps/web-app/src/utils/mockQuestData.ts` (generator from spec).
  - Add `apps/web-app/src/services/mockQuestWebSocket.ts` (mock emitter).
  - Add `apps/web-app/src/hooks/useMockQuest.ts` (state + handlers consuming mock events).
  - Option A: Create `apps/web-app/src/components/cosmos/MockQuestScene.tsx` (from spec) OR
  - Option B: Lightly extend `CosmosLookupScene` to optionally run “Quest Mode” using the mock hook (recommended: separate component to keep Lookup focused).
- Test:
  - Start mock quest; verify 4 staged updates appear in order: capsules → bright stars → medium/dim stars → final response and walkthrough.
  - Confirm `Graph3D` renders staged nodes and UI responds smoothly.

2) WebSocket plumbing via NotificationWorker (no LLM yet)
- Build:
  - Extend `workers/notification-worker/src/NotificationWorker.ts` with quest rooms (`quest:join`/`quest:leave`) and a method to emit `quest:update` to `quest:${executionId}`.
  - Add `apps/web-app/src/hooks/useQuestConnection.ts` to connect to Socket.IO, join a quest room, and surface staged updates to React state (mirrors the mock hook interface).
- Test:
  - Connect from frontend; verify join/leave logs in worker.
  - Manually emit a test `quest:update` from worker (small script or temp endpoint) and confirm UI receives and renders it.

3) Minimal quest endpoint that immediately returns executionId and simulates batches
- Build:
  - Add `POST /api/v1/quest/process` in `apps/api-gateway/src/routes/v1/quest.routes.ts` and controller `apps/api-gateway/src/controllers/quest.controller.ts`.
  - On request: generate `executionId`, return `executionId` immediately; in background, simulate batches (use `setTimeout`) and send them via NotificationWorker’s `quest:update` to `quest:${executionId}`.
- Test:
  - Call endpoint via REST client; frontend joins `quest:${executionId}` and receives simulated batches.
  - Verify error handling path (send `type: 'error'`).

4) Agent Phase 1: Batch 1 (key phrases) real generation
- Build:
  - Create `apps/web-app/src/services/cosmosQuestAgent.ts` with a `processQuest` that extracts key phrases (simple heuristic or reuse DialogueAgent’s phrase extraction if available) and emits Batch 1; keep Batches 2-4 simulated as before.
- Test:
  - Submit various questions; confirm capsules change accordingly.

5) Agent Phase 2: Stage 1 semantic matches (reuse Weaviate logic from Lookup)
- Build:
  - In `CosmosQuestAgent`, use Weaviate “nearObject/nearText” flow similar to `CosmosLookupScene.tsx` to get a seed set. Emit Batch 2 with bright stars.
- Test:
  - Validate entities count and star texture; confirm UI updates Stage 1 while other batches remain simulated.

6) Agent Phase 3: Stages 2-3 graph hops (reuse Neo4j flow from Lookup)
- Build:
  - Use existing Neo4j query route (`/api/v1/neo4j/query` is used inside `CosmosLookupScene`), or add a small service method, to fetch 1-hop and 2-hop connections; emit Batch 3 with medium/dim stars.
- Test:
  - Run with known high-connectivity IDs (the sample IDs listed inside `CosmosLookupScene.tsx`). Confirm edges and connected entities appear.

7) Agent Phase 4: Final response + walkthrough stub
- Build:
  - Generate a concise `response_text` and a small `walkthrough_script` (LLM stub or template-driven for now). Emit Batch 4.
  - Add `apps/web-app/src/services/questPromptBuilder.ts` when ready; wire templates from `config/prompt_templates.yaml` per spec later.
- Test:
  - Verify JSON structure and the UI’s walkthrough controls.

8) Persistence
- Build:
  - Save quest metadata and Redis context per spec in conversation/message repositories; if migrations are required for `type` fields, add Prisma migration (as in spec), and use repos under `packages/database/src/repositories/`.
- Test:
  - Assert records written, Redis key set with proper TTL; add read-back verification.

9) Replace sims with real steps progressively
- Replace previously simulated batches with real ones as soon as each phase is solid.
- Add unit/integration tests:
  - Endpoint returns executionId.
  - NotificationWorker emits and clients receive.
  - Weaviate and Neo4j integrations return expected shapes.
  - UI renders each batch and transitions properly.

### Where to put things (paths)
- Frontend
  - `apps/web-app/src/utils/mockQuestData.ts`
  - `apps/web-app/src/services/mockQuestWebSocket.ts`
  - `apps/web-app/src/hooks/useMockQuest.ts`
  - `apps/web-app/src/hooks/useQuestConnection.ts`
  - `apps/web-app/src/components/cosmos/MockQuestScene.tsx`
  - Optional: a new page `apps/web-app/src/app/cosmos/quest/page.tsx` wiring the mock or live scene
- Backend
  - API Gateway: `apps/api-gateway/src/routes/v1/quest.routes.ts`, `apps/api-gateway/src/controllers/quest.controller.ts` (thin)
  - Agent (library location per spec): `apps/web-app/src/services/cosmosQuestAgent.ts` initially; long-term may move to services/workers if needed per V9.5 architecture
  - NotificationWorker: `workers/notification-worker/src/NotificationWorker.ts` (quest rooms + `quest:update`)

### Acceptance criteria per step
- Step 1 (mock UI): 4-batch flow renders end-to-end using only mock, with clear transitions.
- Step 2 (WS plumbing): client can join quest room; receives fake `quest:update`.
- Step 3 (endpoint): endpoint returns `executionId` and UI receives simulated batches linked to that `executionId`.
- Step 4 (Batch 1 real): key phrases change meaningfully by question.
- Step 5 (Stage 1 real): bright stars populate from Weaviate results.
- Step 6 (Stages 2-3 real): medium/dim stars populate via Neo4j graph traversal.
- Step 7 (final response): walkthrough script appears and drives UI.
- Step 8 (persistence): Redis context present; conversation/message metadata recorded.

### Testing guidance after each step
- Frontend: visually verify batch order and transitions; check console logs already present in `CosmosLookupScene.tsx` for node counts and positions; ensure camera/focus works.
- Backend: use REST client for `/api/v1/quest/process`; inspect NotificationWorker logs; probe Socket.IO with a local client; validate Redis keys and DB records as changes are added.

### Assumptions
- We can reuse Weaviate and Neo4j query shapes already proven in `CosmosLookupScene.tsx`.
- We will extend the existing Socket.IO in `NotificationWorker` rather than creating a new WS service (per spec).
- We keep controllers thin and push quest logic into an agent/service; configuration via `/config/` and envs; pnpm-only.

- I created a todo list to track this sequence. When you’re ready, I can begin with Step 1 (mock UI) and wire it into a new `MockQuestScene` or add a toggle on `CosmosLookupScene` for a mock quest mode, then proceed step-by-step.

