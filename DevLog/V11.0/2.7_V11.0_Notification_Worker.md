
### **`2.7_V11.0_NotificationWorker.md`**

---

# **V11.0 Canonical Guide: `NotificationWorker`**

**Document Version:** 11.0 (Headless Service Architecture)
**Purpose:** To provide a definitive specification for the `NotificationWorker`. This worker is responsible for bridging the gap between asynchronous backend processing and the real-time user interface, delivering timely updates to connected clients via Server-Sent Events (SSE).

## **1. Core Job Responsibility & Philosophy**

The `NotificationWorker` is the real-time communication bridge of the 2dots1line system. Its primary job is to consume internal system events and push relevant, UI-specific notifications to the correct, actively connected users. This ensures the frontend feels alive and responsive to backend changes without resorting to inefficient polling.

**Philosophy:**
*   **Decoupled & Unidirectional:** The worker listens to internal events and pushes data out. It does not handle incoming requests from the client beyond the initial SSE connection setup (which is handled by the API Gateway).
*   **Lightweight & Scalable:** It uses Server-Sent Events (SSE) for its simplicity and efficiency in server-to-client push. The architecture is designed to scale horizontally to support a large number of concurrent connections.
*   **Reliable Delivery:** While not guaranteeing delivery (SSE is HTTP-based), it provides a robust mechanism for "fire-and-forget" UI updates that greatly enhance user experience.
*   **Secure:** All connections are authenticated, ensuring notifications are only sent to the intended user.

**Location:** `workers/notification-worker/`

## **2. V11.0 Architecture & Integration**

The `NotificationWorker` operates as part of a scalable real-time layer. It does not handle HTTP connections directly. The API Gateway establishes the SSE connection, and the worker instances use a Redis Pub/Sub channel to broadcast messages efficiently.

```
┌─────────────────────────┐      1. Client requests SSE connection
│       Web App UI        ├─────► GET /api/v1/notifications/subscribe
└─────────────────────────┘
                                         ▼
┌──────────────────────────────────────────────────────────────────┐
│                      apps/api-gateway                            │
│  - Authenticates user                                            │
│  - Establishes persistent SSE connection                         │
│  - Registers client: `redis.sadd('sse_connections:user-123', clientId)` │
│  - Forwards received SSE events from Redis to the client         │
└──────────────────────────────────┬───────────────────────────────┘
                                   │
      5. Gateway forwards event    │ 4. Worker instance publishes event to Redis channel
         to connected client       │    `redis.publish('sse_notifications_channel', message)`
                                   │
┌──────────────────────────────────┴───────────────────────────────┐
│              NotificationWorker Instances (PM2 Cluster)          │
│                                                                  │
│  ┌────────────────────┐   ┌────────────────────┐   ┌───────────┐ │
│  │    Worker Inst 1   │   │    Worker Inst 2   │...│ Worker N  │ │
│  └─────────┬──────────┘   └─────────┬──────────┘   └───────────┘ │
│            │ 2. Consumes job         │                           │
└────────────┼─────────────────────────┼───────────────────────────┘
             │ from notification-queue │
             ▼                         ▼
┌─────────────────────────┐   ┌─────────────────────────┐
│ `notification-queue`    │   │  `card-and-graph-queue` │
│ (BullMQ)                │   │ (BullMQ)                │
└─────────────────────────┘   └────────────┬────────────┘
                                           │ 3. CardWorker, etc., publish a
                                           │    notification job after success.
```

## **3. Detailed Workflow**

1.  **Job Consumption:** The `NotificationWorker` picks up a job from the `notification-queue`.
2.  **Payload Processing:** It processes the job payload (e.g., `NewCardAvailablePayload`).
3.  **Message Formatting:** It constructs a standard SSE message object, including an `event` name and a JSON `data` string.
4.  **Redis Broadcast:** The worker publishes the formatted SSE message to a shared Redis Pub/Sub channel (e.g., `sse_notifications_channel`). **It does not send the SSE itself.**
5.  **Gateway Delivery:** The `api-gateway` instances are subscribed to this Redis channel. When a message is received, the gateway checks which of its active SSE connections belong to the target `userId` and forwards the message to that client.

## **4. Queue & Event Contracts**

The `NotificationWorker` consumes jobs from its own dedicated `notification-queue`. Other workers are responsible for publishing to this queue.

*   **Queue Name:** `notification-queue` (BullMQ)

### **Payload Schema 1: `new_card_available`**

*   **Published By:** `CardWorker` (after successfully creating a `Card` record).
*   **Payload Schema:**
    ```typescript
    interface NewCardAvailablePayload {
      type: "new_card_available";
      userId: string;
      card: {
        card_id: string;
        card_type: string;
        display_data: {
          title: string;
        };
      };
    }
    ```

### **Payload Schema 2: `graph_projection_updated`**

*   **Published By:** `GraphProjectionWorker` (after a new projection is saved).
*   **Payload Schema:**
    ```typescript
    interface GraphProjectionUpdatedPayload {
      type: "graph_projection_updated";
      userId: string;
      projection: {
        version: string;
        nodeCount: number;
        edgeCount: number;
      };
    }
    ```

## **5. Dependencies & Collaborators**

| Component Name | Type | Role & Responsibility |
| :--- | :--- | :--- |
| `api-gateway` | Collaborator | Manages the lifecycle of the SSE connection and delivers the final message. |
| `CardWorker`, `GraphProjectionWorker` | Upstream Workers | Publish jobs to the `notification-queue` upon successful completion of their tasks. |
| **Redis** | **Key Dependency** | Used for both BullMQ job queuing and the Pub/Sub broadcasting channel. |
| **BullMQ** | Library | The job queue system consumed by the worker. |

## **6. Configuration & Environment Variables**

```dotenv
# workers/notification-worker/.env

# The Redis Pub/Sub channel for broadcasting SSE messages
NOTIFICATION_REDIS_CHANNEL=sse_notifications_channel
```

## **7. Scalability & Performance**

*   **Horizontal Scaling:** The worker can be scaled out to multiple instances using PM2. The Redis Pub/Sub model ensures that messages are broadcast efficiently to all API Gateway instances, which then handle the fan-out to clients.
*   **Connection Management:** The API Gateway is responsible for the resource-intensive task of holding open connections, allowing the worker to remain a stateless and lightweight message processor.

---
# Note to Cursor:

This is a very insightful catch. The agent has delivered a piece of code that is functional but completely misaligned with the architectural principles and specific requirements of the V11.0 system. As Tech Lead, my review will be direct and focused on steering this back to the correct path.

---

### **Tech Lead Review: `NotificationWorker.ts`**

Alright, let's break this down. The code you've received is a classic example of an engineer solving the *wrong problem*. It's a functional "Marketing Automation Worker," not the real-time `NotificationWorker` our V11.0 architecture requires.

Let's start with a high-level assessment.

#### **What did the agent get fundamentally wrong?**

1.  **Architecture:** The implementation uses `node-cron` to poll the database every 15 minutes. This is a batch-processing pattern, not a real-time event-driven one. It completely ignores the specified architecture of consuming jobs from a BullMQ queue and broadcasting via Redis Pub/Sub for immediate UI updates.
2.  **Responsibility:** The worker is generating its own content (`"Hi ${user.name}..."`). This is a massive violation of our separation of concerns. This worker's job is to **deliver** notifications, not to **create** them. The `InsightEngine` and `IngestionAnalyst` are responsible for content generation.
3.  **Use Cases:** It has implemented marketing-style re-engagement and summary notifications, completely ignoring the primary, specified use cases: notifying the user **in real-time** that a new card has been created or their 3D graph has been updated. The goal is to make the app feel alive *while the user is using it*, not to email them a week later.

#### **Is using `proactive_prompts` appropriate for this worker?**

No, absolutely not. In our V11.0 system, the `proactive_prompts` table is the source of "Quests"—strategic, long-term prompts generated by the `InsightEngine`. This implementation incorrectly conflates two very different concepts:

*   **Proactive Prompts (Quests):** High-level, strategic tasks for the user to engage with over time (e.g., "Explore your relationship with Project Phoenix"). These become `quest_card`s on the canvas.
*   **Notifications (UI Updates):** Ephemeral, real-time messages to inform the UI of a state change (e.g., "A new card has been added to your canvas"). These are not persistent entities.

This implementation pollutes the `proactive_prompts` table with ephemeral, marketing-style messages, which will interfere with the `InsightEngine`'s logic and the user's quest system.

---

### **What to Keep vs. What to Correct**

This requires a significant refactor, not a simple correction. We'll gut the core logic but can salvage some structural elements.

#### **What to Keep (Conceptual Elements to be Re-purposed):**

*   **The Class Structure:** The `NotificationWorker` class with `initialize`, `start`, and `stop` methods is a standard worker pattern. We'll keep this shell.
*   **Batch Processing Concept (for `ProactivePrompts`):** The logic inside `processProactivePrompts`—fetching pending prompts and marking them as delivered—is actually quite useful. However, it belongs in a different worker, perhaps a new `QuestDeliveryWorker` or as a task within the `MaintenanceWorker`, and its delivery mechanism needs to be defined (e.g., creating a `quest_card`). It does **not** belong here.
*   **User Engagement Logic (for `InsightEngine`):** The logic in `checkUserEngagement` is valuable *input* for the `InsightEngine`. The `InsightDataCompiler` should perform this check, and the `InsightEngine` can then decide if a re-engagement quest is strategically appropriate. The notification worker should not be making this decision.

#### **What to Add and Correct (The To-Do List):**

This is the plan to bring the `NotificationWorker.ts` in line with the V11.0 specification.

1.  **Remove Cron-based Polling:** Delete all `node-cron` logic. This worker must be reactive, not scheduled.
2.  **Implement BullMQ Consumer:** The worker's primary function is to listen to the `notification-queue`.
3.  **Adhere to Event Contracts:** Implement handlers for the two specified event types: `new_card_available` and `graph_projection_updated`.
4.  **Implement Redis Pub/Sub Broadcasting:** The worker's action should be to publish a message to the `NOTIFICATION_REDIS_CHANNEL`, not to directly interact with users or the database (other than the queue).
5.  **Remove Content Generation:** Delete the `checkUserEngagement` and `sendGrowthInsights` methods entirely. This logic is the responsibility of the `InsightEngine`.
6.  **Refactor `proactive_prompts` Logic:** Remove the `processProactivePrompts` method. We will create a separate ticket to re-home this valuable logic in a more appropriate service.
7.  **Simplify and Focus:** The new implementation will be dramatically simpler, adhering to the single responsibility principle.

---

### **Corrected V11.0 `NotificationWorker.ts` Specification**

Here is what the file *should* look like, based on our architectural design.

```typescript
// workers/notification-worker/src/NotificationWorker.ts
// CORRECT V11.0 IMPLEMENTATION

import { Worker, Job } from 'bullmq';
import { Redis } from 'ioredis';
import { NewCardAvailablePayload, GraphProjectionUpdatedPayload, SSEMessage } from '@2dots1line/shared-types';

const NOTIFICATION_QUEUE_NAME = 'notification-queue';
const REDIS_PUB_SUB_CHANNEL = process.env.NOTIFICATION_REDIS_CHANNEL || 'sse_notifications_channel';

// Define the types of jobs this worker can process
type NotificationJobPayload = NewCardAvailablePayload | GraphProjectionUpdatedPayload;

export class NotificationWorker {
  private worker: Worker;
  private publisher: Redis;

  constructor(redisConnection: Redis) {
    // A single Redis connection can be used for both BullMQ and Pub/Sub
    this.publisher = redisConnection.duplicate(); // Duplicate connection for non-blocking publishing

    this.worker = new Worker<NotificationJobPayload>(
      NOTIFICATION_QUEUE_NAME,
      this.processJob.bind(this),
      { connection: redisConnection }
    );
  }

  public initialize(): void {
    console.log('[NotificationWorker] Initialized and listening to notification-queue.');

    this.worker.on('completed', (job: Job) => {
      console.log(`[NotificationWorker] ✅ Completed job ${job.id} of type ${job.data.type}`);
    });

    this.worker.on('failed', (job: Job | undefined, err: Error) => {
      if (job) {
        console.error(`[NotificationWorker] ❌ Failed job ${job.id} of type ${job.data.type}`, err);
      } else {
        console.error(`[NotificationWorker] ❌ A job failed with no job data`, err);
      }
    });
  }

  /**
   * Main job processing function. This is the heart of the worker.
   */
  private async processJob(job: Job<NotificationJobPayload>): Promise<void> {
    const { type, userId } = job.data;
    let sseMessage: SSEMessage | null = null;

    switch (type) {
      case 'new_card_available':
        sseMessage = this.formatNewCardMessage(job.data as NewCardAvailablePayload);
        break;
      case 'graph_projection_updated':
        sseMessage = this.formatGraphUpdateMessage(job.data as GraphProjectionUpdatedPayload);
        break;
      default:
        console.warn(`[NotificationWorker] Received unknown job type: ${(job.data as any).type}`);
        return; // Acknowledge and drop unknown jobs
    }

    if (sseMessage) {
      // Publish the formatted message to the Redis Pub/Sub channel.
      // The API Gateway will handle the final delivery.
      await this.publisher.publish(REDIS_PUB_SUB_CHANNEL, JSON.stringify(sseMessage));
    }
  }

  /**
   * Formats the SSE message for a new card.
   */
  private formatNewCardMessage(payload: NewCardAvailablePayload): SSEMessage {
    return {
      userId: payload.userId,
      event: 'new_card', // Event name the frontend listens for
      data: JSON.stringify({
        cardId: payload.card.card_id,
        cardType: payload.card.card_type,
        title: payload.card.display_data.title,
      }),
    };
  }

  /**
   * Formats the SSE message for a graph update.
   */
  private formatGraphUpdateMessage(payload: GraphProjectionUpdatedPayload): SSEMessage {
    return {
      userId: payload.userId,
      event: 'graph_updated', // Event name the frontend listens for
      data: JSON.stringify({
        version: payload.projection.version,
        nodeCount: payload.projection.nodeCount,
      }),
    };
  }

  public async stop(): Promise<void> {
    console.log('[NotificationWorker] Stopping...');
    await this.worker.close();
    await this.publisher.quit();
    console.log('[NotificationWorker] Stopped.');
  }
}
```

This corrected version is architecturally sound, adheres to the V11.0 specifications, and fulfills its designated role perfectly. It is lean, focused, and scalable. Please proceed with this implementation.# 