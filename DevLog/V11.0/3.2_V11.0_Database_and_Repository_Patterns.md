### **`3.2_V11.0_Database_and_Repository_Patterns.md`**

---

# **V11.0 Database and Repository Patterns**

**Document Version:** 11.3+ (Headless Service Architecture with Official Prisma Convention)
**Purpose:** To define the database access patterns and repository layer specifications for the 2dots1line V11.0 platform, emphasizing headless service integration and the official lowercase_plural Prisma accessor pattern.

**üî• TECH LEAD DECISION V11.3+**: The project officially adopts and documents the `lowercase_plural` Prisma accessor pattern (e.g., `prisma.users`, `prisma.conversations`) as our standard. This pragmatic decision prioritizes stability and forward momentum over cosmetic schema refactoring. All new code MUST use this pattern.

## **1. Overview and V11.0 Architecture**

The V11.0 Database layer implements a **Repository Pattern** with **headless database services** that are directly imported and used by business logic services. This architecture provides clean separation of concerns while maintaining high performance through direct method calls.

### **1.1 Key V11.0 Changes**
- **Headless Repository Pattern:** Repositories are pure TypeScript libraries
- **Direct Database Injection:** Database services injected into repositories at construction
- **Correct Prisma Accessors:** All Prisma model accessors use `lowercase_plural` format
- **Unified Database Interface:** Single DatabaseService orchestrates multiple database types
- **Transaction Support:** Cross-database transaction coordination

### **1.2 Database Architecture**

```typescript
// V11.0 Database Layer Architecture (All Headless)

packages/database/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ DatabaseService.ts         # Main orchestrator
‚îÇ   ‚îú‚îÄ‚îÄ prisma-client.ts          # Prisma singleton
‚îÇ   ‚îú‚îÄ‚îÄ services/                 # Database-specific services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PostgresService.ts    # PostgreSQL operations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Neo4jService.ts       # Neo4j graph operations  
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WeaviateService.ts    # Weaviate vector operations
‚îÇ   ‚îî‚îÄ‚îÄ repositories/             # Domain repository layer
‚îÇ       ‚îú‚îÄ‚îÄ UserRepository.ts
‚îÇ       ‚îú‚îÄ‚îÄ ConversationRepository.ts
‚îÇ       ‚îú‚îÄ‚îÄ MemoryRepository.ts
‚îÇ       ‚îú‚îÄ‚îÄ CardRepository.ts
‚îÇ       ‚îú‚îÄ‚îÄ ConceptRepository.ts
‚îÇ       ‚îî‚îÄ‚îÄ GraphProjectionRepository.ts
```

---

## **2. Correct Prisma Accessor Patterns (V11.0)**

### **2.1 Model Access Convention**

**‚úÖ CORRECT V11.0 Pattern (lowercase_plural):**

```typescript
// packages/database/src/repositories/UserRepository.ts

import { PrismaClient } from '@prisma/client';
import { prisma } from '../prisma-client';

export class UserRepository {
  constructor(private db: PrismaClient = prisma) {}

  async findById(id: string): Promise<User | null> {
    // ‚úÖ CORRECT: lowercase_plural accessor
    return await this.db.users.findUnique({
      where: { id },
      include: {
        memory_profile: true,
        conversations: {
          orderBy: { created_at: 'desc' },
          take: 10
        }
      }
    });
  }

  async create(userData: CreateUserInput): Promise<User> {
    // ‚úÖ CORRECT: lowercase_plural accessor
    return await this.db.users.create({
      data: {
        id: userData.id,
        email: userData.email,
        display_name: userData.displayName,
        memory_profile: {
          create: {
            preferences: userData.preferences || {},
            learning_style: userData.learningStyle || 'adaptive'
          }
        }
      },
      include: {
        memory_profile: true
      }
    });
  }

  async updateMemoryProfile(userId: string, profile: MemoryProfileUpdate): Promise<User> {
    // ‚úÖ CORRECT: lowercase_plural accessor
    return await this.db.users.update({
      where: { id: userId },
      data: {
        memory_profile: {
          update: {
            strategic_insights: profile.strategicInsights,
            growth_trajectory: profile.growthTrajectory,
            knowledge_graph_schema: profile.knowledgeGraphSchema
          }
        }
      },
      include: {
        memory_profile: true
      }
    });
  }
}
```

**‚ùå INCORRECT (V9.5 camelCase pattern):**

```typescript
// DO NOT USE - This was the incorrect V9.5 pattern
return await this.db.Users.findUnique({  // ‚ùå Wrong: camelCase
  where: { id }
});
```

### **2.2 All Model Accessors (V11.0 Correct Format)**

```typescript
// ‚úÖ CORRECT V11.0 Prisma Model Accessors

// User management
this.db.users              // User model
this.db.user_profiles      // UserProfile model  
this.db.memory_profiles    // MemoryProfile model

// Conversation management
this.db.conversations      // Conversation model
this.db.messages          // Message model
this.db.conversation_contexts // ConversationContext model

// Knowledge management  
this.db.memory_units      // MemoryUnit model
this.db.concepts          // Concept model
this.db.concept_relations // ConceptRelation model
this.db.growth_events     // GrowthEvent model

// Card and presentation
this.db.cards            // Card model
this.db.card_templates   // CardTemplate model
this.db.user_graph_projections // UserGraphProjection model

// System and configuration
this.db.embedding_jobs   // EmbeddingJob model
this.db.insight_cycles   // InsightCycle model
this.db.user_knowledge_items // UserKnowledgeItem model
```

---

## **3. Repository Implementation Patterns**

### **3.1 ConversationRepository Example**

```typescript
// packages/database/src/repositories/ConversationRepository.ts

export class ConversationRepository {
  constructor(
    private db: PrismaClient = prisma,
    private neo4jService: Neo4jService,
    private redisService: RedisService
  ) {}

  /**
   * V11.0: Get recent conversation history with correct Prisma accessors
   */
  async getRecentHistory(conversationId: string, limit: number = 10): Promise<Message[]> {
    // ‚úÖ CORRECT: lowercase_plural accessors
    return await this.db.messages.findMany({
      where: { 
        conversation_id: conversationId 
      },
      orderBy: { 
        created_at: 'desc' 
      },
      take: limit,
      include: {
        conversation: {
          include: {
            user: {
              select: {
                id: true,
                display_name: true
              }
            }
          }
        }
      }
    });
  }

  /**
   * Add message with cross-database synchronization
   */
  async addMessage(messageData: AddMessageInput): Promise<Message> {
    const message = await this.db.messages.create({
      data: {
        conversation_id: messageData.conversationId,
        content: messageData.content,
        message_type: messageData.type,
        source_card_id: messageData.sourceCardId,
        metadata: messageData.metadata || {}
      },
      include: {
        conversation: true
      }
    });

    // Update conversation last_activity
    await this.db.conversations.update({
      where: { id: messageData.conversationId },
      data: { 
        last_activity_at: new Date(),
        message_count: {
          increment: 1
        }
      }
    });

    return message;
  }

  /**
   * V11.0: Transaction example with correct Prisma patterns
   */
  async endConversation(conversationId: string, summary: ConversationSummary): Promise<Conversation> {
    return await this.db.$transaction(async (tx) => {
      // ‚úÖ CORRECT: Use transaction client with lowercase_plural
      const conversation = await tx.conversations.update({
        where: { id: conversationId },
        data: {
          status: 'ended',
          summary: summary.text,
          ended_at: new Date(),
          metadata: {
            ...summary.metadata,
            endedBy: 'timeout'
          }
        }
      });

      // Update related user statistics
      await tx.users.update({
        where: { id: conversation.user_id },
        data: {
          conversation_count: {
            increment: 1
          },
          last_conversation_at: new Date()
        }
      });

      return conversation;
    });
  }
}
```

### **3.2 MemoryRepository Example**

```typescript
// packages/database/src/repositories/MemoryRepository.ts

export class MemoryRepository {
  constructor(
    private db: PrismaClient = prisma,
    private neo4jService: Neo4jService,
    private weaviateService: WeaviateService
  ) {}

  /**
   * V11.0: Create memory units across all databases
   */
  async createMemoryUnits(units: CreateMemoryUnitInput[]): Promise<MemoryUnit[]> {
    const createdUnits: MemoryUnit[] = [];

    for (const unitData of units) {
      // Create in PostgreSQL with correct accessor
      const pgUnit = await this.db.memory_units.create({
        data: {
          id: unitData.id,
          user_id: unitData.userId,
          conversation_id: unitData.conversationId,
          content: unitData.content,
          memory_type: unitData.type,
          importance_score: unitData.importanceScore,
          extracted_at: new Date(),
          metadata: unitData.metadata || {}
        }
      });

      // Create in Neo4j
      await this.neo4jService.createNode('MemoryUnit', {
        id: pgUnit.id,
        userId: pgUnit.user_id,
        content: pgUnit.content,
        type: pgUnit.memory_type,
        importance: pgUnit.importance_score,
        createdAt: pgUnit.extracted_at.toISOString()
      });

      // Create vector embedding in Weaviate
      await this.weaviateService.createObject('UserKnowledgeItem', {
        id: pgUnit.id,
        userId: pgUnit.user_id,
        content: pgUnit.content,
        type: 'memory_unit',
        metadata: pgUnit.metadata
      });

      createdUnits.push(pgUnit);
    }

    return createdUnits;
  }

  /**
   * Find related memories using hybrid search
   */
  async findRelatedMemories(
    userId: string, 
    keyPhrases: string[], 
    maxResults: number = 10
  ): Promise<MemoryUnit[]> {
    // Get vector similarity matches from Weaviate
    const vectorMatches = await this.weaviateService.nearTextSearch({
      concepts: keyPhrases,
      limit: maxResults * 2,
      where: {
        path: ['userId'],
        operator: 'Equal',
        valueText: userId
      }
    });

    // Get IDs and fetch full records from PostgreSQL
    const memoryIds = vectorMatches.map(match => match.id);
    
    if (memoryIds.length === 0) return [];

    // ‚úÖ CORRECT: lowercase_plural accessor
    return await this.db.memory_units.findMany({
      where: {
        id: { in: memoryIds },
        user_id: userId
      },
      orderBy: {
        importance_score: 'desc'
      },
      take: maxResults,
      include: {
        user: {
          select: {
            id: true,
            display_name: true
          }
        },
        conversation: {
          select: {
            id: true,
            started_at: true
          }
        }
      }
    });
  }
}
```

### **3.3 CardRepository Example**

```typescript
// packages/database/src/repositories/CardRepository.ts

export class CardRepository {
  constructor(private db: PrismaClient = prisma) {}

  /**
   * V11.0: Create cards with proper foreign key relationships
   */
  async createCard(cardData: CreateCardInput): Promise<Card> {
    // ‚úÖ CORRECT: lowercase_plural accessor
    return await this.db.cards.create({
      data: {
        id: cardData.id,
        user_id: cardData.userId,
        source_memory_id: cardData.sourceMemoryId,
        source_concept_id: cardData.sourceConceptId,
        card_type: cardData.type,
        title: cardData.title,
        content: cardData.content,
        display_data: cardData.displayData,
        metadata: cardData.metadata || {},
        created_at: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            display_name: true
          }
        },
        source_memory: {
          select: {
            id: true,
            content: true,
            memory_type: true
          }
        },
        source_concept: {
          select: {
            id: true,
            name: true,
            concept_type: true
          }
        }
      }
    });
  }

  /**
   * Get user's active cards with pagination
   */
  async getUserCards(
    userId: string, 
    offset: number = 0, 
    limit: number = 20
  ): Promise<{ cards: Card[], total: number }> {
    const [cards, total] = await Promise.all([
      // ‚úÖ CORRECT: lowercase_plural accessor
      this.db.cards.findMany({
        where: {
          user_id: userId,
          is_active: true
        },
        orderBy: {
          created_at: 'desc'
        },
        skip: offset,
        take: limit,
        include: {
          source_memory: {
            select: {
              content: true,
              memory_type: true
            }
          },
          source_concept: {
            select: {
              name: true,
              concept_type: true
            }
          }
        }
      }),
      // ‚úÖ CORRECT: lowercase_plural accessor  
      this.db.cards.count({
        where: {
          user_id: userId,
          is_active: true
        }
      })
    ]);

    return { cards, total };
  }
}
```

---

## **4. Database Service Layer**

### **4.1 Main DatabaseService Orchestrator**

```typescript
// packages/database/src/DatabaseService.ts

export class DatabaseService {
  constructor(
    private postgresService: PostgresService,
    private neo4jService: Neo4jService,
    private weaviateService: WeaviateService,
    private redisService: RedisService
  ) {}

  /**
   * V11.0: Initialize all database connections
   */
  async initialize(): Promise<void> {
    await Promise.all([
      this.postgresService.connect(),
      this.neo4jService.connect(),
      this.weaviateService.connect(),
      this.redisService.connect()
    ]);
  }

  /**
   * Cross-database transaction coordination
   */
  async executeDistributedTransaction<T>(
    operation: (services: DatabaseServices) => Promise<T>
  ): Promise<T> {
    // Start transaction contexts
    const neo4jSession = this.neo4jService.session();
    const neo4jTx = neo4jSession.beginTransaction();

    try {
      // Execute operation with transaction contexts
      const result = await operation({
        postgres: this.postgresService.getTransactionClient(),
        neo4j: neo4jTx,
        weaviate: this.weaviateService,
        redis: this.redisService
      });

      // Commit all transactions
      await neo4jTx.commit();
      
      return result;
    } catch (error) {
      // Rollback all transactions
      await neo4jTx.rollback();
      throw error;
    } finally {
      await neo4jSession.close();
    }
  }

  /**
   * Health check for all databases
   */
  async healthCheck(): Promise<DatabaseHealthStatus> {
    const [postgres, neo4j, weaviate, redis] = await Promise.allSettled([
      this.postgresService.healthCheck(),
      this.neo4jService.healthCheck(), 
      this.weaviateService.healthCheck(),
      this.redisService.healthCheck()
    ]);

    return {
      postgres: postgres.status === 'fulfilled',
      neo4j: neo4j.status === 'fulfilled',
      weaviate: weaviate.status === 'fulfilled',
      redis: redis.status === 'fulfilled',
      overall: [postgres, neo4j, weaviate, redis].every(result => result.status === 'fulfilled')
    };
  }
}
```

---

## **5. V11.0 Integration Patterns**

### **5.1 Service Integration (Headless)**

```typescript
// services/dialogue-service/src/PromptBuilder.ts

export class PromptBuilder {
  constructor(
    private userRepository: UserRepository,      // ‚úÖ Direct repository injection
    private conversationRepository: ConversationRepository,
    private memoryRepository: MemoryRepository
  ) {}

  async buildPrompt(input: BuildPromptInput): Promise<PromptContext> {
    // Direct repository method calls - no HTTP overhead
    const [userProfile, conversationHistory] = await Promise.all([
      this.userRepository.findById(input.userId),
      this.conversationRepository.getRecentHistory(input.conversationId, 10)
    ]);

    // Build prompt context...
  }
}
```

### **5.2 API Gateway Integration**

```typescript
// apps/api-gateway/src/controllers/conversation.controller.ts

export class ConversationController {
  constructor(
    private conversationRepository: ConversationRepository,
    private userRepository: UserRepository
  ) {}

  async processMessage(req: Request, res: Response): Promise<void> {
    // Direct repository access - no service HTTP calls
    const user = await this.userRepository.findById(req.user.id);
    
    // Add message using repository
    await this.conversationRepository.addMessage({
      conversationId: req.body.conversationId,
      userId: req.user.id,
      content: req.body.messageContent,
      type: 'user'
    });

    // Process with DialogueAgent...
  }
}
```

---

## **6. Migration Notes from V9.5**

### **6.1 Prisma Accessor Changes**

**Required Updates:**

```typescript
// V9.5 ‚Üí V11.0 Migration Examples

// ‚ùå V9.5 (Incorrect)          ‚Üí  ‚úÖ V11.0 (Correct)
this.db.Users                  ‚Üí  this.db.users
this.db.Conversations          ‚Üí  this.db.conversations  
this.db.Messages               ‚Üí  this.db.messages
this.db.MemoryUnits           ‚Üí  this.db.memory_units
this.db.Concepts              ‚Üí  this.db.concepts
this.db.Cards                 ‚Üí  this.db.cards
this.db.UserProfiles          ‚Üí  this.db.user_profiles
this.db.ConversationContexts  ‚Üí  this.db.conversation_contexts
```

### **6.2 Repository Injection Pattern**

```typescript
// V11.0: All repositories injected as constructor dependencies
constructor(
  private userRepository: UserRepository,        // Direct injection
  private conversationRepository: ConversationRepository,
  private memoryRepository: MemoryRepository
) {}
```

### **6.3 Error Handling**

```typescript
// V11.0: Database errors propagate naturally
try {
  const user = await this.userRepository.findById(userId);
} catch (error) {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    // Handle specific Prisma errors
  }
  throw new DatabaseError('User lookup failed', error);
}
```

This V11.0 database and repository pattern specification ensures consistent, performant, and maintainable data access across the entire platform while leveraging the benefits of the headless service architecture. 