/**
 * Reusable entity lookup utilities
 * Shared between CosmosLookupScene and LiveQuestScene
 */

export interface LookupConfig {
  graphHops: number;
  similarityThreshold: number;
  enableGraphHops: boolean;
}

export interface LookupResult {
  nodes: any[];
  edges: any[];
  foundEntity?: any;
  similarEntities: any[];
  connectedEntities: any[];
  totalEntities: number;
}

export interface GraphProjection {
  version: string;
  createdAt: string;
  nodeCount: number;
  edgeCount: number;
  nodes: any[];
  edges: any[];
  communities: any[];
  metadata: any;
}

/**
 * Get embedding for a text phrase using the shared embedding service
 * This reuses embeddings generated by HRT to avoid duplication
 */
const getEmbedding = async (text: string, userId: string = 'dev-user'): Promise<number[]> => {
  try {
    // Call the shared embedding service via API
    const response = await fetch('http://localhost:3001/api/v1/embedding/generate', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text: text,
        userId: userId
      })
    });

    if (!response.ok) {
      throw new Error(`Embedding API error: ${response.status} ${response.statusText}`);
    }

    const result = await response.json();
    if (!result.success || !result.data?.vector) {
      throw new Error(`Embedding generation failed: ${result.error?.message || 'Unknown error'}`);
    }

    return result.data.vector;
  } catch (error) {
    console.error('Failed to get embedding from shared service:', error);
    throw error;
  }
};

/**
 * Find similar entities using key phrases as embedding vectors in Weaviate
 * Generates embeddings for key phrases and uses nearVector for semantic similarity search
 */
export const findSimilarEntitiesByKeyPhrases = async (
  phrases: string[], 
  threshold: number,
  limit: number = 50
): Promise<any[]> => {
  try {
    const allSimilarEntities: any[] = [];
    
    for (const phrase of phrases) {
      console.log(`üîç EntityLookup: Generating embedding for key phrase: "${phrase}"`);
      
      // Get embedding from shared service (reuses HRT embeddings)
      const embedding = await getEmbedding(phrase, 'dev-user');
      console.log(`üîç EntityLookup: Generated ${embedding.length}-dimensional vector for "${phrase}"`);
      
      // Use nearVector search with the generated embedding
      const similarityResponse = await fetch('http://localhost:8080/v1/graphql', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: `
            {
              Get {
                UserKnowledgeItem(
                  nearVector: {
                    vector: [${embedding.join(',')}]
                    distance: ${threshold}
                  }
                  limit: ${limit}
                ) {
                  _additional {
                    id
                    distance
                  }
                  entity_id
                  title
                  content
                  entity_type
                }
              }
            }
          `
        }),
      });

      const similarityResult = await similarityResponse.json();
      console.log(`üîç EntityLookup: Vector similarity result for "${phrase}":`, similarityResult);
      
      if (similarityResult.data?.Get?.UserKnowledgeItem?.length) {
        const entities = similarityResult.data.Get.UserKnowledgeItem.map((entity: any) => ({
          ...entity,
          keyPhrase: phrase,
          semanticScore: 1.0 - entity._additional.distance
        }));
        
        allSimilarEntities.push(...entities);
      }
    }

    // Remove duplicates and sort by semantic score
    const uniqueEntities = allSimilarEntities.reduce((acc: any[], entity: any) => {
      const existing = acc.find(e => e.entity_id === entity.entity_id);
      if (!existing) {
        acc.push(entity);
      } else if (entity.semanticScore > existing.semanticScore) {
        const index = acc.indexOf(existing);
        acc[index] = entity;
      }
      return acc;
    }, []);

    console.log(`üîç EntityLookup: Found ${uniqueEntities.length} unique entities from key phrase vectors`);
    return uniqueEntities.sort((a, b) => b.semanticScore - a.semanticScore);

  } catch (error) {
    console.error('Weaviate vector similarity search failed:', error);
    return [];
  }
};

/**
 * Find connected entities and relationships via Neo4j graph traversal
 */
export const findConnectedEntitiesAndRelationships = async (
  entityIds: string[], 
  userId: string = 'dev-user',
  graphHops: number = 2
): Promise<{connectedEntityIds: string[], relationships: any[]}> => {
  console.log('üîç EntityLookup: Finding connected entities and relationships via Neo4j graph traversal');
  
  try {
    // First, get connected entities
    const connectedEntitiesQuery = `
      UNWIND $seedIds AS seedId
      MATCH (startNode { entity_id: seedId, user_id: $userId })
      CALL {
        WITH startNode
        MATCH p=(startNode)-[*1..${graphHops}]-(relatedNode)
        WHERE relatedNode.user_id = $userId
        RETURN DISTINCT relatedNode.entity_id AS nodeId, relatedNode.entity_type AS nodeType
        LIMIT toInteger($limit)
      }
      RETURN COLLECT(DISTINCT {id: nodeId, type: nodeType}) + [id IN $seedIds | {id: id, type: 'Seed'}] AS allRelevantEntities
    `;

    const connectedResponse = await fetch('http://localhost:3001/api/v1/neo4j/query', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        cypher: connectedEntitiesQuery,
        params: {
          seedIds: entityIds,
          userId,
          limit: 1000
        }
      }),
    });

    const connectedResult = await connectedResponse.json();
    console.log('üîç EntityLookup: Neo4j connected entities result:', connectedResult);

    if (!connectedResult.success || !connectedResult.data) {
      console.warn('üîç EntityLookup: Neo4j connected entities query failed');
      return { connectedEntityIds: [], relationships: [] };
    }

    // Extract connected entity IDs
    const allEntityIds: string[] = [];
    for (const record of connectedResult.data) {
      const entities = record.allRelevantEntities || [];
      for (const entity of entities) {
        if (entity.id) {
          allEntityIds.push(entity.id);
        }
      }
    }

    const connectedEntityIds = allEntityIds.filter(id => !entityIds.includes(id));

    // Now get relationships between all entities
    const relationshipsQuery = `
      UNWIND $entityIds AS entityId
      MATCH (a { entity_id: entityId, user_id: $userId })-[r]->(b)
      WHERE b.entity_id IN $entityIds AND b.user_id = $userId
      RETURN a.entity_id as source, b.entity_id as target, type(r) as type,
             r.relationship_id as relationship_id,
             r.relationship_type as relationship_type,
             r.strength as strength,
             r.weight as weight,
             r.description as description,
             r.source_agent as source_agent,
             r.created_at as created_at
      LIMIT 100
    `;

    const relationshipsResponse = await fetch('http://localhost:3001/api/v1/neo4j/query', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        cypher: relationshipsQuery,
        params: {
          entityIds: allEntityIds,
          userId
        }
      }),
    });

    const relationshipsResult = await relationshipsResponse.json();
    console.log('üîç EntityLookup: Neo4j relationships result:', relationshipsResult);

    const relationships = relationshipsResult.success && relationshipsResult.data ? relationshipsResult.data : [];

    console.log('üîç EntityLookup: Found connected entities and relationships:', {
      originalCount: entityIds.length,
      connectedCount: connectedEntityIds.length,
      totalEntities: allEntityIds.length,
      relationshipCount: relationships.length,
      connectedIds: connectedEntityIds.slice(0, 10),
      relationships: relationships.slice(0, 5),
      success: connectedEntityIds.length > 0 ? 'Graph hops successful!' : 'No graph connections found'
    });

    return { connectedEntityIds, relationships };
  } catch (error) {
    console.error('üîç EntityLookup: Neo4j graph traversal error:', error);
    return { connectedEntityIds: [], relationships: [] };
  }
};

/**
 * Get full entity data from PostgreSQL
 */
export const fetchEntityData = async (entityIds: string[]): Promise<{nodes: any[], edges: any[]}> => {
  try {
    const batchResponse = await fetch('http://localhost:3001/api/v1/cosmos/query', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        setFilters: { nodeIds: entityIds },
        options: { includeEdges: true },
      }),
    });

    const batchResult = await batchResponse.json();
    console.log('üîç EntityLookup: Batch API response:', {
      success: batchResult.success,
      nodeCount: batchResult.data?.nodes?.length || 0,
      edgeCount: batchResult.data?.edges?.length || 0,
    });

    if (!batchResult.success || !batchResult.data?.nodes) {
      throw new Error('Failed to fetch entity data from API');
    }

    return {
      nodes: batchResult.data.nodes,
      edges: batchResult.data.edges || []
    };
  } catch (error) {
    console.error('üîç EntityLookup: Failed to fetch entity data:', error);
    return { nodes: [], edges: [] };
  }
};

/**
 * Create a proper UserGraphProjection object
 */
export const createGraphProjection = (
  nodes: any[], 
  edges: any[], 
  metadata: any = {},
  positionScale: number = 1
): GraphProjection => {
  return {
    version: '1.0',
    createdAt: new Date().toISOString(),
    nodeCount: nodes.length,
    edgeCount: edges.length,
    nodes: nodes.map(node => {
      const px = Number(node.position_x ?? node.x ?? 0) * positionScale;
      const py = Number(node.position_y ?? node.y ?? 0) * positionScale;
      const pz = Number(node.position_z ?? node.z ?? 0) * positionScale;

      return ({
        id: node.id,
        type: (node.entity_type || node.entityType || 'concept') as 'Concept' | 'MemoryUnit' | 'DerivedArtifact',
        label: node.title || node.label || node.id,
        position_x: px,
        position_y: py,
        position_z: pz,
        x: px,
        y: py,
        z: pz,
        position: [px, py, pz] as [number, number, number],
        title: node.title,
        content: node.content,
        community_id: node.community_id || 'default',
        metadata: node.metadata || {}
      });
    }),
    edges: edges.map(edge => ({
      id: edge.id || `${edge.source}-${edge.target}`,
      source: edge.source,
      target: edge.target,
      type: edge.type || 'related',
      weight: edge.weight || 1,
      metadata: edge.metadata || {}
    })),
    communities: [],
    metadata: {
      dimension_reduction_algorithm: 'entity_lookup',
      vector_dimensionality: '3d',
      semantic_similarity_threshold: 0.7,
      communities: [],
      ...metadata
    }
  };
};

/**
 * Complete entity lookup workflow using key phrases
 */
export const performKeyPhraseLookup = async (
  keyPhrases: string[],
  config: LookupConfig
): Promise<LookupResult> => {
  console.log('üîç EntityLookup: Starting key phrase lookup:', { keyPhrases, config });
  
  try {
    // Step 1: Find similar entities using key phrases
    const similarEntities = await findSimilarEntitiesByKeyPhrases(
      keyPhrases, 
      config.similarityThreshold
    );
    
    if (similarEntities.length === 0) {
      return {
        nodes: [],
        edges: [],
        similarEntities: [],
        connectedEntities: [],
        totalEntities: 0
      };
    }

    const semanticEntityIds = similarEntities.map((entity: any) => entity.entity_id);
    
    // Step 2: Find connected entities and relationships via Neo4j (if enabled)
    let connectedEntityIds: string[] = [];
    let neo4jRelationships: any[] = [];
    
    if (config.enableGraphHops) {
      const graphResult = await findConnectedEntitiesAndRelationships(
        semanticEntityIds, 
        'dev-user', 
        config.graphHops
      );
      connectedEntityIds = graphResult.connectedEntityIds;
      neo4jRelationships = graphResult.relationships;
    }

    // Step 3: Combine all entity IDs and fetch full entity data
    const allEntityIds = [...new Set([...semanticEntityIds, ...connectedEntityIds])];
    
    const { nodes, edges: postgresEdges } = await fetchEntityData(allEntityIds);
    
    // Step 4: Combine PostgreSQL edges with Neo4j relationships
    const allEdges = [
      ...postgresEdges,
      ...neo4jRelationships.map((rel: any, index: number) => ({
        id: rel.relationship_id || `${rel.source}-${rel.target}-${rel.type || 'related'}-${index}`,
        source: rel.source,
        target: rel.target,
        type: rel.relationship_type || rel.type || 'related',
        weight: rel.strength || rel.weight || 1.0,
        strength: rel.strength || rel.weight || 1.0,
        description: rel.description,
        source_agent: rel.source_agent,
        created_at: rel.created_at
      }))
    ];

    // Step 5: Prepare entities for display
    const displayEntities = nodes.map((entity: any) => {
      const semanticEntity = similarEntities.find((se: any) => se.entity_id === entity.id);
      const semanticScore = semanticEntity ? semanticEntity.semanticScore : 0;
      const isConnected = connectedEntityIds.includes(entity.id);
      
      return {
        ...entity,
        semanticScore,
        isConnected
      };
    });

    console.log('üîç EntityLookup: Key phrase lookup completed:', {
      keyPhrases: keyPhrases.length,
      similarEntities: similarEntities.length,
      connectedCount: connectedEntityIds.length,
      totalDisplayedEntities: displayEntities.length,
      totalEdges: allEdges.length,
      neo4jRelationships: neo4jRelationships.length
    });

    return {
      nodes: displayEntities,
      edges: allEdges,
      similarEntities: displayEntities.slice(0, 10).map((entity: any) => ({
        id: entity.id,
        title: entity.title,
        type: entity.entity_type,
        semanticScore: entity.semanticScore,
        isConnected: entity.isConnected
      })),
      connectedEntities: displayEntities.filter((entity: any) => entity.isConnected).slice(0, 10).map((entity: any) => ({
        id: entity.id,
        title: entity.title,
        type: entity.entity_type,
        semanticScore: entity.semanticScore
      })),
      totalEntities: displayEntities.length
    };

  } catch (error) {
    console.error('üîç EntityLookup: Key phrase lookup failed:', error);
    return {
      nodes: [],
      edges: [],
      similarEntities: [],
      connectedEntities: [],
      totalEntities: 0
    };
  }
};
